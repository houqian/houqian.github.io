<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>声明式接口调用：Feign源码剖析（2）基于JDK动态代理构建FeignClient的过程 | 且听风吟</title>
  <meta name="author" content="侯乾">
  
  <meta name="description" content="上文我们已经分析到FeignClientFactoryBean#getTarget()方法，这里完成了FeignClient动态代理的创建。但并未分析具体的创建过程，本文将深入Feign Core将FeignClient到底是如何被创建出来的给摸清楚。">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="声明式接口调用：Feign源码剖析（2）基于JDK动态代理构建FeignClient的过程">
  <meta property="og:site_name" content="且听风吟">

  
    <meta property="og:image" content="">
  

  
  
    <link href="/blog/favicon.png" rel="icon">
  

  <!-- CSS -->
  <link rel="stylesheet" href="/blog/css/themes/cerulean.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/blog/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/blog/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/blog/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/blog/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/blog/css/highlight-default.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/blog/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/blog/css/comment.css" media="screen" type="text/css">
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.9/es5-shim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.7/es5-sham.min.js"></script>
  <![endif]-->

  <script src="/blog/js/jquery-2.0.3.min.js"></script>
  
  <!-- analytics -->
  



<link rel="alternate" href="/blog/atom.xml" title="且听风吟" type="application/atom+xml">
</head>

<body>
  <nav id="main-nav" class="navbar navbar-inverse navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
	<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
       <a class="navbar-brand" href="/blog/">且听风吟</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/blog/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>归档
			</a>
		  </li>
		  
		  <li>
			<a href="/blog/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>分类
			</a>
		  </li>
		  
		  <li>
			<a href="/blog/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>标签
			</a>
		  </li>
		  
		  <li>
			<a href="/blog/about" title="91年人，喜欢声乐，想养一只猫">
			  <i class="fa fa-user"></i>关于
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
    <div class="content">
      


	
		<div class="page-header page-header-inverse ">		
			<h1 class="title title-inverse "> 声明式接口调用：Feign源码剖析（2）基于JDK动态代理构建FeignClient的过程</h1>
		</div>		
	






<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>上文我们已经分析到<code>FeignClientFactoryBean#getTarget()</code>方法，这里完成了FeignClient动态代理的创建。但并未分析具体的创建过程，本文将深入Feign Core将FeignClient到底是如何被创建出来的给摸清楚。</p>
</blockquote>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HystrixTargeter</span> <span class="keyword">implements</span> <span class="title">Targeter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(FeignClientFactoryBean factory, Feign.Builder feign,</span></span></span><br><span class="line"><span class="function"><span class="params">         FeignContext context, Target.HardCodedTarget&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!(feign <span class="keyword">instanceof</span> feign.hystrix.HystrixFeign.Builder)) &#123;</span><br><span class="line">         <span class="keyword">return</span> feign.target(target);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们此时并未整合Hystrix，所以此处的feign还是<code>Feign.Builder</code>，此处直接走他的target方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Feign</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> InvocationHandlerFactory invocationHandlerFactory =</span><br><span class="line">            <span class="keyword">new</span> InvocationHandlerFactory.Default();</span><br><span class="line"></span><br><span class="line">    	<span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(Target&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> build().newInstance(target);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Feign <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          SynchronousMethodHandler.Factory synchronousMethodHandlerFactory =</span><br><span class="line">              <span class="keyword">new</span> SynchronousMethodHandler.Factory(client, retryer, requestInterceptors, logger,</span><br><span class="line">                  logLevel, decode404, closeAfterDecode, propagationPolicy);</span><br><span class="line">          ParseHandlersByName handlersByName =</span><br><span class="line">              <span class="keyword">new</span> ParseHandlersByName(contract, options, encoder, decoder, queryMapEncoder,</span><br><span class="line">                  errorDecoder, synchronousMethodHandlerFactory);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> ReflectiveFeign(handlersByName, invocationHandlerFactory, queryMapEncoder);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>SynchronousMethodHandler</code><br>
同步方法处理器</p>
</li>
<li>
<p>invocationHandlerFactory<br>
invocationHandler这东西怎么这么眼熟呢，这不是JDK动态代理那个套路里的接口吗？我们一探究竟</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Default</span> <span class="keyword">implements</span> <span class="title">InvocationHandlerFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> InvocationHandler <span class="title">create</span><span class="params">(Target target, Map&lt;Method, MethodHandler&gt; dispatch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReflectiveFeign.FeignInvocationHandler(target, dispatch);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>这包裹的层次够深的，我们看看这个<code>FeignInvoccationHandler</code>是啥</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Target target;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MethodHandler&gt; dispatch;</span><br><span class="line"></span><br><span class="line">  FeignInvocationHandler(Target target, Map&lt;Method, MethodHandler&gt; dispatch) &#123;</span><br><span class="line">    <span class="keyword">this</span>.target = checkNotNull(target, <span class="string">"target"</span>);</span><br><span class="line">    <span class="keyword">this</span>.dispatch = checkNotNull(dispatch, <span class="string">"dispatch for %s"</span>, target);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"equals"</span>.equals(method.getName())) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Object otherHandler =</span><br><span class="line">            args.length &gt; <span class="number">0</span> &amp;&amp; args[<span class="number">0</span>] != <span class="keyword">null</span> ? Proxy.getInvocationHandler(args[<span class="number">0</span>]) : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> equals(otherHandler);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"hashCode"</span>.equals(method.getName())) &#123;</span><br><span class="line">      <span class="keyword">return</span> hashCode();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"toString"</span>.equals(method.getName())) &#123;</span><br><span class="line">      <span class="keyword">return</span> toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dispatch.get(method).invoke(args);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>到此，终于真相大白，验证了我们根据命名得到的猜测，这确实是使用了JDK的动态代理技术，这个invoke方法我们后续再分析，其实也不难推测，无非是拦截对ServiceAClient的方法的调用，委托到这个<code>FeignInvocationHandler#invoke()</code>，然后执行feign的逻辑，最后就是调用底层的一个HTTP客户端，根据我们的<code>RequestMapping</code>等注解里的参数拼接一个HTTP Request，发送出去罢了</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>接上<code>build().newInstance(target)</code>，<code>build()</code>出了一个<code>ReflectiveFeign</code>对象，然后调用它的<code>newInstance()</code>方法，在这里，最终完成了基于JDK动态代理的FeignClient的创建</p>
</li>
</ul>
<h1 id="柳暗花明-看reflectivefeign-newinstance"><a class="header-anchor" href="#柳暗花明-看reflectivefeign-newinstance"></a>柳暗花明，看<code>ReflectiveFeign#newInstance()</code></h1>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReflectiveFeign</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    <span class="title">public</span> &lt;<span class="title">T</span>&gt; <span class="title">T</span> <span class="title">newInstance</span>(<span class="title">Target</span>&lt;<span class="title">T</span>&gt; <span class="title">target</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 这个apply会调用SpringMvcContract将注解都解析出来，放到Feign的RequestTemplate中去</span></span><br><span class="line">      Map&lt;String, MethodHandler&gt; nameToHandler = targetToHandlersByName.apply(target);</span><br><span class="line">      Map&lt;Method, MethodHandler&gt; methodToHandler = <span class="keyword">new</span> LinkedHashMap&lt;Method, MethodHandler&gt;();</span><br><span class="line">      List&lt;DefaultMethodHandler&gt; defaultMethodHandlers = <span class="keyword">new</span> LinkedList&lt;DefaultMethodHandler&gt;();</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 这里就是</span></span><br><span class="line">      <span class="keyword">for</span> (Method method : target.type().getMethods()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Util.isDefault(method)) &#123;</span><br><span class="line">          DefaultMethodHandler handler = <span class="keyword">new</span> DefaultMethodHandler(method);</span><br><span class="line">          defaultMethodHandlers.add(handler);</span><br><span class="line">          methodToHandler.put(method, handler);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 就是简单的组装了一个ServiceAClient中方法对象 -&gt;  SynchronousMethodHandler的映射</span></span><br><span class="line">          methodToHandler.put(method, nameToHandler.get(Feign.configKey(target.type(), method)));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 接下来就是最后的基于JDK动态代理创建Proxy对象实例了</span></span><br><span class="line">      InvocationHandler handler = factory.create(target, methodToHandler);</span><br><span class="line">      T proxy = (T) Proxy.newProxyInstance(target.type().getClassLoader(),</span><br><span class="line">          <span class="keyword">new</span> Class&lt;?&gt;[] &#123;target.type()&#125;, handler);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (DefaultMethodHandler defaultMethodHandler : defaultMethodHandlers) &#123;</span><br><span class="line">        defaultMethodHandler.bindTo(proxy);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>下面的部分是各个步骤的详细剖析，没兴趣的同学可以不看了，在这里已经完成了所有关于FeignClient创建的核心知识了。</strong></p>
</blockquote>
<ul>
<li>
<p>nameToHandler<br>
看名字就可以猜测是什么东西的名称和代理方法处理器的映射</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReflectiveFeign</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">	<span class="title">public</span> <span class="title">Map</span>&lt;<span class="title">String</span>, <span class="title">MethodHandler</span>&gt; <span class="title">apply</span>(<span class="title">Target</span> <span class="title">key</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 这里执行了SpringMvcContract组件的解析SpringMVC注解的逻辑，最后解析后组成了一个List</span></span><br><span class="line">      List&lt;MethodMetadata&gt; metadata = contract.parseAndValidatateMetadata(key.type());</span><br><span class="line">      Map&lt;String, MethodHandler&gt; result = <span class="keyword">new</span> LinkedHashMap&lt;String, MethodHandler&gt;();</span><br><span class="line">      <span class="keyword">for</span> (MethodMetadata md : metadata) &#123;</span><br><span class="line">        BuildTemplateByResolvingArgs buildTemplate;</span><br><span class="line">        <span class="keyword">if</span> (!md.formParams().isEmpty() &amp;&amp; md.template().bodyTemplate() == <span class="keyword">null</span>) &#123;</span><br><span class="line">          buildTemplate = <span class="keyword">new</span> BuildFormEncodedTemplateFromArgs(md, encoder, queryMapEncoder);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (md.bodyIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">          buildTemplate = <span class="keyword">new</span> BuildEncodedTemplateFromArgs(md, encoder, queryMapEncoder);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          buildTemplate = <span class="keyword">new</span> BuildTemplateByResolvingArgs(md, queryMapEncoder);</span><br><span class="line">        &#125;</span><br><span class="line">        result.put(md.configKey(),</span><br><span class="line">            factory.create(key, md, buildTemplate, options, decoder, errorDecoder));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>contract.parseAndValidateMetadata</code><br>
这里就轮到SpringMvcContract组件闪亮登场了，他负责对<code>ReqeustMapping</code>、<code>PathVaraiable</code>等注解的解析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseContract</span> <span class="keyword">implements</span> <span class="title">Contract</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;MethodMetadata&gt; <span class="title">parseAndValidatateMetadata</span><span class="params">(Class&lt;?&gt; targetType)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, MethodMetadata&gt; result = <span class="keyword">new</span> LinkedHashMap&lt;String, MethodMetadata&gt;();</span><br><span class="line">    <span class="comment">// 使用反射，遍历ServiceAClient的每个方法  </span></span><br><span class="line">    <span class="keyword">for</span> (Method method : targetType.getMethods()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (method.getDeclaringClass() == Object.class ||</span><br><span class="line">          (method.getModifiers() &amp; Modifier.STATIC) != <span class="number">0</span> ||</span><br><span class="line">          Util.isDefault(method)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 调用SpringMvcContract来具体处理注解  </span></span><br><span class="line">      MethodMetadata metadata = parseAndValidateMetadata(targetType, method);</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      result.put(metadata.configKey(), metadata);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(result.values());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>通过反射遍历ServiceAClient中的每个方法，然后委托给<code>SpringMvcContract#parseValidateMetadata</code>处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringMvcContract</span> <span class="keyword">extends</span> <span class="title">Contract</span>.<span class="title">BaseContract</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    @<span class="title">Override</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">MethodMetadata</span> <span class="title">parseAndValidateMetadata</span>(<span class="title">Class</span>&lt;?&gt; <span class="title">targetType</span>, <span class="title">Method</span> <span class="title">method</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.processedMethods.put(Feign.configKey(targetType, method), method);</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">// 又调回父类方法了	</span></span><br><span class="line">       MethodMetadata md = <span class="keyword">super</span>.parseAndValidateMetadata(targetType, method);</span><br><span class="line">       RequestMapping classAnnotation = findMergedAnnotation(targetType,</span><br><span class="line">             RequestMapping.class);</span><br><span class="line">       <span class="keyword">if</span> (classAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// produces - use from class annotation only if method has not specified this</span></span><br><span class="line">          <span class="keyword">if</span> (!md.template().headers().containsKey(ACCEPT)) &#123;</span><br><span class="line">             parseProduces(md, method, classAnnotation);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// consumes -- use from class annotation only if method has not specified this</span></span><br><span class="line">          <span class="keyword">if</span> (!md.template().headers().containsKey(CONTENT_TYPE)) &#123;</span><br><span class="line">             parseConsumes(md, method, classAnnotation);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// headers -- class annotation is inherited to methods, always write these if</span></span><br><span class="line">          <span class="comment">// present</span></span><br><span class="line">          parseHeaders(md, method, classAnnotation);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> md;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>Feign的封装当真是山路十八弯，父类子类各种相互调用，这点儿一点也不优雅</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> MethodMetadata <span class="title">parseAndValidateMetadata</span><span class="params">(Class&lt;?&gt; targetType, Method method)</span> </span>&#123;</span><br><span class="line">  MethodMetadata data = <span class="keyword">new</span> MethodMetadata();</span><br><span class="line">  data.returnType(Types.resolve(targetType, targetType, method.getGenericReturnType()));</span><br><span class="line">  data.configKey(Feign.configKey(targetType, method));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (targetType.getInterfaces().length == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//  解析ServiceAClient类上的`RequestMapping`注解 </span></span><br><span class="line">    processAnnotationOnClass(data, targetType.getInterfaces()[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  processAnnotationOnClass(data, targetType);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析ServiceAClient方法上的`RequestMapping`注解	</span></span><br><span class="line">  <span class="keyword">for</span> (Annotation methodAnnotation : method.getAnnotations()) &#123;</span><br><span class="line">    processAnnotationOnMethod(data, methodAnnotation, method);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">  Type[] genericParameterTypes = method.getGenericParameterTypes();</span><br><span class="line"></span><br><span class="line">  Annotation[][] parameterAnnotations = method.getParameterAnnotations();</span><br><span class="line">  <span class="keyword">int</span> count = parameterAnnotations.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> isHttpAnnotation = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (parameterAnnotations[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">      isHttpAnnotation = processAnnotationsOnParameter(data, parameterAnnotations[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (parameterTypes[i] == URI.class) &#123;</span><br><span class="line">      data.urlIndex(i);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isHttpAnnotation &amp;&amp; parameterTypes[i] != Request.Options.class) &#123;</span><br><span class="line">     </span><br><span class="line">      data.bodyIndex(i);</span><br><span class="line">      data.bodyType(Types.resolve(targetType, targetType, genericParameterTypes[i]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解析ServiceAClient类上的<code>RequestMapping</code>注解</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processAnnotationOnClass</span><span class="params">(MethodMetadata data, Class&lt;?&gt; clz)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (clz.getInterfaces().length == <span class="number">0</span>) &#123;</span><br><span class="line">      RequestMapping classAnnotation = findMergedAnnotation(clz,</span><br><span class="line">            RequestMapping.class);</span><br><span class="line">      <span class="keyword">if</span> (classAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// Prepend path from class annotation if specified</span></span><br><span class="line">         <span class="keyword">if</span> (classAnnotation.value().length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            String pathValue = emptyToNull(classAnnotation.value()[<span class="number">0</span>]);</span><br><span class="line">            pathValue = resolve(pathValue);</span><br><span class="line">            <span class="keyword">if</span> (!pathValue.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">               pathValue = <span class="string">"/"</span> + pathValue;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里template()其实是一个RequestTemplate </span></span><br><span class="line">            data.template().uri(pathValue);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这里其实就是将ServiceAClient类上面<code>RequestMapping</code>注解中解析出<code>url</code>，然后将他发到Feign的<code>RequestTemplate</code>组件中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processAnnotationOnMethod</span><span class="params">(MethodMetadata data,</span></span></span><br><span class="line"><span class="function"><span class="params">      Annotation methodAnnotation, Method method)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   RequestMapping methodMapping = findMergedAnnotation(method, RequestMapping.class);</span><br><span class="line">   <span class="comment">// HTTP Method</span></span><br><span class="line">   RequestMethod[] methods = methodMapping.method();</span><br><span class="line">   <span class="comment">// 如果你没有在`RequestMapping`里指定方法类型，那么默认就是GET方法 </span></span><br><span class="line">   <span class="keyword">if</span> (methods.length == <span class="number">0</span>) &#123;</span><br><span class="line">      methods = <span class="keyword">new</span> RequestMethod[] &#123; RequestMethod.GET &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 解析你在`RequestMapping`里指定的method类型，放到RequestTemplate中的method中去</span></span><br><span class="line">   data.template().method(Request.HttpMethod.valueOf(methods[<span class="number">0</span>].name()));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 解析你在RequestMapping中的path，拼接成url，放到RequestTemplate中的URL中去</span></span><br><span class="line">   <span class="keyword">if</span> (methodMapping.value().length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      String pathValue = emptyToNull(methodMapping.value()[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">if</span> (pathValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">         pathValue = resolve(pathValue);</span><br><span class="line">         <span class="comment">// Append path from @RequestMapping if value is present on method</span></span><br><span class="line">         <span class="keyword">if</span> (!pathValue.startsWith(<span class="string">"/"</span>) &amp;&amp; !data.template().path().endsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">            pathValue = <span class="string">"/"</span> + pathValue;</span><br><span class="line">         &#125;</span><br><span class="line">         data.template().uri(pathValue, <span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 解析RequestMapping注解里的produces属性，将这些属性放到RequestTemplate中的header中的ACCEPT值里</span></span><br><span class="line">   parseProduces(data, method, methodMapping);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 解析RequestMappinp注解的consumes属性，将这些属性放到RequestTemplate中的header中的CONTENT_TYPE值的</span></span><br><span class="line">   parseConsumes(data, method, methodMapping);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 解析RequestMapping注解的headers属性，将这些属性放到RequestTemplate中的header键值对里去</span></span><br><span class="line">   parseHeaders(data, method, methodMapping);</span><br><span class="line"></span><br><span class="line">   data.indexToExpander(<span class="keyword">new</span> LinkedHashMap&lt;Integer, Param.Expander&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解析ServiceAClient中方法上的RequestMapping注解里各项属性
<ul>
<li>如果你没有指定方法类型，那么默认就是GET方法</li>
<li>解析method类型，放到RequestTemplate中的method中去</li>
<li>解析path，拼接成url，放到RequestTemplate中的URL中去</li>
<li>解析produces属性，将这些属性放到RequestTemplate中的header中的ACCEPT值里</li>
<li>解析consumes属性，将这些属性放到RequestTemplate中的header中的CONTENT_TYPE值的</li>
<li>解析headers属性，将这些属性放到RequestTemplate中的header键值对里去</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">processAnnotationsOnParameter</span><span class="params">(MethodMetadata data,</span></span></span><br><span class="line"><span class="function"><span class="params">      Annotation[] annotations, <span class="keyword">int</span> paramIndex)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">boolean</span> isHttpAnnotation = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">   AnnotatedParameterProcessor.AnnotatedParameterContext context = <span class="keyword">new</span> SimpleAnnotatedParameterContext(</span><br><span class="line">         data, paramIndex);</span><br><span class="line">   Method method = <span class="keyword">this</span>.processedMethods.get(data.configKey());</span><br><span class="line">   <span class="keyword">for</span> (Annotation parameterAnnotation : annotations) &#123;</span><br><span class="line">      AnnotatedParameterProcessor processor = <span class="keyword">this</span>.annotatedArgumentProcessors</span><br><span class="line">            .get(parameterAnnotation.annotationType());</span><br><span class="line">      <span class="keyword">if</span> (processor != <span class="keyword">null</span>) &#123;</span><br><span class="line">         Annotation processParameterAnnotation;</span><br><span class="line">         <span class="comment">// synthesize, handling @AliasFor, while falling back to parameter name on</span></span><br><span class="line">         <span class="comment">// missing String #value():</span></span><br><span class="line">         processParameterAnnotation = synthesizeWithMethodParameterNameAsFallbackValue(</span><br><span class="line">               parameterAnnotation, method, paramIndex);</span><br><span class="line">         isHttpAnnotation |= processor.processArgument(context,</span><br><span class="line">               processParameterAnnotation, method);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (isHttpAnnotation &amp;&amp; data.indexToExpander().get(paramIndex) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      TypeDescriptor typeDescriptor = createTypeDescriptor(method, paramIndex);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.conversionService.canConvert(typeDescriptor,</span><br><span class="line">            STRING_TYPE_DESCRIPTOR)) &#123;</span><br><span class="line">         Param.Expander expander = <span class="keyword">this</span>.convertingExpanderFactory</span><br><span class="line">               .getExpander(typeDescriptor);</span><br><span class="line">         <span class="keyword">if</span> (expander != <span class="keyword">null</span>) &#123;</span><br><span class="line">            data.indexToExpander().put(paramIndex, expander);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> isHttpAnnotation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>解析ServiceAClient中方法上的入参</p>
<ul>
<li>默认的参数处理器，这几个处理器都是spring-cloud-openfeign-core工程的
<ul>
<li>解析<code>@PathVariable</code>：<code>PathVariableParameterProcessor</code></li>
<li>解析<code>@RequestParam</code>：<code>RequestParamParameterProcessor</code></li>
<li>解析<code>@ReqeustHeader</code>：<code>RequestHeaderParameterProcessor</code></li>
<li>解析<code>@QueryMap</code>:<code>QueryMapParameterProcessor</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>result.put(md.configKey(), factory.create(key, md, buildTemplate, options, decoder, errorDecoder));</code></p>
<ul>
<li>
<p>create方法其实创建了一个<code>SynchronousMethodHandler</code>，将所有和serviceAClient中一个方法相关的东西都放了进去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronousMethodHandler</span></span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">Factory</span></span></span><br><span class="line"><span class="class">        <span class="title">public</span> <span class="title">MethodHandler</span> <span class="title">create</span>(<span class="title">Target</span>&lt;?&gt; <span class="title">target</span>,</span></span><br><span class="line"><span class="class">                                    <span class="title">MethodMetadata</span> <span class="title">md</span>,</span></span><br><span class="line"><span class="class">                                    <span class="title">RequestTemplate</span>.<span class="title">Factory</span> <span class="title">buildTemplateFromArgs</span>,</span></span><br><span class="line"><span class="class">                                    <span class="title">Options</span> <span class="title">options</span>,</span></span><br><span class="line"><span class="class">                                    <span class="title">Decoder</span> <span class="title">decoder</span>,</span></span><br><span class="line"><span class="class">                                    <span class="title">ErrorDecoder</span> <span class="title">errorDecoder</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> SynchronousMethodHandler(target, client, retryer, requestInterceptors, logger,</span><br><span class="line">              logLevel, md, buildTemplateFromArgs, options, decoder,</span><br><span class="line">              errorDecoder, decode404, closeAfterDecode, propagationPolicy);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="总结"><a class="header-anchor" href="#总结"></a>总结</h1>
<p>feign对FeignClient的创建过程，个人觉得封装的并不是很优雅，山路十八弯，各种父子类调用，很容易让源码阅读者绕晕。<br>
按照惯例，笔者放出总结大图一张。<br>
<img src="/blog/blog/2020/05/19/声明式接口调用：Feign源码剖析（2）基于JDK动态代理构建FeignClient的过程/Feign-FeignClient%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B.png" alt="Feign-FeignClient动态代理创建过程"></p>
	  
	</div>

	<!-- recommended posts -->
	

	<div>
  	<center>
	<div class="pagination">
<ul class="pagination">
	 
				
    	<li class="prev"><a href="/blog/2020/05/28/声明式接口调用：Feign源码剖析（3）Feign是如何处理请求的/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i>Prev</a></li>
  		

        <li><a href="/blog/archives"><i class="fa fa-archive"></i>Archive</a></li>

		
		   <li class="next"><a href="/blog/2020/05/10/声明式接口调用：Feign源码剖析（1）@FeignClient注解/" class="alignright next">Next<i class="fa fa-arrow-circle-o-right"></i></a></li>         
        
	
</ul>
</div>

    </center>
	</div>

    <!-- share -->
    
        
    <div class="bdsharebuttonbox">
        <a href="#" class="bds_more" data-cmd="more"></a>
        <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
        <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
        <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
        <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
        <a href="#" class="bds_linkedin" data-cmd="linkedin" title="分享到linkedin"></a>
        <a href="#" class="bds_evernotecn" data-cmd="evernotecn" title="分享到印象笔记"></a>
        <a href="#" class="bds_youdao" data-cmd="youdao" title="分享到有道云笔记"></a>
        <a href="#" class="bds_copy" data-cmd="copy" title="分享到复制网址"></a>
    </div>
    <script>
        window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"1","bdSize":"24"},"share":{}};
        with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
    </script>


        

    
	
	<!-- comment -->
	
<section id="comment">
  <h2 class="title">Comments</h2>
  
</section>


	</div> <!-- col-md-9/col-md-12 -->
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta">
	<!-- hexo-wordcount 字数统计 -->
	<div class="meta-widget">
		<i class="fa fa-bar-chart"></i>
		<span class="post-count">2.2k</span>&nbsp;字
	</div>
	<!-- hexo-wordcount 阅读时长预计 -->
	<div class="meta-widget">
		<i class="fa fa-clock-o"></i>
		<span class="post-count">&nbsp;10</span>&nbsp;分钟
	</div>

	<!-- date -->
	
	<div class="meta-widget">
		<i class="fa fa-calendar-o"></i>
		<span>&nbsp;2020-05-19</span>
	</div>
	

	<!-- categories -->
	
	<div class="meta-widget">
		<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>
		<ul id="categorys" class="tag_box list-unstyled collapse in">
			  
  <li>
    <li><a href="/blog/categories/计算机科学与技术/">计算机科学与技术<span>58</span></a></li>
  </li>

		</ul>
	</div>
	

	<!-- tags -->
	
	<div class="meta-widget">
		<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>
		<ul id="tags" class="tag_box list-unstyled collapse in">
			  
  <li><a href="/blog/tags/Spring-Cloud/">Spring Cloud<span>28</span></a></li> <li><a href="/blog/tags/Spring-Cloud-Netflix/">Spring Cloud Netflix<span>28</span></a></li> <li><a href="/blog/tags/源码剖析/">源码剖析<span>39</span></a></li> <li><a href="/blog/tags/Feign/">Feign<span>7</span></a></li>
		</ul>
	</div>
	

	<!-- toc -->
	<div class="meta-widget">
		
		<a data-toggle="collapse" data-target="#toc"><i class="fa fa-bars"></i></a>
		<div id="toc" class="toc collapse in">
			<ol class="toc-article"><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#柳暗花明-看reflectivefeign-newinstance"><span class="toc-article-text">柳暗花明，看ReflectiveFeign#newInstance()</span></a></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#总结"><span class="toc-article-text">总结</span></a></li></ol>
		</div>
		
	</div>

	<hr>

</div><!-- col-md-3 -->
	</div>
		

</div><!-- row -->



    </div>
  </div>
  <div class="container-narrow">
    <footer> <p>
  &copy; 2021 侯乾
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.    
</p> </footer>
  </div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/blog/js/jquery.imagesloaded.min.js"></script>
<script src="/blog/js/gallery.js"></script>
<script src="/blog/js/bootstrap.min.js"></script>
<script src="/blog/js/main.js"></script>
<script src="/blog/js/search.js"></script> 


<link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/blog/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/blog/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>


<!-- syntax highlighting -->


<script src="/blog/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/blog/live2dw/assets/hijiki.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"react":{"opacity":0.7},"log":false});</script></body>
</html>