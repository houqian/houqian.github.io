<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>一张图澄清架构设计模式</title>
      <link href="/2019/06/01/%E4%B8%80%E5%BC%A0%E5%9B%BE%E6%BE%84%E6%B8%85%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/06/01/%E4%B8%80%E5%BC%A0%E5%9B%BE%E6%BE%84%E6%B8%85%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/06/01/一张图澄清架构设计模式/%E4%B8%80%E5%BC%A0%E5%9B%BE%E6%BE%84%E6%B8%85%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.svg" alt="一张图澄清架构设计模式"></p>]]></content>
      
      
      <categories>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>调用模型</title>
      <link href="/2018/08/30/%E8%B0%83%E7%94%A8%E6%A8%A1%E5%9E%8B/"/>
      <url>/2018/08/30/%E8%B0%83%E7%94%A8%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>提示: 本文是<a href="http://houqian.xyz/2018/08/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/#%E7%AE%97%E6%B3%95%E4%BE%A7">模型部署方案</a>的一部分</p><h1 id="依赖"><a class="header-anchor" href="#依赖"></a>依赖</h1><ul><li>java8</li><li>pmml-evaluator 1.4.2</li><li>pmml-evaluator-extension 1.4.2</li></ul><h1 id="步骤"><a class="header-anchor" href="#步骤"></a>步骤</h1><ol><li><p>使用JPMML执行引擎反序列化pmml文件</p></li><li><p>模型校验（此处具体校验的问题，笔者以后另开一篇）</p></li></ol><a id="more"></a><h1 id="我们开始吧"><a class="header-anchor" href="#我们开始吧"></a>我们开始吧</h1><p>maven依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pmml-evaluator.version</span>&gt;</span>1.4.2<span class="tag">&lt;/<span class="name">pmml-evaluator.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--运行模型--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jpmml<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pmml-evaluator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;pmml-evaluator.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jpmml<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pmml-evaluator-extension<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;pmml-evaluator.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="一网打尽"><a class="header-anchor" href="#一网打尽"></a>一网打尽</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.houqian.jpmml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jpmml.evaluator.*;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.SAXException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.bind.JAXBException;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : houqian</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> : 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> : 2018-08-30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Execute</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JAXBException, SAXException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 从pmml文件实例化模型执行引擎</span></span><br><span class="line">    Evaluator evaluator = <span class="keyword">new</span> LoadingModelEvaluatorBuilder()</span><br><span class="line">            .setLocatable(<span class="keyword">false</span>)</span><br><span class="line">            .setVisitors(<span class="keyword">new</span> DefaultVisitorBattery())</span><br><span class="line">            <span class="comment">//.setOutputFilter(OutputFilters.KEEP_FINAL_RESULTS)</span></span><br><span class="line">            .load(<span class="keyword">new</span> File(<span class="string">"src/main/resources/pipeline.pmml.xml"</span>))</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验模型合法性</span></span><br><span class="line">    evaluator.verify();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入变量</span></span><br><span class="line">    List&lt;? extends InputField&gt; inputFields = evaluator.getInputFields();</span><br><span class="line">    System.out.println(<span class="string">"Input fields: "</span> + inputFields);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标签</span></span><br><span class="line">    List&lt;? extends TargetField&gt; targetFields = evaluator.getTargetFields();</span><br><span class="line">    System.out.println(<span class="string">"Target field(s): "</span> + targetFields);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出变量</span></span><br><span class="line">    List&lt;? extends OutputField&gt; outputFields = evaluator.getOutputFields();</span><br><span class="line">    System.out.println(<span class="string">"Output fields: "</span> + outputFields);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放引用，优化GC</span></span><br><span class="line">    evaluator = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deploy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>加载模型文件</title>
      <link href="/2018/08/30/%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B%E6%96%87%E4%BB%B6/"/>
      <url>/2018/08/30/%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>提示: 本文是<a href="http://houqian.xyz/2018/08/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/#%E7%AE%97%E6%B3%95%E4%BE%A7">模型部署方案</a>的一部分</p><h1 id="依赖"><a class="header-anchor" href="#依赖"></a>依赖</h1><ul><li>java8</li><li>pmml-model 1.4.2</li></ul><h1 id="步骤"><a class="header-anchor" href="#步骤"></a>步骤</h1><ol><li>加载反序列化模型文件为PMML对象</li><li>优化模型，并写到新模型文件</li></ol><a id="more"></a><h1 id="我们开始吧"><a class="header-anchor" href="#我们开始吧"></a>我们开始吧</h1><p>maven依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pmml-model.version</span>&gt;</span>1.4.2<span class="tag">&lt;/<span class="name">pmml-model.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--pmml模型--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jpmml<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pmml-model<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;pmml-model.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="加载模型-更新模型"><a class="header-anchor" href="#加载模型-更新模型"></a>加载模型 &amp; 更新模型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.houqian.jpmml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> org.dmg.pmml.PMML;</span><br><span class="line"><span class="keyword">import</span> org.jpmml.model.PMMLUtil;</span><br><span class="line"><span class="keyword">import</span> org.jpmml.model.visitors.LocatorNullifier;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.SAXException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.bind.JAXBException;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : houqian</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> : 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> : 2018-08-30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Load</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException, JAXBException, SAXException, JsonProcessingException </span>&#123;</span><br><span class="line">    <span class="comment">// 这里的pmml是之前sklearn、sparkml导出的文件，任选其一即可</span></span><br><span class="line">    FileInputStream srcModelIs = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"src/main/resources/pipeline.pmml.xml"</span>));</span><br><span class="line">    PMML pmml = PMMLUtil.unmarshal(srcModelIs);</span><br><span class="line"></span><br><span class="line">    optimize(pmml);</span><br><span class="line"></span><br><span class="line">    FileOutputStream newModelOs = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"src/main/resources/new-pipeline.pmml.xml"</span>));</span><br><span class="line">    store(pmml, newModelOs);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">optimize</span><span class="params">(PMML pmml)</span></span>&#123;</span><br><span class="line">    LocatorNullifier nullifier = <span class="keyword">new</span> LocatorNullifier();</span><br><span class="line">    nullifier.applyTo(pmml);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">store</span><span class="params">(PMML pmml, OutputStream os)</span> <span class="keyword">throws</span> JAXBException </span>&#123;</span><br><span class="line">    org.jpmml.model.PMMLUtil.marshal(pmml, os);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>笔者没有找到如何验证以上操作和模型正确性的关系，现在姑且先让它这样不报错跑通吧。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜  src git:(master) ✗ tree -L 3 </span><br><span class="line">.</span><br><span class="line">├── main</span><br><span class="line">│   ├── java</span><br><span class="line">│   │   ├── com</span><br><span class="line">│   │   └── org</span><br><span class="line">│   └── resources</span><br><span class="line">│       ├── application.properties</span><br><span class="line">│       ├── application.yml</span><br><span class="line">│       ├── import.sql</span><br><span class="line">│       ├── kafka</span><br><span class="line">│       ├── new-pipeline.pmml.xml   &lt;--生成的新模型文件</span><br><span class="line">│       └── pipeline.pmml.xml       &lt;--之前sklearn输出的模型文件</span><br><span class="line">└── test</span><br><span class="line">    └── java</span><br><span class="line">        └── org</span><br><span class="line"></span><br><span class="line">9 directories, 5 files</span><br></pre></td></tr></table></figure><h1 id="参考"><a class="header-anchor" href="#参考"></a>参考</h1><ol><li><a href="https://github.com/jpmml/jpmml-model" target="_blank" rel="noopener">https://github.com/jpmml/jpmml-model</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deploy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>sparkml导出jpmml</title>
      <link href="/2018/08/30/sparkml%E5%AF%BC%E5%87%BAjpmml/"/>
      <url>/2018/08/30/sparkml%E5%AF%BC%E5%87%BAjpmml/</url>
      
        <content type="html"><![CDATA[<p>提示: 本文是<a href="http://houqian.xyz/2018/08/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/#%E7%AE%97%E6%B3%95%E4%BE%A7">模型部署方案</a>的一部分</p><h1 id="依赖"><a class="header-anchor" href="#依赖"></a>依赖</h1><ul><li>spark 2.2</li><li>jpmml-sparkml 1.3.8</li><li>scala 2.11</li></ul><h1 id="步骤"><a class="header-anchor" href="#步骤"></a>步骤</h1><ol><li>使用spark ml训练一个决策树模型</li><li>在控制台验证可以输出后，写到文件中</li></ol><a id="more"></a><h1 id="我们开始吧"><a class="header-anchor" href="#我们开始吧"></a>我们开始吧</h1><p>maven依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scala.version</span>&gt;</span>2.11.12<span class="tag">&lt;/<span class="name">scala.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scala.compat.version</span>&gt;</span>2.11<span class="tag">&lt;/<span class="name">scala.compat.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">spark-core.version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">spark-core.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">jpmml-sparkml.version</span>&gt;</span>1.3.8<span class="tag">&lt;/<span class="name">jpmml-sparkml.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--整合jpmml--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jpmml<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jpmml-sparkml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jpmml-sparkml.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--spark mllib--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-mllib_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spark-core.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--spark--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-core_$&#123;scala.compat.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spark-core.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-sql_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spark-core.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="模型训练-输出"><a class="header-anchor" href="#模型训练-输出"></a>模型训练 &amp; 输出</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.houqian.spark.jpmml</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.<span class="type">File</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.ml.classification.<span class="type">DecisionTreeClassifier</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.ml.feature.<span class="type">RFormula</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.ml.&#123;<span class="type">Pipeline</span>, <span class="type">PipelineStage</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">SparkSession</span></span><br><span class="line"><span class="keyword">import</span> org.jpmml.model.<span class="type">JAXBUtil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @author : houqian</span></span><br><span class="line"><span class="comment">  * @version : 1.0</span></span><br><span class="line"><span class="comment">  * @since : 2018-08-30</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Pipeline</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> spark = <span class="type">SparkSession</span></span><br><span class="line">      .builder</span><br><span class="line">      .appName(<span class="string">"Pipeline"</span>)</span><br><span class="line">      .master(<span class="string">"local[4]"</span>)</span><br><span class="line">      .getOrCreate()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载训练集</span></span><br><span class="line">    <span class="keyword">val</span> irisData = spark</span><br><span class="line">      .read</span><br><span class="line">      .format(<span class="string">"csv"</span>)</span><br><span class="line">      .option(<span class="string">"header"</span>, <span class="string">"true"</span>)</span><br><span class="line">      .load(<span class="string">"file:///Users/houqian/repo/github/data-notebook/src/main/resources/Iris.csv"</span>)</span><br><span class="line"></span><br><span class="line">    irisData.show()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 特征选择</span></span><br><span class="line">    <span class="keyword">val</span> formula = <span class="keyword">new</span> <span class="type">RFormula</span>().setFormula(<span class="string">"Species ~ ."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置决策树分类器</span></span><br><span class="line">    <span class="keyword">val</span> classifier = <span class="keyword">new</span> <span class="type">DecisionTreeClassifier</span>().setLabelCol(formula.getLabelCol).setFeaturesCol(formula.getFeaturesCol)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组合pipeline</span></span><br><span class="line">    <span class="keyword">val</span> pipeline = <span class="keyword">new</span> <span class="type">Pipeline</span>().setStages(<span class="type">Array</span>[<span class="type">PipelineStage</span>](formula, classifier))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 训练</span></span><br><span class="line">    <span class="keyword">val</span> pipelineModel = pipeline.fit(irisData)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> javax.xml.transform.stream.<span class="type">StreamResult</span></span><br><span class="line">    <span class="keyword">import</span> org.jpmml.sparkml.<span class="type">PMMLBuilder</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> schema = irisData.schema</span><br><span class="line">    <span class="keyword">val</span> pmml = <span class="keyword">new</span> <span class="type">PMMLBuilder</span>(schema, pipelineModel).build</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将pmml以流的形式输出到控制台</span></span><br><span class="line">    <span class="type">JAXBUtil</span>.marshalPMML(pmml, <span class="keyword">new</span> <span class="type">StreamResult</span>(<span class="type">System</span>.out))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将pmml写到文件</span></span><br><span class="line">    <span class="keyword">new</span> <span class="type">PMMLBuilder</span>(schema, pipelineModel).buildFile(<span class="keyword">new</span> <span class="type">File</span>(<span class="string">"/Users/houqian/repo/github/data-notebook/src/main/resources/pipeline.pmml"</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行，控制台输出：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">PMML</span> <span class="attr">xmlns</span>=<span class="string">"http://www.dmg.org/PMML-4_3"</span> <span class="attr">xmlns:data</span>=<span class="string">"http://jpmml.org/jpmml-model/InlineTable"</span> <span class="attr">version</span>=<span class="string">"4.3"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Header</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Application</span> <span class="attr">name</span>=<span class="string">"JPMML-SparkML"</span> <span class="attr">version</span>=<span class="string">"1.5.3"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Timestamp</span>&gt;</span>2018-08-30T14:03:52Z<span class="tag">&lt;/<span class="name">Timestamp</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">DataDictionary</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">DataField</span> <span class="attr">name</span>=<span class="string">"Species"</span> <span class="attr">optype</span>=<span class="string">"categorical"</span> <span class="attr">dataType</span>=<span class="string">"string"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"versicolor"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"virginica"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"setosa"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">DataField</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">DataField</span> <span class="attr">name</span>=<span class="string">"Petal_Width"</span> <span class="attr">optype</span>=<span class="string">"categorical"</span> <span class="attr">dataType</span>=<span class="string">"string"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"0.2"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"1.3"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"1.5"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"1.8"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"2.3"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"1.4"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"0.4"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"0.3"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"2.1"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"2"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"0.1"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"1.9"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"1.2"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"1.6"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"2.4"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"1.1"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"2.5"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"2.2"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"1.7"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"0.5"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"0.6"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">DataField</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">DataDictionary</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TreeModel</span> <span class="attr">functionName</span>=<span class="string">"classification"</span> <span class="attr">missingValueStrategy</span>=<span class="string">"nullPrediction"</span> <span class="attr">splitCharacteristic</span>=<span class="string">"multiSplit"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">MiningSchema</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">MiningField</span> <span class="attr">name</span>=<span class="string">"Species"</span> <span class="attr">usageType</span>=<span class="string">"target"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">MiningField</span> <span class="attr">name</span>=<span class="string">"Petal_Width"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">MiningSchema</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Output</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">OutputField</span> <span class="attr">name</span>=<span class="string">"pmml(prediction)"</span> <span class="attr">optype</span>=<span class="string">"categorical"</span> <span class="attr">dataType</span>=<span class="string">"string"</span> <span class="attr">feature</span>=<span class="string">"predictedValue"</span> <span class="attr">isFinalResult</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">OutputField</span> <span class="attr">name</span>=<span class="string">"prediction"</span> <span class="attr">optype</span>=<span class="string">"categorical"</span> <span class="attr">dataType</span>=<span class="string">"double"</span> <span class="attr">feature</span>=<span class="string">"transformedValue"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">MapValues</span> <span class="attr">outputColumn</span>=<span class="string">"data:output"</span> <span class="attr">dataType</span>=<span class="string">"double"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">FieldColumnPair</span> <span class="attr">field</span>=<span class="string">"pmml(prediction)"</span> <span class="attr">column</span>=<span class="string">"data:input"</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">InlineTable</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">row</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">data:input</span>&gt;</span>versicolor<span class="tag">&lt;/<span class="name">data:input</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">data:output</span>&gt;</span>0<span class="tag">&lt;/<span class="name">data:output</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">row</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">row</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">data:input</span>&gt;</span>virginica<span class="tag">&lt;/<span class="name">data:input</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">data:output</span>&gt;</span>1<span class="tag">&lt;/<span class="name">data:output</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">row</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">row</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">data:input</span>&gt;</span>setosa<span class="tag">&lt;/<span class="name">data:input</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">data:output</span>&gt;</span>2<span class="tag">&lt;/<span class="name">data:output</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">row</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">InlineTable</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">MapValues</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">OutputField</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">OutputField</span> <span class="attr">name</span>=<span class="string">"probability(versicolor)"</span> <span class="attr">optype</span>=<span class="string">"continuous"</span> <span class="attr">dataType</span>=<span class="string">"double"</span> <span class="attr">feature</span>=<span class="string">"probability"</span> <span class="attr">value</span>=<span class="string">"versicolor"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">OutputField</span> <span class="attr">name</span>=<span class="string">"probability(virginica)"</span> <span class="attr">optype</span>=<span class="string">"continuous"</span> <span class="attr">dataType</span>=<span class="string">"double"</span> <span class="attr">feature</span>=<span class="string">"probability"</span> <span class="attr">value</span>=<span class="string">"virginica"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">OutputField</span> <span class="attr">name</span>=<span class="string">"probability(setosa)"</span> <span class="attr">optype</span>=<span class="string">"continuous"</span> <span class="attr">dataType</span>=<span class="string">"double"</span> <span class="attr">feature</span>=<span class="string">"probability"</span> <span class="attr">value</span>=<span class="string">"setosa"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Output</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Node</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">True</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Node</span> <span class="attr">score</span>=<span class="string">"setosa"</span> <span class="attr">recordCount</span>=<span class="string">"29"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">SimplePredicate</span> <span class="attr">field</span>=<span class="string">"Petal_Width"</span> <span class="attr">operator</span>=<span class="string">"equal"</span> <span class="attr">value</span>=<span class="string">"0.2"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ScoreDistribution</span> <span class="attr">value</span>=<span class="string">"versicolor"</span> <span class="attr">recordCount</span>=<span class="string">"0.0"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ScoreDistribution</span> <span class="attr">value</span>=<span class="string">"virginica"</span> <span class="attr">recordCount</span>=<span class="string">"0.0"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ScoreDistribution</span> <span class="attr">value</span>=<span class="string">"setosa"</span> <span class="attr">recordCount</span>=<span class="string">"29.0"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Node</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Node</span> <span class="attr">score</span>=<span class="string">"versicolor"</span> <span class="attr">recordCount</span>=<span class="string">"13"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">SimplePredicate</span> <span class="attr">field</span>=<span class="string">"Petal_Width"</span> <span class="attr">operator</span>=<span class="string">"equal"</span> <span class="attr">value</span>=<span class="string">"1.3"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ScoreDistribution</span> <span class="attr">value</span>=<span class="string">"versicolor"</span> <span class="attr">recordCount</span>=<span class="string">"13.0"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ScoreDistribution</span> <span class="attr">value</span>=<span class="string">"virginica"</span> <span class="attr">recordCount</span>=<span class="string">"0.0"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ScoreDistribution</span> <span class="attr">value</span>=<span class="string">"setosa"</span> <span class="attr">recordCount</span>=<span class="string">"0.0"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Node</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Node</span> <span class="attr">score</span>=<span class="string">"setosa"</span> <span class="attr">recordCount</span>=<span class="string">"7"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">SimplePredicate</span> <span class="attr">field</span>=<span class="string">"Petal_Width"</span> <span class="attr">operator</span>=<span class="string">"equal"</span> <span class="attr">value</span>=<span class="string">"0.4"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ScoreDistribution</span> <span class="attr">value</span>=<span class="string">"versicolor"</span> <span class="attr">recordCount</span>=<span class="string">"0.0"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ScoreDistribution</span> <span class="attr">value</span>=<span class="string">"virginica"</span> <span class="attr">recordCount</span>=<span class="string">"0.0"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ScoreDistribution</span> <span class="attr">value</span>=<span class="string">"setosa"</span> <span class="attr">recordCount</span>=<span class="string">"7.0"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Node</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Node</span> <span class="attr">score</span>=<span class="string">"setosa"</span> <span class="attr">recordCount</span>=<span class="string">"7"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">SimplePredicate</span> <span class="attr">field</span>=<span class="string">"Petal_Width"</span> <span class="attr">operator</span>=<span class="string">"equal"</span> <span class="attr">value</span>=<span class="string">"0.3"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ScoreDistribution</span> <span class="attr">value</span>=<span class="string">"versicolor"</span> <span class="attr">recordCount</span>=<span class="string">"0.0"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ScoreDistribution</span> <span class="attr">value</span>=<span class="string">"virginica"</span> <span class="attr">recordCount</span>=<span class="string">"0.0"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ScoreDistribution</span> <span class="attr">value</span>=<span class="string">"setosa"</span> <span class="attr">recordCount</span>=<span class="string">"7.0"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Node</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Node</span> <span class="attr">score</span>=<span class="string">"setosa"</span> <span class="attr">recordCount</span>=<span class="string">"5"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">SimplePredicate</span> <span class="attr">field</span>=<span class="string">"Petal_Width"</span> <span class="attr">operator</span>=<span class="string">"equal"</span> <span class="attr">value</span>=<span class="string">"0.1"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ScoreDistribution</span> <span class="attr">value</span>=<span class="string">"versicolor"</span> <span class="attr">recordCount</span>=<span class="string">"0.0"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ScoreDistribution</span> <span class="attr">value</span>=<span class="string">"virginica"</span> <span class="attr">recordCount</span>=<span class="string">"0.0"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ScoreDistribution</span> <span class="attr">value</span>=<span class="string">"setosa"</span> <span class="attr">recordCount</span>=<span class="string">"5.0"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Node</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Node</span> <span class="attr">score</span>=<span class="string">"virginica"</span> <span class="attr">recordCount</span>=<span class="string">"89"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">True</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ScoreDistribution</span> <span class="attr">value</span>=<span class="string">"versicolor"</span> <span class="attr">recordCount</span>=<span class="string">"37.0"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ScoreDistribution</span> <span class="attr">value</span>=<span class="string">"virginica"</span> <span class="attr">recordCount</span>=<span class="string">"50.0"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ScoreDistribution</span> <span class="attr">value</span>=<span class="string">"setosa"</span> <span class="attr">recordCount</span>=<span class="string">"2.0"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Node</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Node</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">TreeModel</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">PMML</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们成功生成的pmml文件：</p><p><img src="/2018/08/30/sparkml导出jpmml/image-20180830161456730.png" alt="image-20180830161456730.png"></p><h1 id="参考"><a class="header-anchor" href="#参考"></a>参考</h1><ol><li><p><a href="https://openscoring.io/blog/2018/07/09/converting_sparkml_pipeline_pmml/" target="_blank" rel="noopener">https://openscoring.io/blog/2018/07/09/converting_sparkml_pipeline_pmml/</a></p></li><li><p><a href="https://github.com/jpmml/jpmml-sparkml" target="_blank" rel="noopener">https://github.com/jpmml/jpmml-sparkml</a></p></li><li><p>用到的训练集Iris.csv：<a href="https://github.com/jpmml/jpmml-sparkml/blob/1.3.X/src/test/resources/csv/Iris.csv" target="_blank" rel="noopener">https://github.com/jpmml/jpmml-sparkml/blob/1.3.X/src/test/resources/csv/Iris.csv</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deploy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>sklearn导出jpmml</title>
      <link href="/2018/08/30/sklearn%E5%AF%BC%E5%87%BAjpmml/"/>
      <url>/2018/08/30/sklearn%E5%AF%BC%E5%87%BAjpmml/</url>
      
        <content type="html"><![CDATA[<p>提示: 本文是<a href="http://houqian.xyz/2018/08/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/#%E7%AE%97%E6%B3%95%E4%BE%A7">模型部署方案</a>的一部分</p><h1 id="依赖"><a class="header-anchor" href="#依赖"></a>依赖</h1><ul><li>Python 2.7, 3.4 or newer.</li><li><a href="https://pypi.python.org/pypi/scikit-learn" target="_blank" rel="noopener"><code>scikit-learn</code></a> 0.16.0 or newer.</li><li><a href="https://pypi.python.org/pypi/sklearn-pandas" target="_blank" rel="noopener"><code>sklearn-pandas</code></a> 0.0.10 or newer.</li><li><a href="https://github.com/jpmml/sklearn2pmml" target="_blank" rel="noopener"><code>sklearn2pmml</code></a> 0.14.0 or newer.</li></ul><h1 id="步骤"><a class="header-anchor" href="#步骤"></a>步骤</h1><ol><li>使用sklearn训练一个模型</li><li>使用sklearn原生API将模型到处为 <code>pickle</code> 格式</li><li>使用 JPMML-SkLearn命令将原始<code>pickle</code> 格式文件转换成JPMML文件</li></ol><a id="more"></a><h1 id="我们开始吧"><a class="header-anchor" href="#我们开始吧"></a>我们开始吧</h1><h2 id="训练模型-导出pickle"><a class="header-anchor" href="#训练模型-导出pickle"></a>训练模型 &amp; 导出pickle</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0. 使用pandas加载iris数据集</span></span><br><span class="line">df = pandas.read_csv(<span class="string">"file:./csv/Iris.csv"</span>)</span><br><span class="line"></span><br><span class="line">iris_X = df[df.columns.difference([<span class="string">"Species"</span>])]</span><br><span class="line">iris_y = df[<span class="string">"Species"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 创建一个sklearn_pandas.DataFrameMapper对象，它主要提供面向列的特征工程、标准化功能</span></span><br><span class="line"><span class="keyword">from</span> sklearn_pandas <span class="keyword">import</span> DataFrameMapper</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn2pmml.decoration <span class="keyword">import</span> ContinuousDomain</span><br><span class="line"></span><br><span class="line">column_preprocessor = DataFrameMapper([</span><br><span class="line">    ([<span class="string">"Sepal.Length"</span>, <span class="string">"Sepal.Width"</span>, <span class="string">"Petal.Length"</span>, <span class="string">"Petal.Width"</span>], [ContinuousDomain(), StandardScaler()])</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 创建一个Transformer和Selector对象，它主要提供面向表的特征工程、标准化功能</span></span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest</span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line"><span class="keyword">from</span> sklearn2pmml <span class="keyword">import</span> SelectorProxy</span><br><span class="line"></span><br><span class="line">table_preprocessor = Pipeline([</span><br><span class="line">(<span class="string">"pca"</span>, PCA(n_components = <span class="number">3</span>)),</span><br><span class="line">(<span class="string">"selector"</span>, SelectorProxy(SelectKBest(k = <span class="number">2</span>)))</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 创建一个Estimator对象</span></span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"></span><br><span class="line">classifier = DecisionTreeClassifier(min_samples_leaf = <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将上面的对象作为参数与sklearn2pmml.pipeline.PMMLPipeline对象组合起来，此时可以运行一下，看看能不能跑通</span></span><br><span class="line"><span class="keyword">from</span> sklearn2pmml.pipeline <span class="keyword">import</span> PMMLPipeline</span><br><span class="line"></span><br><span class="line">pipeline = PMMLPipeline([</span><br><span class="line">    (<span class="string">"columns"</span>, column_preprocessor),</span><br><span class="line">    (<span class="string">"table"</span>, table_preprocessor),</span><br><span class="line">    (<span class="string">"classifier"</span>, classifier)</span><br><span class="line">])</span><br><span class="line">pipeline.fit(iris_X, iris_y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 内置的模型验证功能</span></span><br><span class="line">pipeline.verify(iris_X.sample(n = <span class="number">15</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将拟合好的PMMLPipeline对象，用joblib导出为pickle格式的文件</span></span><br><span class="line"><span class="keyword">from</span> sklearn.externals <span class="keyword">import</span> joblib</span><br><span class="line"></span><br><span class="line">joblib.dump(pipeline, <span class="string">"pipeline.pkl.z"</span>, compress = <span class="number">9</span>)</span><br></pre></td></tr></table></figure><p>此时，我们得到了原始模型文件</p><p><img src="/2018/08/30/sklearn导出jpmml/image-20180830134051087.png" alt="image-20180830134051087.png"></p><h2 id="转换jpmml"><a class="header-anchor" href="#转换jpmml"></a>转换JPMML</h2><p>我们需要jpmml-sklearn的帮助，来转换原始模型文件。目前该子项目的最新版本为1.5.4，我们可以下载编译好的jar包，或者自己编译。</p><p><img src="/2018/08/30/sklearn导出jpmml/image-20180830134831357.png" alt="image-20180830134831357.png"></p><p>这里笔者选择自行编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/jpmml/jpmml-sklearn.git</span></span><br><span class="line">cd jpmml-sklearn &amp;&amp; mvn clean install -DskipTests</span><br></pre></td></tr></table></figure><p>讲我们上面得到的原始文件拷贝到jpmml-sklearn目录下, 执行:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar target/jpmml-sklearn-executable-<span class="number">1.5</span>-SNAPSHOT.jar --pkl-input pipeline.pkl.z --pmml-output pipeline.pmml</span><br></pre></td></tr></table></figure><p>我们成功的得到了pmml模型文件</p><p><img src="/2018/08/30/sklearn导出jpmml/image-20180830135636503.png" alt="image-20180830135636503.png"></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deploy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>机器学习模型部署方案</title>
      <link href="/2018/08/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/"/>
      <url>/2018/08/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a class="header-anchor" href="#背景"></a>背景</h1><p>目前，我们组反欺诈业务已经进行到了较为后期的阶段，初步有了基础的数据平台、计算平台。此时，算法同事也升级了过往基于统计分布的简单算法实现，而采用了更为强大的机器学习模型，目前已知的将会使用以下几类算法：离群点检测算法、树类算法等（笔者仅了解常见算法，描述不准确还望见谅。）</p><h1 id="问题"><a class="header-anchor" href="#问题"></a>问题</h1><p>算法同学日常使用sk-learn或者spark ml居多，其中前者使用python后者使用scala作为日常开发语言。笔者目前所做的属于算法工程化，需要对接线上实时数据流、离线数据实现对算法同学产出的模型的上线。</p><p>目前，已知的其他团队的方案有：</p><ol><li>使用python语言实现backend，并对接实时、离线数据</li><li>使用Java重新实现一遍算法逻辑，然后实现web api，并对接实时、离线数据</li></ol><p>分析一下这两种方案：</p><p>对于1，他们这么做的理由是算法同学自己的工程能力非常强，可以自己用python一站式搞定模型训练、上线，并且他们的业务离线居多，对实时性的要求不高。</p><p>对于2，他们这么做的理由是算法同学工程能力较弱，自己无法搞定一站式。使用线性模型比较多，后端Java同学实现起来还是比较简单的，性能也非常好。</p><p>然而，这两种方案目前看来都不能满足我们组的需求。</p><ul><li>我们的模型比较复杂，用Java实现一遍显的复杂性不可控，验证实现正确性的成本也很高。</li><li>主要是实时、数据量较少的场景，对实时性要求比较高（查询四五个数据源，加上模型逻辑，需要在1秒内给业务方返回）</li><li>希望做到模型的部署和训练接耦，算法同学和后端同学各自专注自己的事情</li></ul><a id="more"></a><h1 id="方案"><a class="header-anchor" href="#方案"></a>方案</h1><p>针对如上特征，笔者进行了调查。发现使用<code>模型训练</code>—&gt;<code>导出模型文件</code>—&gt;<code>服务端加载模型文件，对接数据源</code>这种模式比较适合我们。</p><p>目前业界使用的比较多的模型文件标准是PMML，以下是对该标准的简单描述：</p><blockquote><p>PMML 是一种事实标准语言，用于呈现数据挖掘模型。PMML 允许您在不同的应用程序之间轻松共享预测分析模型。因此，您可以在一个系统中定型一个模型，在 PMML 中对其进行表达，然后将其移动到另一个系统中。</p><p>PMML 是数据挖掘群组的产物，该群组是一个由供应商领导的委员会，由各种商业和开放源码分析公司组成。因此，现在的大部分领先数据挖掘工具都可以导出或导入 PMML。作为一个已发展 10 多年的成熟标准，PMML 既可以呈现用于从数据中了解模型的统计技术（如人工神经网络和决策树），也可以呈现原始输入数据的预处理以及模型输出的后处理。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p></blockquote><p>可以看到，PMML作为一个10几年的标准，在数据挖掘领域是很成熟的。笔者在Github也找到了该标准的Java实现<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。</p><p><img src="/2018/08/29/机器学习模型部署方案/image-20180829123430675.png" alt="image-20180829123430675.png"></p><p>可以看到其子项目分类非常清晰：</p><ul><li><p>jpmml-evaluatorjava加载jpmml格式文件API，这个也是我们服务端重点关注的</p></li><li><p>jpmml-modeljpmml文件对应的Java类</p></li><li><p>jpmml-sparkml与sparkml整合以导出jpmml文件</p></li><li><p>jpmml-sklearn</p><p>与sklearn整合以导出jpmml文件</p></li><li><p>jpmml-r</p></li><li><p>jpmml-xgboost</p></li></ul><p>如果使用这种方案，改动量：</p><ul><li>算法同学需要整合jpmml-sparkml、jpmml-sklearn</li><li>后端工程同学需要整合jpmml-evaluator、jpmml-model</li></ul><p>改动量还是比较大的，目前也主要是笔者自己进行相关的调研，接下来笔者尝试跑通<code>模型训练</code>—&gt;<code>导出模型文件</code>—&gt;<code>服务端加载模型文件，对接数据源</code>这个流程。</p><h1 id="实现"><a class="header-anchor" href="#实现"></a>实现</h1><h2 id="算法侧"><a class="header-anchor" href="#算法侧"></a>算法侧</h2><p><a href="http://houqian.xyz/2018/08/30/sklearn%E5%AF%BC%E5%87%BAjpmml/">sklearn导出jpmml</a></p><p><a href="http://houqian.xyz/2018/08/30/sklearn%E5%AF%BC%E5%87%BAjpmml/">sparkml导出jpmml</a></p><h2 id="工程侧"><a class="header-anchor" href="#工程侧"></a>工程侧</h2><p><a href="http://houqian.xyz/2018/08/30/%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B%E6%96%87%E4%BB%B6">加载模型文件</a></p><p><a href="http://houqian.xyz/2018/08/30/%E8%B0%83%E7%94%A8%E6%A8%A1%E5%9E%8B">调用模型</a></p><h1 id="总结"><a class="header-anchor" href="#总结"></a>总结</h1><h2 id="该方案的优势"><a class="header-anchor" href="#该方案的优势"></a>该方案的优势</h2><ul><li>解耦使用PMML作为中间层，解耦了模型训练、部署这两个环节，使得算法同学专注效果、后端同学专注性能</li><li>成熟度很高已经有10几年的历史</li></ul><h2 id="该方案的缺点"><a class="header-anchor" href="#该方案的缺点"></a>该方案的缺点</h2><ul><li><p>故障追踪相对困难</p><p>增加了一层模型文件，引入了几个子项目，出了问题定位起来相对以前要难上一些。不过，如果满足我们的需求，相信随着对源码的逐步掌握，我们可以在关键节点做埋点日志，结合已有的tracing系统，这个问题也不大</p></li></ul><h2 id="心得"><a class="header-anchor" href="#心得"></a>心得</h2><p>这次总共花了1天多的时间研究更好的模型上线方案，初步确定了JPMML这一生成中间文件的方案。目前，已经跑通了从算法模型训练（覆盖sklearn、spark ml的jpmml文件输出）到使用jpmml模型文件部署的整个流程。</p><p>过程中还算比较顺利，github上的文档虽少但足够精炼，已经覆盖了主要流程。但并没有覆盖到算法同学的复杂模型case，因此还需要和算法同学细化使用场景。</p><p>如果该方案最终被采用，笔者会撰写更为深入的源码分析系列文章。</p><p><strong>Reference</strong></p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>何为PMML？<a href="https://www.ibm.com/developerworks/cn/opensource/ind-PMML1/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/opensource/ind-PMML1/index.html</a> <a href="#fnref1" class="footnote-backref">↩</a></p></li><li id="fn2" class="footnote-item"><p>Jpmml Github <a href="https://github.com/jpmml" target="_blank" rel="noopener">https://github.com/jpmml</a> <a href="#fnref2" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deploy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>监控调研</title>
      <link href="/2017/08/29/%E7%9B%91%E6%8E%A7%E8%B0%83%E7%A0%94/"/>
      <url>/2017/08/29/%E7%9B%91%E6%8E%A7%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a class="header-anchor" href="#背景"></a>背景</h3><p>性能压测后，逐个埋点添加各种StopWatch。</p><p><strong>两个缺点：</strong></p><ol><li>侵入了业务逻辑，降低可读性</li><li>耗时，工作量大</li></ol><p><strong>期望：</strong></p><ol><li>【注解】 基于配置或注解可以精确控制要添加性能监控的method或class</li><li>【指标维度全面】监控指标全面，除了常见的QPS、Req Cost Time，还要有TPS, P90, P95 ,P99等指标</li><li>【可视化】最好有图形化的界面可以实时看到各个method的性能状况</li></ol><a id="more"></a><h3 id="方案调研"><a class="header-anchor" href="#方案调研"></a>方案调研</h3><ol><li>商业OneAPM、NewRelic等基于java agent实现无侵入监控性能指标。</li><li>开源【一站式】open-tracing【定制化】metrics + aop + AMQP中间件 + <a href="https://www.influxdata.com/" target="_blank" rel="noopener">InfluxDB</a> + <a href="https://grafana.com/" target="_blank" rel="noopener">Grafana</a></li></ol><p>分析</p><p>根据目前的需求，需要灵活的定制化监控项，可控的监控数据流，因此原则定制化开源项。</p><h3 id="方案细节"><a class="header-anchor" href="#方案细节"></a>方案细节</h3><ol><li><h4 id="组件调研"><a class="header-anchor" href="#组件调研"></a>组件调研</h4><h5 id="监控指标采集"><a class="header-anchor" href="#监控指标采集"></a>监控指标采集</h5><ul><li><a href="evernote:///view/476088119/s5/95bcac4c-8c7e-4a74-8b86-7a2b7f6a43d9/95bcac4c-8c7e-4a74-8b86-7a2b7f6a43d9/" target="_blank" rel="noopener">Metrics</a></li><li>AOP</li></ul><h5 id="指标数据传输"><a class="header-anchor" href="#指标数据传输"></a>指标数据传输</h5><ul><li>AMQP选型</li></ul><h5 id="指标数据落地"><a class="header-anchor" href="#指标数据落地"></a>指标数据落地</h5><ul><li><p>时间序列数据库</p><p>InfluxDB</p></li></ul><h5 id="指标数据展示"><a class="header-anchor" href="#指标数据展示"></a>指标数据展示</h5><ul><li>Grafana</li></ul></li><li><h4 id="方案打通"><a class="header-anchor" href="#方案打通"></a>方案打通</h4></li><li><h4 id="测试上线"><a class="header-anchor" href="#测试上线"></a>测试上线</h4></li></ol><p><strong>Reference</strong></p><ol><li><a href="http://www.jianshu.com/p/e4f70ddbc287" target="_blank" rel="noopener">Metrics —— JVM上的实时监控类库</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> APM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java性能监控 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Shell编程实战总结</title>
      <link href="/2017/08/25/shell%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
      <url>/2017/08/25/shell%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h4 id="linux显示彩色字体"><a class="header-anchor" href="#linux显示彩色字体"></a>Linux显示彩色字体</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">echo -e "\033[30m 黑色字 \033[0m"</span><br><span class="line">echo -e "\033[31m 红色字 \033[0m"</span><br><span class="line">echo -e "\033[32m 绿色字 \033[0m"</span><br><span class="line">echo -e "\033[33m 黄色字 \033[0m"</span><br><span class="line">echo -e "\033[34m 蓝色字 \033[0m"</span><br><span class="line">echo -e "\033[35m 紫色字 \033[0m"</span><br><span class="line">echo -e "\033[36m 天蓝字 \033[0m"</span><br><span class="line">echo -e "\033[37m 白色字 \033[0m"</span><br><span class="line"> </span><br><span class="line">echo -e "\033[40;37m 黑底白字 \033[0m"</span><br><span class="line">echo -e "\033[41;37m 红底白字 \033[0m"</span><br><span class="line">echo -e "\033[42;37m 绿底白字 \033[0m"</span><br><span class="line">echo -e "\033[43;37m 黄底白字 \033[0m"</span><br><span class="line">echo -e "\033[44;37m 蓝底白字 \033[0m"</span><br><span class="line">echo -e "\033[45;37m 紫底白字 \033[0m"</span><br><span class="line">echo -e "\033[46;37m 天蓝底白字 \033[0m"</span><br><span class="line">echo -e "\033[47;30m 白底黑字 \033[0m"</span><br></pre></td></tr></table></figure><h4 id="隔一秒检查mysql在执行的dml语句"><a class="header-anchor" href="#隔一秒检查mysql在执行的dml语句"></a>隔一秒检查MySQL在执行的DML语句</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span> </span><br><span class="line">  sudo mysql --default-character-set=utf8 -h <span class="variable">$&#123;hostname&#125;</span> -P 3306  -u<span class="variable">$&#123;username&#125;</span>  -p<span class="variable">$&#123;password&#125;</span> -e <span class="string">"show processlist"</span> | grep Query; </span><br><span class="line">sleep 1; </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h4 id="以逗号分隔每一行-取第一列"><a class="header-anchor" href="#以逗号分隔每一行-取第一列"></a>以逗号分隔每一行，取第一列</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F, <span class="string">'&#123;print $1&#125;'</span> doufen_uid_name</span><br></pre></td></tr></table></figure><h4 id="批量行首添加字符串"><a class="header-anchor" href="#批量行首添加字符串"></a>批量行首添加字符串</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以后研究下列模式能否实现</span></span><br><span class="line">vim mode下 </span><br><span class="line">:%s/^/del user_item__/g</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="查看jar包内容"><a class="header-anchor" href="#查看jar包内容"></a>查看jar包内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar -tf xxxx.jar</span><br></pre></td></tr></table></figure><h4 id="统计一个文件的行数"><a class="header-anchor" href="#统计一个文件的行数"></a>统计一个文件的行数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法1：先用wc -l算出行数，awk取第一个字段</span></span><br><span class="line">wc -l filename | awk <span class="string">'&#123;print $1&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2：巧用END函数和内置变量NR直接输出行数</span></span><br><span class="line"><span class="comment"># NR变量可以输出当前行号，END函数是awk读取完文件之后执行的操作</span></span><br><span class="line">awk <span class="string">'END&#123;pint NR&#125;'</span> filename</span><br></pre></td></tr></table></figure><h4 id="如何获取当前脚本的名称？当前路径文件的名称？"><a class="header-anchor" href="#如何获取当前脚本的名称？当前路径文件的名称？"></a>如何获取当前脚本的名称？当前路径文件的名称？</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># shell script</span></span><br><span class="line">basename <span class="variable">$0</span></span><br></pre></td></tr></table></figure><h4 id="linux下的进程管理"><a class="header-anchor" href="#linux下的进程管理"></a>Linux下的进程管理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. bg,fg,&amp;,ctrl+c, ctrl+z, jobs</span></span><br><span class="line"><span class="comment"># 查看后台进程任务</span></span><br><span class="line"><span class="built_in">bg</span></span><br><span class="line"><span class="comment"># 将一个后台任务唤醒start并切到前台</span></span><br><span class="line"><span class="built_in">fg</span></span><br><span class="line"><span class="comment"># 将一个任务转为daemon进程在后台运行</span></span><br><span class="line">&amp;</span><br><span class="line"><span class="comment"># 停止当前正在运行的进程</span></span><br><span class="line">ctrl+c</span><br><span class="line"><span class="comment"># 将当前进程放到后天并挂起[stop]</span></span><br><span class="line">ctrl+z</span><br><span class="line"><span class="comment"># 查看当前用户下的所有后台任务</span></span><br><span class="line"><span class="built_in">jobs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 工作流实践</span></span><br><span class="line"><span class="comment"># 1.vim 打开一个log文件</span></span><br><span class="line"><span class="comment"># 2.ctrl + z在后台挂起</span></span><br><span class="line"><span class="comment"># 3.jobs</span></span><br><span class="line"><span class="comment"># 4.fg + 编号唤醒相应的进程</span></span><br></pre></td></tr></table></figure><h4 id="实时的监控网卡流量"><a class="header-anchor" href="#实时的监控网卡流量"></a>实时的监控网卡流量</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptraf</span><br></pre></td></tr></table></figure><p><img src="/2017/08/25/shell编程实战/iptraf01.png" alt="iptraf01"></p><p><img src="/2017/08/25/shell编程实战/iptraf02.png" alt="iptraf02"></p><p><a href="http://www.ttlsa.com/linux-command/ss-replace-netstat/" target="_blank" rel="noopener">网络状态工具SS</a></p><h4 id="取出中括号内的内容"><a class="header-anchor" href="#取出中括号内的内容"></a>取出中括号内的内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 123[321]123 | cut -d <span class="string">"["</span> -f2 | cut -d <span class="string">"]"</span> -f1</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">321</span><br><span class="line"></span><br><span class="line"><span class="comment"># cut语法理解：</span></span><br><span class="line">cut -d 会根据指定的分隔符切分字符串（或者从文件中读取），-f&#123;<span class="variable">$num</span>&#125;的num是按照该分隔符分割后取哪一块内容（也就是分割后是一个字符串数组，你可以根据下标获取期望的子串，只不过该数组下标从）</span><br></pre></td></tr></table></figure><h4 id="使用vim去除段落内行尾的空格与tab"><a class="header-anchor" href="#使用vim去除段落内行尾的空格与tab"></a>使用VIM去除段落内行尾的空格与tab</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s<span class="comment">#\s\+$##</span></span><br></pre></td></tr></table></figure><h4 id="过滤并高亮"><a class="header-anchor" href="#过滤并高亮"></a>过滤并高亮</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep --color -C30 <span class="string">'RESPONSE'</span> test.log</span><br></pre></td></tr></table></figure><p><img src="/2017/08/25/shell编程实战/%E8%BF%87%E6%BB%A4%E5%B9%B6%E9%AB%98%E4%BA%AE.png" alt="过滤并高亮"></p><h4 id="osx下利用xargs传参"><a class="header-anchor" href="#osx下利用xargs传参"></a>osx下利用xargs传参</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls | grep json |grep -v <span class="string">'('</span> |  xargs -I  % cp % <span class="built_in">test</span>/</span><br><span class="line"><span class="comment"># %%内包起来要执行的命令即可，不需要&#123;&#125;占位符</span></span><br><span class="line"><span class="comment"># 注意：OSX的xargs与Linux不同</span></span><br></pre></td></tr></table></figure><h4 id="查看系统中的内存占用"><a class="header-anchor" href="#查看系统中的内存占用"></a>查看系统中的内存占用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -A --sort -rss -o pid,comm,pmem,rss | less</span><br></pre></td></tr></table></figure><h4 id="查看进程打开的文件句柄数"><a class="header-anchor" href="#查看进程打开的文件句柄数"></a>查看进程打开的文件句柄数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> $(pidof java); <span class="keyword">do</span> <span class="built_in">echo</span> <span class="string">"PID # <span class="variable">$p</span> has <span class="variable">$(lsof -n -a -p $p|wc -l)</span> fd opened."</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure><h4 id="linux根据pid查找执行路径及其他详情"><a class="header-anchor" href="#linux根据pid查找执行路径及其他详情"></a>Linux根据PID查找执行路径及其他详情</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll /proc/PID</span><br></pre></td></tr></table></figure><p><img src="/2017/08/25/shell编程实战/Linux%E6%A0%B9%E6%8D%AEPID%E6%9F%A5%E6%89%BE%E6%89%A7%E8%A1%8C%E8%B7%AF%E5%BE%84%E5%8F%8A%E5%85%B6%E4%BB%96%E8%AF%A6%E6%83%85.png" alt="Linux根据PID查找执行路径及其他详情"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AQS论文翻译</title>
      <link href="/2017/08/04/AQS%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/"/>
      <url>/2017/08/04/AQS%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a class="header-anchor" href="#背景"></a>背景</h1><p>最近对并发底层实现比较有兴趣，正巧逛博客园看到这篇译文不错，这里记录一下<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p><a id="more"></a><h2 id="一-论文简介"><a class="header-anchor" href="#一-论文简介"></a>一、论文简介</h2><p>闲来无事，看看源码，发现了一篇JDK作者的论文《The java.util.concurrent Synchronizer Framework》主要描述了作者对AbstractQueuedSynchronizer同步器框架的设计和实现。权威性毋庸置疑！自然需要拜读一下，配上中文翻译，希望大家能有所收获。</p><h2 id="二-原文链接"><a class="header-anchor" href="#二-原文链接"></a>二、原文链接</h2><p><a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf" target="_blank" rel="noopener">论文英文版原文链接：http://gee.cs.oswego.edu/dl/papers/aqs.pdf 打开链接右上角有下载按钮</a></p><p><a href="http://gee.cs.oswego.edu/" target="_blank" rel="noopener">http://gee.cs.oswego.edu/</a>  这个是老李头的主页，里面有他的部分贡献，感兴趣的可以关注一下，老李头确实比较厉害。</p><h2 id="三-中文翻译"><a class="header-anchor" href="#三-中文翻译"></a>三、中文翻译</h2><h3 id="摘要"><a class="header-anchor" href="#摘要"></a>摘要</h3><p>在J2SE 1.5的java.util.concurrent包（下称j.u.c包）中，大部分的同步器（例如锁，屏障等等）都是基于AbstractQueuedSynchronizer类（下称AQS类），这个简单的框架而构建的。这个框架为同步状态的原子性管理、线程的阻塞和解除阻塞以及排队提供了一种通用的机制。这篇论文主要描述了这个框架基本原理、设计、实现、用法以及性能。</p><h3 id="1-背景介绍"><a class="header-anchor" href="#1-背景介绍"></a>1. 背景介绍</h3><p>通过JCP的JSR166规范，Java的1.5版本引入了j.u.c包，这个包提供了一系列支持中等程度并发的类。这些组件是一系列的同步器（抽象数据类型(ADT)）。这些同步器主要维护着以下几个功能：内部同步状态的管理(例如：表示一个锁的状态是获取还是释放)，同步状态的更新和检查操作，且至少有一个方法会导致调用线程在同步状态被获取时阻塞，以及在其他线程改变这个同步状态时解除线程的阻塞。上述的这些的实际例子包括：互斥排它锁的不同形式、读写锁、信号量、屏障、Future、事件指示器以及传送队列等。</p><p>几乎任一同步器都可以用来实现其他形式的同步器。例如，可以用可重入锁实现信号量或者用信号量实现可重入锁。但是，这样做带来的复杂性，开销，不灵活使其至多只能是个二流工程。且缺乏吸引力。如果任何这样的构造方式不能在本质上比其他形式更简洁，那么开发者就不应该随意地选择其中的某个来构建另一个同步器。取而代之，JSR166建立了一个小框架，AQS类。这个框架为构造同步器提供一种通用的机制，并且被j.u.c包中大部分类使用，同时很多用户也用它来定义自己的同步器。</p><p>在这篇论文的下面部分会讨论这个框架的需求、设计与实现背后的主要思路、示例用法，以及性能指标的一些测量。</p><h3 id="2-需求"><a class="header-anchor" href="#2-需求"></a>2. 需求</h3><h4 id="2-1-功能"><a class="header-anchor" href="#2-1-功能"></a>2.1 功能</h4><p>同步器一般包含两种方法，一种是acquire，另一种是release。acquire操作阻塞调用的线程，直到或除非同步状态允许其继续执行。而release操作则是通过某种方式改变同步状态，使得一或多个被acquire阻塞的线程继续执行。</p><p>j.u.c包中并没有对同步器的API做一个统一的定义。因此，有一些类定义了通用的接口（如Lock），而另外一些则定义了其专有的版本。因此在不同的类中，acquire和release操作的名字和形式会各有不同。例如：Lock.lock，Semaphore.acquire，CountDownLatch.await和FutureTask.get，在这个框架里，这些方法都是acquire操作。但是，J.U.C为支持一系列常见的使用选项，在类间都有个一致约定。在有意义的情况下，每一个同步器都支持下面的操作：</p><ul><li>阻塞和非阻塞（例如tryLock）同步。</li><li>可选的超时设置，让调用者可以放弃等待</li><li>通过中断实现的任务取消，通常是分为两个版本，一个acquire可取消，而另一个不可以。</li></ul><p>同步器的实现根据其状态是否独占而有所不同。独占状态的同步器，在同一时间只有一个线程可以通过阻塞点，而共享状态的同步器可以同时有多个线程在执行。一般锁的实现类往往只维护独占状态，但是，例如计数信号量在数量许可的情况下，允许多个线程同时执行。为了使框架能得到广泛应用，这两种模式都要支持。</p><p>j.u.c包里还定义了Condition接口，用于支持监控形式的await/signal操作，这些操作与独占模式的Lock类有关，且Condition的实现天生就和与其关联的Lock类紧密相关。</p><h4 id="2-2-性能目标"><a class="header-anchor" href="#2-2-性能目标"></a>2.2 性能目标</h4><p>Java内置锁（使用synchronized的方法或代码块）的性能问题一直以来都在被人们关注，并且已经有一系列的文章描述其构造（例如引文[1],[3]）。然而，大部分的研究主要关注的是在单核处理器上大部分时候使用于单线程上下文环境中时，如何尽量降低其空间（因为任何的Java对象都可以当成是锁）和时间的开销。对于同步器来说这些都不是特别重要：程序员仅在需要的时候才会使用同步器，因此并不需要压缩空间来避免浪费，并且同步器几乎是专门用在多线程设计中（特别是在多核处理器上），在这种环境下，偶尔的竞争是在意料之中的。因此，常规的JVM锁优化策略主要是针对零竞争的场景，而其它场景则使用缺乏可预见性的“慢速路径（slow paths）” ，所以常规的JVM锁优化策略并不适用于严重依赖于J.U.C包的典型多线程服务端应用。</p><p>这里主要的性能目标是可伸缩性，即在大部分情况下，即使，或特别在同步器有竞争的情况下，稳定地保证其效率。在理想的情况下，不管有多少线程正试图通过同步点，通过同步点的开销都应该是个常量。在某一线程被允许通过同步点但还没有通过的情况下，使其耗费的总时间最少，这是主要目标之一。然而，这也必须考虑平衡各种资源，包括总CPU时间的需求，内存负载以及线程调度的开销。例如：获取自旋锁通常比阻塞锁所需的时间更短，但是通常也会浪费CPU时钟周期，并且造成内存竞争，所以使用的并不频繁。</p><p>实现同步器的这些目标包含了两种不同的使用类型。大部分应用程序是最大化其总的吞吐量，容错性，并且最好保证尽量减少饥饿的情况。然而，对于那些控制资源分配的程序来说，更重要是去维持多线程读取的公平性，可以接受较差的总吞吐量。没有任何框架可以代表用户去决定应该选择哪一个方式，因此，应该提供不同的公平策略。</p><p>无论同步器的内部实现是多么的精雕细琢，它还是会在某些应用中产生性能瓶颈。因此，框架必须提供相应的监视工具让用户发现和缓和这些瓶颈。至少需要提供一种方式来确定有多少线程被阻塞了。</p><h3 id="3-设计与实现"><a class="header-anchor" href="#3-设计与实现"></a>3. 设计与实现</h3><p>同步器背后的基本思想非常简单。acquire操作如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (同步状态不允许获取) &#123;</span><br><span class="line">如果尚未排队,则将当前线程排入队列;</span><br><span class="line">可能阻塞当前线程;</span><br><span class="line">&#125;</span><br><span class="line">如果当前线程在排队则将其取消;</span><br></pre></td></tr></table></figure><p>release操作如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">更新同步状态;</span><br><span class="line"><span class="keyword">if</span> (状态允许阻塞线程获取)</span><br><span class="line">解锁一个或者多个已经入队的线程;</span><br></pre></td></tr></table></figure><p>为了实现上述操作，需要下面三个基本组件的相互协作：</p><ul><li>同步状态的原子性管理；</li><li>线程的阻塞与解除阻塞；</li><li>队列的管理；</li></ul><p>创建一个框架分别实现这三个组件是有可能的。但是，这会让整个框架既难用又没效率。例如：存储在队列节点的信息必须与解除阻塞所需要的信息一致，而暴露出的方法的签名必须依赖于同步状态的特性。</p><p>同步器框架的核心决策是为这三个组件选择一个具体实现，同时在使用方式上又有大量选项可用。这里有意地限制了其适用范围，但是提供了足够的效率，使得实际上没有理由在合适的情况下不用这个框架而去重新建造一个。</p><h4 id="3-1-同步状态"><a class="header-anchor" href="#3-1-同步状态"></a>3.1 同步状态</h4><p>AQS类使用单个<code>int</code>（32位）来保存同步状态，并暴露出<code>getState</code>、<code>setState</code>以及<code>compareAndSet</code>操作来读取和更新这个状态。这些方法都依赖于j.u.c.atomic包的支持，这个包提供了兼容JSR133中<code>volatile</code>在读和写上的语义，并且通过使用本地的compare-and-swap或load-linked/store-conditional指令来实现<code>compareAndSetState</code>，使得仅当同步状态拥有一个期望值的时候，才会被原子地设置成新值。</p><p>将同步状态限制为一个32位的整形是出于实践上的考量。虽然JSR166也提供了64位<code>long</code>字段的原子性操作，但这些操作在很多平台上还是使用内部锁的方式来模拟实现的，这会使同步器的性能可能不会很理想。当然，将来可能会有一个类是专门使用64位的状态的。然而现在就引入这么一个类到这个包里并不是一个很好的决定（<em>译者注：JDK1.6中已经包含java.util.concurrent.locks.AbstractQueuedLongSynchronizer类，即使用 long 形式维护同步状态的一个 AbstractQueuedSynchronizer 版本</em>）。目前来说，32位的状态对大多数应用程序都是足够的。在j.u.c包中，只有一个同步器类可能需要多于32位来维持状态，那就是<code>CyclicBarrier</code>类，所以，它用了锁（该包中大多数更高层次的工具亦是如此）。</p><p>基于AQS的具体实现类必须根据暴露出的状态相关的方法定义<code>tryAcquire</code>和<code>tryRelease</code>方法，以控制acquire和release操作。当同步状态满足时，<code>tryAcquire</code>方法必须返回<code>true</code>，而当新的同步状态允许后续acquire时，<code>tryRelease</code>方法也必须返回<code>true</code>。这些方法都接受一个<code>int</code>类型的参数用于传递想要的状态。例如：可重入锁中，当某个线程从条件等待中返回，然后重新获取锁时，为了重新建立循环计数的场景。很多同步器并不需要这样一个参数，因此忽略它即可。</p><h4 id="3-2-阻塞"><a class="header-anchor" href="#3-2-阻塞"></a>3.2 阻塞</h4><p>在JSR166之前，阻塞线程和解除线程阻塞都是基于Java内置监视器，没有基于Java API可以用来创建同步器。唯一可以选择的是<code>Thread.suspend</code>和<code>Thread.resume</code>，但是它们都有无法解决的竞态问题，所以也没法用：当一个非阻塞的线程在一个正准备阻塞的线程调用<code>suspend</code>前调用了<code>resume</code>，这个<code>resume</code>操作将不会有什么效果。</p><p>j.u.c包有一个<code>LockSuport</code>类，这个类中包含了解决这个问题的方法。方法<code>LockSupport.park</code>阻塞当前线程除非/直到有个<code>LockSupport.unpark</code>方法被调用（<code>unpark</code>方法被提前调用也是可以的）。<code>unpark</code>的调用是没有被计数的，因此在一个<code>park</code>调用前多次调用<code>unpark</code>方法只会解除一个<code>park</code>操作。另外，它们作用于每个线程而不是每个同步器。一个线程在一个新的同步器上调用park操作可能会立即返回，因为在此之前可能有“剩余的”<code>unpark</code>操作。但是，在缺少一个<code>unpark</code>操作时，下一次调用park就会阻塞。虽然可以显式地消除这个状态（<em>译者注：就是多余的unpark调用</em>），但并不值得这样做。在需要的时候多次调用<code>park</code>会更高效。</p><p>这个简单的机制与有些用法在某种程度上是相似的，例如Solaris-9的线程库，WIN32中的“可消费事件”，以及Linux中的NPTL线程库。因此最常见的运行Java的平台上都有相对应的有效实现。（但目前Solaris和Linux上的Sun Hotspot JVM参考实现实际上是使用一个pthread的condvar来适应目前的运行时设计的）。<code>park</code>方法同样支持可选的相对或绝对的超时设置，以及与JVM的<code>Thread.interrupt</code>结合 —— 可通过中断来<code>unpark</code>一个线程。</p><h4 id="3-3-队列"><a class="header-anchor" href="#3-3-队列"></a>3.3 队列</h4><p>整个框架的关键就是如何管理被阻塞的线程的队列，该队列是严格的FIFO队列，因此，框架不支持基于优先级的同步。</p><p>同步队列的最佳选择是自身没有使用底层锁来构造的非阻塞数据结构，目前，业界对此很少有争议。而其中主要有两个选择：一个是Mellor-Crummey和Scott锁（MCS锁）<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup><sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup><sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>的变体。一直以来，CLH锁仅被用于自旋锁。但是，在这个框架中，CLH锁显然比MCS锁更合适。因为CLH锁可以更容易地去实现“取消（cancellation）”和“超时”功能，因此我们选择了CLH锁作为实现的基础。但是最终的设计已经与原来的CLH锁有较大的出入，因此下文将对此做出解释。</p><p>CLH队列实际上并不那么像队列，因为它的入队和出队操作都与它的用途（即用作锁）紧密相关。它是一个链表队列，通过两个字段<code>head</code>和<code>tail</code>来存取，这两个字段是可原子更新的，两者在初始化时都指向了一个空节点。</p><p><img src="/2017/08/04/AQS论文翻译/CLHNode-20190522123101755.png" alt="324242343"></p><p>一个新的节点，node，通过一个原子操作入队：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123; </span><br><span class="line">    pred = tail;</span><br><span class="line">&#125; <span class="keyword">while</span>(!tail.compareAndSet(pred, node));</span><br></pre></td></tr></table></figure><p>每一个节点的“释放”状态都保存在其前驱节点中。因此，自旋锁的“自旋”操作就如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (pred.status != RELEASED) ; <span class="comment">// spin</span></span><br></pre></td></tr></table></figure><p>自旋后的出队操作只需将head字段指向刚刚得到锁的节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head = node;</span><br></pre></td></tr></table></figure><p>CLH锁的优点在于其入队和出队操作是快速、无锁的，以及无障碍的（即使在竞争下，某个线程总会赢得一次插入机会而能继续执行）；且探测是否有线程正在等待也很快（只要测试一下head是否与tail相等）；同时，“释放”状态是分散的（<em>译者注：几乎每个节点都保存了这个状态，当前节点保存了其后驱节点的“释放”状态，因此它们是分散的，不是集中于一块的。</em>），避免了一些不必要的内存竞争。</p><p>在原始版本的CLH锁中，节点间甚至都没有互相链接。自旋锁中，<code>pred</code>变量可以是一个局部变量。然而，Scott和Scherer证明了通过在节点中显式地维护前驱节点，CLH锁就可以处理“超时”和各种形式的“取消”：如果一个节点的前驱节点取消了，这个节点就可以滑动去使用前面一个节点的状态字段。</p><p>为了将CLH队列用于阻塞式同步器，需要做些额外的修改以提供一种高效的方式定位某个节点的后继节点。在自旋锁中，一个节点只需要改变其状态，下一次自旋中其后继节点就能注意到这个改变，所以节点间的链接并不是必须的。但在阻塞式同步器中，一个节点需要显式地唤醒（<code>unpark</code>）其后继节点。</p><p>AQS队列的节点包含一个<code>next</code>链接到它的后继节点。但是，由于没有针对双向链表节点的类似<code>compareAndSet</code>的原子性无锁插入指令，因此这个<code>next</code>链接的设置并非作为原子性插入操作的一部分，而仅是在节点被插入后简单地赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pred.next = node;</span><br></pre></td></tr></table></figure><p><code>next</code>链接仅是一种优化。如果通过某个节点的<code>next</code>字段发现其后继结点不存在（或看似被取消了），总是可以使用<code>pred</code>字段从尾部开始向前遍历来检查是否真的有后续节点。</p><p>第二个对CLH队列主要的修改是将每个节点都有的状态字段用于控制阻塞而非自旋。在同步器框架中，仅在线程调用具体子类中的<code>tryAcquire</code>方法返回<code>true</code>时，队列中的线程才能从<code>acquire</code>操作中返回；而单个“released”位是不够的。但仍然需要做些控制以确保当一个活动的线程位于队列头部时，仅允许其调用<code>tryAcquire</code>；这时的<code>acquire</code>可能会失败，然后（重新）阻塞。这种情况不需要读取状态标识，因为可以通过检查当前节点的前驱是否为<code>head</code>来确定权限。与自旋锁不同，读取<code>head</code>以保证复制时不会有太多的内存竞争（ there is not enough memory contention reading head to warrant replication.）。然而，“取消”状态必须存在于状态字段中。</p><p>队列节点的状态字段也用于避免没有必要的<code>park</code>和<code>unpark</code>调用。虽然这些方法跟阻塞原语一样快，但在跨越Java和JVM runtime以及操作系统边界时仍有可避免的开销。在调用<code>park</code>前，线程设置一个“唤醒（signal me）”位，然后再一次检查同步和节点状态。一个释放的线程会清空其自身状态。这样线程就不必频繁地尝试阻塞，特别是在锁相关的类中，这样会浪费时间等待下一个符合条件的线程去申请锁，从而加剧其它竞争的影响。除非后继节点设置了“唤醒”位（<em>译者注：源码中为-1</em>），否则这也可避免正在release的线程去判断其后继节点。这反过来也消除了这些情形：除非“唤醒”与“取消”同时发生，否则必须遍历多个节点来处理一个似乎为null的<code>next</code>字段。</p><p>同步框架中使用的CLH锁的变体与其他语言中的相比，主要区别可能是同步框架中使用的CLH锁需要依赖垃圾回收管理节点的内存，这就避免了一些复杂性和开销。但是，即使依赖GC也仍然需要在确定链接字段不再需要时将其置为null。这往往可以与出队操作一起完成。否则，无用的节点仍然可触及，它们就没法被回收。</p><p>其它一些更深入的微调，包括CLH队列首次遇到竞争时才需要的初始空节点的延迟初始化等，都可以在J2SE1.5的版本的源代码文档中找到相应的描述。</p><p>抛开这些细节，基本的<code>acquire</code>操作的最终实现的一般形式如下（互斥，非中断，无超时）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">f (!tryAcquire(arg)) &#123;</span><br><span class="line">    node = 创建和入栈一个新的节点;</span><br><span class="line">    pred = 节点有效的前置节点;</span><br><span class="line">    <span class="keyword">while</span> (pred前置节点不是head节点 || !tryAcquire(arg)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (设置pred前置节点的信号位)</span><br><span class="line">        park();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        compareAndSet,设置前置节点信号位为<span class="keyword">true</span>;</span><br><span class="line">        pred = 节点有效的前置节点;</span><br><span class="line">    &#125;</span><br><span class="line">    head = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>release</code>操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(tryRelease(arg) &amp;&amp; head node<span class="string">'s signal bit is set) &#123;</span></span><br><span class="line"><span class="string">    compareAndSet head'</span>s bit to <span class="keyword">false</span>;</span><br><span class="line">    unpark head<span class="string">'s successor, if one exist</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><code>acquire</code>操作的主循环次数依赖于具体实现类中<code>tryAcquire</code>的实现方式。另一方面，在没有“取消”操作的情况下，每一个组件的<code>acquire</code>和<code>release</code>都是一个O(1)的操作，忽略<code>park</code>中发生的所有操作系统线程调度。</p><p>支持“取消”操作主要是要在<code>acquire</code>循环里的<code>park</code>返回时检查中断或超时。由超时或中断而被取消等待的线程会设置其节点状态，然后<code>unpark</code>其后继节点。在有“取消”的情况下，判断其前驱节点和后继节点以及重置状态可能需要O(n)的遍历（n是队列的长度）。由于“取消”操作，该线程再也不会被阻塞，节点的链接和状态字段可以被快速重建。</p><h4 id="3-4-条件队列"><a class="header-anchor" href="#3-4-条件队列"></a>3.4 条件队列</h4><p>AQS框架提供了一个<code>ConditionObject</code>类，给维护独占同步的类以及实现<code>Lock</code>接口的类使用。一个锁对象可以关联任意数目的条件对象，可以提供典型的管程风格的<code>await</code>、<code>signal</code>和<code>signalAll</code>操作，包括带有超时的，以及一些检测、监控的方法。</p><p>通过修正一些设计决策，<code>ConditionObject</code>类有效地将条件（conditions）与其它同步操作结合到了一起。该类只支持Java风格的管程访问规则，这些规则中，仅当当前线程持有锁且要操作的条件（condition）属于该锁时，条件操作才是合法的（一些替代操作的讨论参考[<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>）。这样，一个<code>ConditionObject</code>关联到一个<code>ReentrantLock</code>上就表现的跟内置的管程（通过<code>Object.wait</code>等）一样了。两者的不同仅仅在于方法的名称、额外的功能以及用户可以为每个锁声明多个条件。</p><p><code>ConditionObject</code>使用了与同步器一样的内部队列节点。但是，是在一个单独的条件队列中维护这些节点的。<code>signal</code>操作是通过将节点从条件队列转移到锁队列中来实现的，而没有必要在需要唤醒的线程重新获取到锁之前将其唤醒。</p><p>基本的<code>await</code>操作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">创建和添加新的节点到条件队列;</span><br><span class="line">释放锁;</span><br><span class="line">阻塞,直到节点c处于锁定队列;</span><br><span class="line">重新获得锁;</span><br></pre></td></tr></table></figure><p><code>signal</code>操作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将第一个节点从条件队列转移到锁定队列;</span><br></pre></td></tr></table></figure><p>因为只有在持有锁的时候才能执行这些操作，因此他们可以使用顺序链表队列操作来维护条件队列（在节点中用一个<code>nextWaiter</code>字段）。转移操作仅仅把第一个节点从条件队列中的链接解除，然后通过CLH插入操作将其插入到锁队列上。</p><p>实现这些操作主要复杂在，因超时或<code>Thread.interrupt</code>导致取消了条件等待时，该如何处理。“取消”和“唤醒”几乎同时发生就会有竞态问题，最终的结果遵照内置管程相关的规范。JSR133修订以后，就要求如果中断发生在<code>signal</code>操作之前，await方法必须在重新获取到锁后，抛出<code>InterruptedException</code>。但是，如果中断发生在<code>signal</code>后，<code>await</code>必须返回且不抛异常，同时设置线程的中断状态。</p><p>为了维护适当的顺序，队列节点状态变量中的一个位记录了该节点是否已经（或正在）被转移。“唤醒”和“取消”相关的代码都会尝试用<code>compareAndSet</code>修改这个状态。如果某次<code>signal</code>操作修改失败，就会转移队列中的下一个节点（如果存在的话）。如果某次“取消”操作修改失败，就必须中止此次转移，然后等待重新获得锁。后面的情况采用了一个潜在的无限的自旋等待。在节点成功的被插到锁队列之前，被“取消”的等待不能重新获得锁，所以必须自旋等待CLH队列插入（即<code>compareAndSet</code>操作）被“唤醒”线程成功执行。这里极少需要自旋，且自旋里使用<code>Thread.yield</code>来提示应该调度某一其它线程，理想情况下就是执行signal的那个线程。虽然有可能在这里为“取消”实现一个帮助策略以帮助插入节点，但这种情况实在太少，找不到合适的理由来增加这些开销。在其它所有的情况下，这个基本的机制都不需要自旋或<code>yield</code>，因此在单处理器上保持着合理的性能。</p><h3 id="4-用法"><a class="header-anchor" href="#4-用法"></a>4. 用法</h3><p>AQS类将上述的功能结合到一起，并且作为一种基于“模版方法模式”<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>的基类提供给同步器。子类只需定义状态的检查与更新相关的方法，这些方法控制着acquire和 release操作。然而，将AQS的子类作为同步器ADT并不适合，因为这个类必须提供方法在内部控制acquire和release的规则，这些都不应该被用户所看到。所有java.util.concurrent包中的同步器类都声明了一个私有的继承了<code>AbstractQueuedSynchronizer</code>的内部类，并且把所有同步方法都委托给这个内部类。这样各个同步器类的公开方法就可以使用适合自己的名称。</p><p>下面是一个最简单的<code>Mutex</code>类的实现，它使用同步状态0表示解锁，1表示锁定。这个类并不需要同步方法中的参数，因此这里在调用的时候使用0作为实参，方法实现里将其忽略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Sync</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> ignore)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> compareAndSetState(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> ignore)</span> </span>&#123;</span><br><span class="line">            setState(<span class="number">0</span>); <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; sync.acquire(<span class="number">0</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; sync.release(<span class="number">0</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子的一个更完整的版本，以及其它用法指南，可以在J2SE的文档中找到。还可以有一些变体。如，tryAcquire可以使用一种“test-and-test-and-set”策略，即在改变状态值前先对状态进行校验。</p><p>令人诧异的是，像互斥锁这样性能敏感的东西也打算通过委托和虚方法结合的方式来定义。然而，这正是现代动态编译器一直在重点研究的面向对象设计结构。编译器擅长将这方面的开销优化掉，起码会优化频繁调用同步器的那些代码。</p><p><code>AbstractQueuedSynchronizer</code>类也提供了一些方法用来协助策略控制。例如，基础的acquire方法有可超时和可中断的版本。虽然到目前为止，我们的讨论都集中在像锁这样的独占模式的同步器上，但<code>AbstractQueuedSynchronizer</code>类也包含另一组方法（如<code>acquireShared</code>），它们的不同点在于<code>tryAcquireShared</code>和<code>tryReleaseShared</code>方法能够告知框架（通过它们的返回值）尚能接受更多的请求，最终框架会通过级联的signal(cascading signals)唤醒多个线程。</p><p>虽然将同步器序列化（持久化存储或传输）一般来说没有太大意义，但这些类经常会被用于构造其它类，例如线程安全的集合，而这些集合通常是可序列化的。<code>AbstractQueuedSynchronizer</code>和<code>ConditionObject</code>类都提供了方法用于序列化同步状态，但不会序列化潜在的被阻塞的线程，也不会序列化其它内部暂时性的簿记（bookkeeping）变量。即使如此，在反序列化时，大部分同步器类也只仅将同步状态重置为初始值，这与内置锁的隐式策略一致 —— 总是反序列化到一个解锁状态。这相当于一个空操作，但仍必须显式地支持以便<code>final</code>字段能够反序列化。</p><h4 id="4-1-公平调度的控制"><a class="header-anchor" href="#4-1-公平调度的控制"></a>4.1 公平调度的控制</h4><p>尽管同步器是基于FIFO队列的，但它们并不一定就得是公平的。可以注意到，在基础的acquire算法（3.3节）中，<code>tryAcquire</code>是在入队前被执行的。因此一个新的acquire线程能够“窃取”本该属于队列头部第一个线程通过同步器的机会。</p><p>可<em>闯入</em>的FIFO策略通常会提供比其它技术更高的总吞吐率。当一个有竞争的锁已经空闲，而下一个准备获取锁的线程又正在解除阻塞的过程中，这时就没有线程可以获取到这个锁，如果使用<em>闯入</em>策略，则可减少这之间的时间间隔。与此同时，这种策略还可避免过分的，无效率的竞争，这种竞争是由于只允许一个（第一个）排队的线程被唤醒然后尝试acquire操作导致的。在只要求短时间持有同步器的场景中，创建同步器的开发者可以通过定义<code>tryAcquire</code>在控制权返回之前重复调用自己若干次，来进一步凸显<em>闯入</em>的效果。</p><p><img src="/2017/08/04/AQS论文翻译/fifo-300x90-20190522121813159.png" alt="img"></p><p>可闯入的FIFO同步器只有概率性的公平属性。锁队列头部一个解除了阻塞的线程拥有一次无偏向的机会（<em>译者注：即不会偏向队头的线程也不会偏向闯入的线程</em>）来赢得与<em>闯入</em>的线程之间的竞争，如果竞争失败，要么重新阻塞要么进行重试。然而，如果<em>闯入</em>的线程到达的速度比队头的线程解除阻塞快，那么在队列中的第一个线程将很难赢得竞争，以至于几乎总要重新阻塞，并且它的后继节点也会一直保持阻塞。对于短暂持有的同步器来说，在队列中第一个线程被解除阻塞期间，多处理器上很可能发生过多次<em>闯入</em>（<em>译者注：即闯入的线程的acquire操作</em>）和<code>release</code>了。正如下文所提到的，最终结果就是保持一或多个线程的高进展速度的同时，仍至少在一定概率上避免了饥饿的发生。</p><p>当有更高的公平性需求时，实现起来也很简单。如果需要严格的公平性，程序员可以把tryAcquire方法定义为，若当前线程不是队列的头节点（可通过<code>getFirstQueuedThread</code>方法检查，这是框架提供的为数不多的几个检测方法之一），则立即失败（返回false）。</p><p>一个更快，但非严格公平的变体可以这样做，若队列为空（判断的瞬间），仍然允许<code>tryAcquire</code>执行成功。在这种情况下，多个线程同时遇到一个空队列时可能会去竞争以使自己第一个获得锁，这样，通常至少有一个线程是无需入队列的。<code>java.util.concurrent</code>包中所有支持公平模式的同步器都采用了这种策略。</p><p>尽管公平性设置在实践中很有用，但是它们并没有保障，因为Java Language Specification没有提供这样的调度保证。例如：即使是严格公平的同步器，如果一组线程永远不需要阻塞来达到互相等待，那么JVM可能会决定纯粹以顺序方式运行它们。在实际中，单处理器上，在抢占式上下文切换之前，这样的线程有可能是各自运行了一段时间。如果这样一个线程正持有某个互斥锁，它将很快会被切换回来，仅是为了释放其持有的锁，然后会继续阻塞，因为它知道有另外一个线程需要这把锁，这更增加了同步器可用但没有线程能来获取之间的间隔。同步器公平性设置在多处理器上的影响可能会更大，因为在这种环境下会产生更多的交错，因此一个线程就会有更多的机会发现锁被另一个线程请求。</p><p>在高竞争下，当保护的是短暂持有锁的代码体时，尽管性能可能会较差，但公平锁仍然能有效地工作。例如，当公平性锁保护的是相对长的代码体和/或有着相对长的锁间(inter-lock)间隔，在这种情况下，<em>闯入</em>只能带来很小的性能优势，但却可能会大大增加无限等待的风险。同步器框架将这些工程决策留给用户来确定。</p><h4 id="4-2-同步器"><a class="header-anchor" href="#4-2-同步器"></a>4.2 同步器</h4><p>下面是<code>java.util.concurrent</code>包中同步器定义方式的概述：</p><p><code>ReentrantLock</code>类使用AQS同步状态来保存锁（重复）持有的次数。当锁被一个线程获取时，<code>ReentrantLock</code>也会记录下当前获得锁的线程标识，以便检查是否是重复获取，以及当错误的线程（<em>译者注：如果线程不是锁的持有者，在此线程中执行该锁的unlock操作就是非法的</em>）试图进行解锁操作时检测是否存在非法状态异常。<code>ReentrantLock</code>也使用了AQS提供的ConditionObject，还向外暴露了其它监控和监测相关的方法。<code>ReentrantLock</code>通过在内部声明两个不同的<code>AbstractQueuedSynchronizer</code>实现类（提供公平模式的那个禁用了<em>闯入</em>策略）来实现可选的公平模式，在创建ReentrantLock实例的时候根据设置（<em>译者注：即ReentrantLock构造方法中的fair参数</em>）使用相应的<code>AbstractQueuedSynchronizer</code>实现类。</p><p><code>ReentrantReadWriteLock</code>类使用AQS同步状态中的16位来保存写锁持有的次数，剩下的16位用来保存读锁的持有次数。<code>WriteLock</code>的构建方式同<code>ReentrantLock</code>。<code>ReadLock</code>则通过使用<code>acquireShared</code>方法来支持同时允许多个读线程。</p><p><code>Semaphore</code>类（计数信号量）使用AQS同步状态来保存信号量的当前计数。它里面定义的acquireShared方法会减少计数，或当计数为非正值时阻塞线程；<code>tryRelease</code>方法会增加计数，可能在计数为正值时还要解除线程的阻塞。</p><p><code>CountDownLatch</code>类使用AQS同步状态来表示计数。当该计数为0时，所有的acquire操作（<em>译者注：acquire操作是从aqs的角度说的，对应到CountDownLatch中就是await方法</em>）才能通过。</p><p><code>FutureTask</code>类使用AQS同步状态来表示某个异步计算任务的运行状态（初始化、运行中、被取消和完成）。设置（<em>译者注：FutureTask的set方法</em>）或取消（<em>译者注：FutureTask的cancel方法</em>）一个<code>FutureTask</code>时会调用AQS的<code>release</code>操作，等待计算结果的线程的阻塞解除是通过AQS的<code>acquire</code>操作实现的。</p><p><code>SynchronousQueues</code>类（一种CSP*（Communicating Sequential Processes）*形式的传递）使用了内部的等待节点，这些节点可以用于协调生产者和消费者。同时，它使用AQS同步状态来控制当某个消费者消费当前一项时，允许一个生产者继续生产，反之亦然。</p><p><code>java.util.concurrent</code>包的使用者当然也可以为自定义的应用定义自己的同步器。例如，那些曾考虑到过的，但没有采纳进这个包的同步器包括提供WIN32事件各种风格的语义类，二元信号量，集中管理的锁以及基于树的屏障。</p><h3 id="5-性能"><a class="header-anchor" href="#5-性能"></a>5. 性能</h3><p>虽然AQS框架除了支持互斥锁外，还支持其它形式的同步方式，但锁的性能是最容易测量和比较的。即使如此，也还存在许多不同的测量方式。这里的实验主要是设计来展示锁的开销和吞吐量。</p><p>在每个测试中，所有线程都重复的更新一个伪随机数，该随机数由<code>nextRandom(int seed)</code>方法计算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> t = (seed % <span class="number">127773</span>) * <span class="number">16807</span> – (seed / <span class="number">127773</span>) * <span class="number">2836</span>;</span><br><span class="line"><span class="keyword">return</span> (t &gt; <span class="number">0</span>)? t : t + <span class="number">0x7fffffff</span>;</span><br></pre></td></tr></table></figure><p>在每次迭代中，线程以概率S在一个互斥锁下更新共享的生成器，否则（<em>译者注：概率为1-S</em>）更新其自己局部的生成器，此时是不需要锁的。如此，锁占用区域的耗时是短暂的，这就使线程持有锁期间被抢占时的外界干扰降到了最小。这个函数的随机性主要是为了两个目的：确定是否需要使用锁（这个生成器足以应付这里的需求），以及使循环中的代码不可能被轻易地优化掉。</p><p>这里比较了四种锁：内置锁，用的是<code>synchronized</code>块；互斥锁，用的是像第四节例子中的那样简单的Mutex类；可重入锁，用的是<code>ReentrantLock</code>；以及公平锁，用的是<code>ReentrantLock</code>的公平模式。所有测试都运行在J2SE1.5 JDK build46（大致与beta2相同）的server模式下。在收集测试数据前，测试程序先运行20次非竞争的测试，以排除JVM“预热”（<em>译者注：更多关于“预热”的内容，参见：Java 理论与实践: 动态编译与性能测量</em>）过程的影响。除了公平模式下的测试只跑了一百万次迭代，其它每个线程中的测试都运行了一千万次迭代。</p><p>该测试运行在四个X86机器和四个UltraSparc机器上。所有X86机器都运行的是RedHat基于NPTL 2.4内核和库的Linux系统。所有的UltraSparc机器都运行的是Solaris-9。测试时所有系统的负载都很轻。根据该测试的特征，并不要求系统完全空闲（<em>译者注：即测试时操作系统上有其它较轻的负载也不会影响本次测试的结果。</em>）。“4P”这个名字反映出双核超线程的Xeon更像是4路机器，而不是2路机器。这里没有将测试数据规范化。如下所示，同步的相对开销与处理器的数量、类型、速度之间不具备简单的关系。</p><p><strong>表1 测试的平台</strong></p><table><thead><tr><th>名字</th><th>处理器数量</th><th>类型</th><th>速度(Mhz)</th></tr></thead><tbody><tr><td>1P</td><td>1</td><td>Pentium3</td><td>900</td></tr><tr><td>2P</td><td>2</td><td>Pentium3</td><td>1400</td></tr><tr><td>2A</td><td>2</td><td>Athlon</td><td>2000</td></tr><tr><td>4P</td><td>2HT</td><td>Pentium4/Xeon</td><td>2400</td></tr><tr><td>1U</td><td>1</td><td>UltraSparc2</td><td>650</td></tr><tr><td>4U</td><td>4</td><td>UltraSparc2</td><td>450</td></tr><tr><td>8U</td><td>8</td><td>UltraSparc3</td><td>750</td></tr><tr><td>24U</td><td>24</td><td>UltraSparc3</td><td>750</td></tr></tbody></table><h4 id="5-1-开销"><a class="header-anchor" href="#5-1-开销"></a>5.1 开销</h4><p>无竞争情况下的开销是通过仅运行一个线程，将概率S为1时的每次迭代时间减去概率S为0（访问共享内存的概率为0）时的每次迭代时间得到的（<em>译者注：这里的“概率S”即前文提到的“概率S”，概率为0时是没有锁操作的，概率为1时是每次都有锁操作，因此将概率为1时的耗时减去概率为0时的耗时就是整个锁操作的开销。</em>）。表2以纳秒为单位显示了非竞争场景下每次锁操作的开销。Mutex类最接近于框架的基本耗时，可重入锁的额外开销是记录当前所有者线程和错误检查的耗时，对于公平锁来说还包含开始时检查队列是否为空的耗时。</p><p>表格2也展示与内置锁的“快速路径（fast path）”对比，<code>tryAcquire</code>的耗时。这里的差异主要反映出了各锁和机器中使用的不同的原子指令以及内存屏障的耗时。在多处理器上，这些指令常常是完全优于所有其它指令的。内置锁和同步器类之间的主要差别，显然是由于Hotspot锁在锁定和解锁时都使用了一次<code>compareAndSet</code>，而同步器的<code>acquire</code>操作使用了一次<code>compareAndSet</code>，但<code>release</code>操作用的是一次<code>volatile</code>写（即，多处理器上的一次内存屏障以及所有处理器上的重排序限制）。每个锁的绝对的和相对耗时因机器的不同而不同。</p><p><strong>表2 无竞争时的单锁开销（单位：纳秒）</strong></p><table><thead><tr><th>机器</th><th>内置</th><th>互斥</th><th>可重入</th><th>公平可重入</th></tr></thead><tbody><tr><td>1P</td><td>18</td><td>9</td><td>31</td><td>37</td></tr><tr><td>2P</td><td>58</td><td>71</td><td>77</td><td>81</td></tr><tr><td>2A</td><td>13</td><td>21</td><td>31</td><td>30</td></tr><tr><td>4P</td><td>116</td><td>95</td><td>109</td><td>117</td></tr><tr><td>1U</td><td>90</td><td>40</td><td>58</td><td>67</td></tr><tr><td>4U</td><td>122</td><td>82</td><td>100</td><td>115</td></tr><tr><td>8U</td><td>160</td><td>83</td><td>103</td><td>123</td></tr><tr><td>24U</td><td>161</td><td>84</td><td>108</td><td>119</td></tr></tbody></table><p>从另一个极端看，表3展示了概率S为1，运行256个并发线程时产生了大规模的锁竞争下每个锁的开销。在完全饱和的情况下，可<em>闯入</em>的FIFO锁比内置锁的开销少了一个数量级（也就是更大的吞吐量），比公平锁更是少了两个数量级。这表现出即使有着极大的竞争，在维持线程进展方面可<em>闯入</em>FIFO策略的效率。</p><p>表3也说明了即使在内部开销比较低的情况下，公平锁的性能也完全是由上下文切换的时间所决定的。列出的时间大致上都与各平台上线程阻塞和解除线程阻塞的时间相称。</p><p>此外，后面增加的一个实验（仅使用机器4P）表明，对于这里用到的短暂持有的锁，公平参数的设置在总差异中的影响很小。这里将线程终止时间间的差异记录成一个粗粒度的离散量数。在4P的机器上，公平锁的时间度量的标准差平均为0.7%，可重入锁平均为6.0%。作为对比，为模拟一个长时间持有锁的场景，测试中使每个线程在持有锁的情况下计算了16K次随机数。这时，总运行时间几乎是相同的（公平锁：9.79s，可重入锁：9.72s）。公平模式下的差异依然很小，标准差平均为0.1%，而可重入锁上升到了平均29.5%。</p><p><strong>表格3 饱和时的单锁开销（单位：纳秒）</strong></p><table><thead><tr><th>机器</th><th>内置</th><th>互斥</th><th>可重入</th><th>公平可重入</th></tr></thead><tbody><tr><td>1P</td><td>521</td><td>46</td><td>67</td><td>8327</td></tr><tr><td>2P</td><td>930</td><td>108</td><td>132</td><td>14967</td></tr><tr><td>2A</td><td>748</td><td>79</td><td>84</td><td>33910</td></tr><tr><td>4P</td><td>1146</td><td>188</td><td>247</td><td>15328</td></tr><tr><td>1U</td><td>879</td><td>153</td><td>177</td><td>41394</td></tr><tr><td>4U</td><td>2590</td><td>347</td><td>368</td><td>30004</td></tr><tr><td>8U</td><td>1274</td><td>157</td><td>174</td><td>31084</td></tr><tr><td>24U</td><td>1983</td><td>160</td><td>182</td><td>32291</td></tr></tbody></table><h4 id="5-2-吞吐量"><a class="header-anchor" href="#5-2-吞吐量"></a>5.2 吞吐量</h4><p>大部分同步器都是用于无竞争和极大竞争之间的。这可以用实验在两个方面进行检查，通过修改固定个线程的竞争概率，和/或通过往拥有固定竞争概率的线程集合里增加更多的线程。为了说明这些影响，测试运行在不同的竞争概率和不同的线程数目下，都用的是可重入锁。附图使用了一个<em>slowdown</em>度量标准。</p><p><a href="http://ifeve.com/wp-content/uploads/2013/02/formula.jpg" target="_blank" rel="noopener"><img src="/2017/08/04/AQS论文翻译/formula-300x66-20190522121813117.jpg" alt="img"></a></p><p>这里，t是总运行时间，b是一个线程在没有竞争或同步下的基线时间，n是线程数，p是处理器数，S是共享访问的比例（<em>译者注：即前面的竞争概率S</em>）。计算结果是实际执行时间与理想执行时间（通常是无法得到的）的比率，理想执行时间是通过使用Amdahl’s法则计算出来的。理想时间模拟了一次没有同步开销，没有因锁争用而导致线程阻塞的执行过程。即使这样，在很低的竞争下，相比理想时间，有一些测试结果却表现出了很小的速度增长，大概是由于基线和测试之间的优化、流水线等方面有着轻微的差别。</p><p>图中用以2为底的对数为比例进行了缩放。例如，值为1表示实际时间是理想时间的两倍，4表示慢16倍。使用对数就不需要依赖一个随意的基线时间（这里指的是计算随机数的时间），因此，基于不同底数计算的结果表现出的趋势应该是类似的。这些测试使用的竞争概率从1/128（标识为“0.008”）到1，以2的幂为步长，线程的数量从1到1024，以2的幂的一半为步长。</p><p>在单处理器（1P和1U）上，性能随着竞争的上升而下降，但不会随着线程数的增加而下降。多处理器在遭遇竞争时，性能下降的更快。根据多处理器相关的图表显示，开始出现的峰值处虽然只有几个线程的竞争，但相对性能通常却最差。这反映出了一个性能的<em>过渡区域</em>，在这里<em>闯入</em>的线程和被唤醒的线程都准备获取锁，这会让它们频繁的迫使对方阻塞。在大部分时候，过渡区域后面会紧接着一个<em>平滑区域</em>，因为此时几乎没有空闲的锁，所以会与单处理器上顺序执行的模式差不多；在多处理器机器上会较早进入平滑区域。例如，请注意，在满竞争（标识为“1.000”）下这些值表示，在处理器越少的机器上，会有更糟糕的相对速度下降。</p><p>根据这些结果，可以针对阻塞（park/unpark）做进一步调优以减少上下文切换和相关的开销，这会给本框架带来小但显著的提升。此外，在多处理器上为短时间持有的但高竞争的锁采用某种形式的适应性自旋，可以避免这里看到的一些波动，这对同步器类大有裨益。虽然在跨不同上下文时适应性自旋很难很好的工作，但可以使用本框架为遇到这类使用配置的特定应用构建一个自定义形式的锁。</p><p><img src="/2017/08/04/AQS论文翻译/584866-20170721153333433-1036091107-20190522121812946.jpg" alt="img"></p><p><img src="/2017/08/04/AQS论文翻译/584866-20170721153344933-80322669-20190522121812997.jpg" alt="img"></p><p><img src="/2017/08/04/AQS论文翻译/584866-20170721153353714-548675583-20190522121813004.jpg" alt="img"></p><p><img src="/2017/08/04/AQS论文翻译/584866-20170721153402620-2093158242-20190522121812993.jpg" alt="img"></p><h3 id="6-总结"><a class="header-anchor" href="#6-总结"></a>6. 总结</h3><p>本文撰写之时，<code>java.util.concurrent</code>包中的同步器框架还太新所以还不能在实践中使用。因此在J2SE 1.5最终版本发布之前都很难看到其大范围的使用，并且，它的设计，API实现以及性能肯定还有无法预料的后果。但是，此时，这个框架明显能胜任其基本的目标，即为创建新的同步器提供一个高效的基础。</p><h3 id="7-致谢"><a class="header-anchor" href="#7-致谢"></a>7. 致谢</h3><p>Thanks to Dave Dice for countless ideas and advice during the development of this framework, to Mark Moir and Michael Scott for urging consideration of CLH queues, to David Holmes for critiquing early versions of the code and API, to Victor Luchangco and Bill Scherer for reviewing previous incarnations of the source code, and to the other members of the JSR166 Expert Group (Joe Bowbeer, Josh Bloch, Brian Goetz, David Holmes, and Tim Peierls) as well as Bill Pugh, for helping with design and specifications and commenting on drafts of this paper. Portions of this work were made possible by a DARPA PCES grant, NSF grant EIA-0080206 (for access to the 24way Sparc) and a Sun Collaborative Research Grant.</p><h3 id="参考文献"><a class="header-anchor" href="#参考文献"></a>参考文献</h3><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>译文原文链接：原文链接：<a href="https://www.cnblogs.com/dennyzhangdd/p/7218510.html" target="_blank" rel="noopener">https://www.cnblogs.com/dennyzhangdd/p/7218510.html</a> <a href="#fnref1" class="footnote-backref">↩</a></p></li><li id="fn2" class="footnote-item"><p>Craig, T. S. Building FIFO and priority-queueing spin locks from atomic swap. Technical Report TR 93-02-02,Department of Computer Science, University of Washington, Feb. 1993. <a href="#fnref2" class="footnote-backref">↩</a></p></li><li id="fn3" class="footnote-item"><p>Magnussen, P., A. Landin, and E. Hagersten. Queue locks on cache coherent multiprocessors. 8th Intl. Parallel Processing Symposium, Cancun, Mexico, Apr. 1994. <a href="#fnref3" class="footnote-backref">↩</a></p></li><li id="fn4" class="footnote-item"><p>M. L. Scott and W N. Scherer III. Scalable Queue-Based Spin Locks with Timeout. 8th ACM Symp. on Principles and Practice of Parallel Programming, Snowbird, UT, June 2001. <a href="#fnref4" class="footnote-backref">↩</a></p></li><li id="fn5" class="footnote-item"><p>Buhr, P. M. Fortier, and M. Coffin. Monitor Classification,ACM Computing Surveys, March 1995. <a href="#fnref5" class="footnote-backref">↩</a></p></li><li id="fn6" class="footnote-item"><p>Gamma, E., R. Helm, R. Johnson, and J. Vlissides. Design Patterns, Addison Wesley, 1996. <a href="#fnref6" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AQS </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>看起来简单的通知推送服务，真的简单吗</title>
      <link href="/2016/05/31/%E7%9C%8B%E8%B5%B7%E6%9D%A5%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%9A%E7%9F%A5%E6%8E%A8%E9%80%81%E6%9C%8D%E5%8A%A1%EF%BC%8C%E7%9C%9F%E7%9A%84%E7%AE%80%E5%8D%95%E5%90%97/"/>
      <url>/2016/05/31/%E7%9C%8B%E8%B5%B7%E6%9D%A5%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%9A%E7%9F%A5%E6%8E%A8%E9%80%81%E6%9C%8D%E5%8A%A1%EF%BC%8C%E7%9C%9F%E7%9A%84%E7%AE%80%E5%8D%95%E5%90%97/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a class="header-anchor" href="#背景"></a>背景</h1><p>目前OneAlert提供短信、邮件、电话、APP四种通知通道，其中前三种的使用量最高(90%以上的用户)，因此靠谱的第三方推送提供商至关重要。经过对各种三方推送服务的公司调研，目前锁定了阿里大鱼<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>、容联云<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>、云片<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>、云之讯<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>、SendCloud<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>，这5家平台提供商。</p><p>首先我们来分析一下接入三方后的通讯模型</p><p><img src="/2016/05/31/看起来简单的通知推送服务，真的简单吗/%E6%8E%A8%E9%80%81%E6%A8%A1%E5%9E%8B.svg" alt="推送模型"></p><blockquote><p>注：配额这里是指三方服务商的发送限制，比如每小时最多每个电话拨打几次</p></blockquote><a id="more"></a><p>我们作为一个服务提供商，必然要确保用户的告警可以准确、准时、不漏的投递给用户，这个问题看起来一目了然，没什么难度，其实不然，我们分析下以上通信模型中的几种情况：</p><h2 id="s1-发送成功"><a class="header-anchor" href="#s1-发送成功"></a>s1:发送成功</h2><p>最好的情况（这里由于无法真正的监控第三方是否真正投递到了用户，不过根据以往的工单经验，丢失的概率很小）</p><h2 id="s2-超出配额"><a class="header-anchor" href="#s2-超出配额"></a>s2:超出配额</h2><h3 id="换个重发"><a class="header-anchor" href="#换个重发"></a>换个重发</h3><p>超出配额，那就换个重发呗？这是下意识的解决思路，我们看看有什么问题：</p><p><img src="/2016/05/31/看起来简单的通知推送服务，真的简单吗/%E8%B6%85%E5%87%BA%E9%85%8D%E9%A2%9D.svg" alt="超出配额"></p><h3 id="独立状态服务"><a class="header-anchor" href="#独立状态服务"></a>独立状态服务</h3><p>很直观的发现，重试的次数有可能会很多，这非常影响推送实时性。马上，我们又会想到可以对每次超出配额的情况进行缓存，提炼一个状态服务，如下：</p><p><img src="/2016/05/31/看起来简单的通知推送服务，真的简单吗/%E8%B6%85%E5%87%BA%E9%85%8D%E9%A2%9D_%E6%8E%A8%E9%80%81%E6%9C%8D%E5%8A%A1%E5%95%86%E9%85%8D%E9%A2%9D%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1.svg" alt="超出配额_推送服务商配额状态服务"></p><p>问题到此为止，一切美好已经发生… 遗憾的是，该状态服务几乎是不可用的。我们可以进一步思考：</p><p>当第一次配额超出的情况发生时，按照上面的设计，该状态服务会缓存下来；</p><p>当第二次推送来临时，会首先请求状态服务，拿到配额超出的那个服务商，排除掉它，使用其他服务商发送</p><p>当第三次推送来临时，会首先请求状态服务，拿到配额超出的那个服务商，排除掉它，使用其他服务商发送</p><p>…</p><p>当第n次推送…</p><p>此时问题一目了然，某个三方服务商第一次超出配额后就不再被请求了，这显然不是我们要的。如果我们试图及时、恰当的让某超出配额的状态失效掉，问题是我们如何知道什么时间或者哪一次请求时让其失效呢？</p><h3 id="小结"><a class="header-anchor" href="#小结"></a>小结</h3><p>目前看来，针对简单的请求-重试模型是很难解决我们的问题的。</p><h1 id="换个思路"><a class="header-anchor" href="#换个思路"></a>换个思路</h1><p>上面所有的方案每次发送都是无状态的，如果我们对每个时间段每次发送用的哪个服务商记录下来，结合配额限制，这样是不是可以做到避免处罚超出配额的问题呢？</p><p>我们来分析下：</p><p><img src="/2016/05/31/看起来简单的通知推送服务，真的简单吗/%E8%B6%85%E5%87%BA%E9%85%8D%E9%A2%9D_%E8%AE%B0%E5%BD%95%E6%8E%A8%E9%80%81%E7%8A%B6%E6%80%81.svg" alt="超出配额_记录推送状态"></p><p>嗯… 此时貌似已经解决了问题。不过从设计来看，NotifySender职责太多了，既要负责发送消息，又得记录发送状态，不符合单一职责原则。如果将来对三方服务商做增加、下线操作，还要动NotifySender，显然是不合理的。</p><h2 id="小结-v2"><a class="header-anchor" href="#小结-v2"></a>小结</h2><p>通过有状态的发送，解决了配额问题，但NotifySender职责太多，不利于拓展，需要再次设计。</p><h1 id="最后方案"><a class="header-anchor" href="#最后方案"></a>最后方案</h1><p>事实上，我们需要一个这样的服务，它能根据三方服务商目前的配额情况，自动的给我们的消息路由到合适的服务商。</p><blockquote><p>实质上，对于每次发送「计数」这件事，其实可以换一个角度思考，我们只要确保在单位时间内，按照配额作为权重将消息分发给服务商即可，这样也能确保不会触发超出配额异常。</p><p>由于篇幅关系，这里不对轮询算法进行展开讨论，而且本身算法不是重点，此类算法网上一搜一大堆，笔者也不想赘述，重要的是我们对业务场景进行实质分析。</p><p>ok，直接给出结论：加权轮询算法（如果读者有兴趣，可以给我发邮件，我们一起讨论: P）</p></blockquote><p><img src="/2016/05/31/看起来简单的通知推送服务，真的简单吗/%E8%B6%85%E5%87%BA%E9%85%8D%E9%A2%9D_%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2%E6%96%B9%E6%A1%88.svg" alt="超出配额_加权轮询方案"></p><p>对调度服务的补充解释：</p><p>我们选择将服务商信息存放在配置中心里，主要考虑了以下几点：</p><ul><li>如果服务商将来由于各种原因维护，我们只需要从配置中心去掉这个服务商即可，NotifySender不需要做任何改动</li><li>如果服务商将来更改了配额，我们只需要在配置中心重新配置一下这个服务商的配额信息即可，NotifySender也不需要做任何改动</li></ul><h1 id="reference"><a class="header-anchor" href="#reference"></a>Reference</h1><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://dayu.aliyun.com" target="_blank" rel="noopener">https://dayu.aliyun.com</a> 阿里大鱼 <a href="#fnref1" class="footnote-backref">↩</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://www.yuntongxun.com/" target="_blank" rel="noopener">https://www.yuntongxun.com/</a> 容联云 <a href="#fnref2" class="footnote-backref">↩</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://www.yunpian.com" target="_blank" rel="noopener">https://www.yunpian.com</a> 云片 <a href="#fnref3" class="footnote-backref">↩</a></p></li><li id="fn4" class="footnote-item"><p><a href="https://www.ucpaas.com" target="_blank" rel="noopener">https://www.ucpaas.com</a> 云之讯 <a href="#fnref4" class="footnote-backref">↩</a></p></li><li id="fn5" class="footnote-item"><p><a href="https://sendcloud.sohu.com/" target="_blank" rel="noopener">https://sendcloud.sohu.com/</a> SendCloud <a href="#fnref5" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 业务场景 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通知推送 </tag>
            
            <tag> 轮询算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java集合源码剖析目录</title>
      <link href="/2015/06/04/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%9B%AE%E5%BD%95/"/>
      <url>/2015/06/04/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<ol><li><p><a href="http://houqian.xyz/2015/05/14/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8B%E6%A0%B8%E5%BF%83%E6%8E%A5%E5%8F%A3/">Java集合源码剖析之核心接口</a></p></li><li><p><a href="http://houqian.xyz/2015/06/03/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8BArrayList/">Java集合源码剖析之ArrayList</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 源码剖析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java集合 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java集合源码剖析之ArrayList</title>
      <link href="/2015/06/03/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8BArrayList/"/>
      <url>/2015/06/03/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8BArrayList/</url>
      
        <content type="html"><![CDATA[<p>此为 <a href="http://houqian.xyz/2015/06/04/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%9B%AE%E5%BD%95/">Java集合源码剖析</a>系列的一部分</p><h1 id="简介"><a class="header-anchor" href="#简介"></a>简介</h1><p>ArrayList属于线性表的一种，底层由数组实现。相对于数组，它具有动态扩容的能力，也可以称其为动态数组。</p><h1 id="继承体系"><a class="header-anchor" href="#继承体系"></a>继承体系</h1><p><img src="/2015/06/03/Java集合源码剖析之ArrayList/ArrayList%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.svg" alt="ArrayList继承关系"></p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 源码剖析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java集合 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java集合源码剖析之核心接口</title>
      <link href="/2015/05/14/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8B%E6%A0%B8%E5%BF%83%E6%8E%A5%E5%8F%A3/"/>
      <url>/2015/05/14/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8B%E6%A0%B8%E5%BF%83%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p>此为 <a href="http://houqian.xyz/2015/06/04/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%9B%AE%E5%BD%95/">Java集合源码剖析</a>系列的一部分</p><h1 id="背景"><a class="header-anchor" href="#背景"></a>背景</h1><p>最近把Javadoc精读了一遍，发现许多概念和自己印象里的不一致（记忆掺杂了各种想当然的假设，以及容易受到各种其他因素的干扰，因此和事实会产生许多不一致）。还是很有必要将其系统的梳理一下的，魔鬼在细节，虽然有点儿枯燥，但花些功夫矫正偏差是很有必要的。</p><h1 id="引言"><a class="header-anchor" href="#引言"></a>引言</h1><p>Java集合位于java.util包下，主要分为两大类：字典、线性表。其核心接口如下：</p><p><img src="/2015/05/14/Java集合源码剖析之核心接口/Java%E9%9B%86%E5%90%88%E6%A0%B8%E5%BF%83%E6%8E%A5%E5%8F%A3-9580177.svg" alt="Java集合核心接口"></p><a id="more"></a><h1 id="线性表类"><a class="header-anchor" href="#线性表类"></a>线性表类</h1><h2 id="iterable"><a class="header-anchor" href="#iterable"></a>Iterable</h2><h3 id="职责"><a class="header-anchor" href="#职责"></a>职责</h3><h3 id="核心方法"><a class="header-anchor" href="#核心方法"></a>核心方法</h3><ul><li>boolean hasNext()如果有更多的元素，则返回true</li><li>E next()返回迭代中的下一个元素。如果已经没有元素会抛出<code>NoSuchElementException</code></li><li>default remove()从底层集合中移除此迭代器返回的最后一个元素(注意，你要删除哪个元素，要先调用<code>next()</code>方法使指针跳过该元素才可以删除)。此方法不可用连续调用。<ul><li>如果该iterator不允许删除元素，抛出<code>UnsupportedOperationException</code></li><li>如果调用<code>remove()</code>前没有调用<code>next()</code>，或者是<code>next()</code>后调用2次<code>remove()</code>，抛出<code>UnsupportedOperationException</code></li></ul></li><li>default void forEachRemaining(Consumer&lt;? super E&gt; action)对每个元素执行action方法<ul><li>如果action==null,抛出<code>NullPointerException</code></li></ul></li></ul><blockquote><p>笔者发现这种线性描述不利于后期查看，不过这东西见仁见智，因此此处姑且放上这么一段。但是之后的所有情况都以二维表格的形式记录。</p></blockquote><h2 id="collection"><a class="header-anchor" href="#collection"></a>Collection</h2><h3 id="职责-v2"><a class="header-anchor" href="#职责-v2"></a>职责</h3><p>所有的线性表类、接口都继承该接口。有些集合允许重复元素而其他集合则不允许。有些是有序的，有些是无序的。JDK不提供此接口的任何直接实现：它提供了更具体的子接口（如Set和List）的实现。此接口通常用于在需要最大通用性的情况下，传递集合并对其进行操作。</p><p>所有通用Collection实现类（通常通过其子接口间接实现Collection）应提供两个“标准”构造函数：</p><ul><li>无参数构造器，它创建并返回一个空集合</li><li>一个参数类型是Collection的构造器，它接收一个集合，并用这个集合创建一个新的集合（两个集合类型不同，主要是用来进行类型转换 ）</li></ul><p>由每个集合子类来决定自己的同步策略。</p><h3 id="核心方法-v2"><a class="header-anchor" href="#核心方法-v2"></a>核心方法</h3><style>  /*基本样式*/  table {      width: 100%; /*表格宽度*/      /*max-width: 65em; *//*表格最大宽度，避免表格过宽*/      border: 1px solid #dedede; /*表格外边框设置*/      margin: 15px auto; /*外边距*/      border-collapse: collapse; /*使用单一线条的边框*/      empty-cells: show; /*单元格无内容依旧绘制边框*/    overflow:scroll;  }  table th,  table td {    height: 35px; /*统一每一行的默认高度*/    border: 1px solid #dedede; /*内部边框样式*/    padding: 0 10px; /*内边距*/  }  /*表头样式*/  table th {      font-weight: bold; /*加粗*/      text-align: center !important; /*内容居中，加上 !important 避免被 Markdown 样式覆盖*/      background: rgba(158,188,226,0.2); /*背景色*/  }    /*隔行变色*/  table tbody tr:nth-child(2n) {      background: rgba(158,188,226,0.12);   }    /*悬浮变色*/  table tr:hover {      background: #efefef;   }    /*表头不换行*/  table th {      white-space: nowrap; /*表头内容强制在一行显示*/  }    /*首列不换行*/  table td:nth-child(1) {      white-space: nowrap;   }</style><table><thead><tr><th style="text-align:left">返回值类型</th><th style="text-align:left">方法</th><th style="text-align:left">职责描述</th><th style="text-align:left">异常</th></tr></thead><tbody><tr><td style="text-align:left"><code>boolean</code></td><td style="text-align:left"><code>add(E e)</code></td><td style="text-align:left">向集合添加指定的元素，如果该集合因为调用该方法而改变，返回true（如果该集合不允许重复并且已经包含了指定的元素，返回false）</td><td style="text-align:left">UnsupportedOperationException- 如果此集合不支持添加操作 <br>ClassCastException - 如果指定元素的类阻止将其添加到此集合中<br> NullPointerException - 如果指定的元素为null且此collection不允许null元素 <br>IllegalArgumentException - 如果元素的某些属性阻止将其添加到此集合中 <br>IllegalStateException - 如果由于插入限制而无法在此时添加元素</td></tr><tr><td style="text-align:left"><code>boolean</code></td><td style="text-align:left"><code>addAll(Collection&lt;? extends E&gt; c)</code></td><td style="text-align:left">将指定集合中的所有元素添加到此集合中</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>void</code></td><td style="text-align:left"><code>clear()</code></td><td style="text-align:left">从此集合中删除所有元素（可选操作）</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>boolean</code></td><td style="text-align:left"><code>contains(Object o)</code></td><td style="text-align:left">如果该集合包含指定的元素，则返回true</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>boolean</code></td><td style="text-align:left"><code>containsAll(Collection&lt;?&gt; c)</code></td><td style="text-align:left">如果该集合包含入参集合的所有元素，则返回true</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>boolean</code></td><td style="text-align:left"><code>equals(Object o)</code></td><td style="text-align:left">将指定对象与此集合进行比较，相等则返回true，反之，false</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>int</code></td><td style="text-align:left"><code>hashCode()</code></td><td style="text-align:left">返回此集合的哈希码值</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>boolean</code></td><td style="text-align:left"><code>isEmpty()</code></td><td style="text-align:left">如果该集合不包含任何元素，则返回true</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>Iterator&lt;E&gt;</code></td><td style="text-align:left"><code>iterator()</code></td><td style="text-align:left">返回该集合的迭代器。（无法保证返回元素的顺序，除非实现类是有序的）</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>default Stream&lt;E&gt;</code></td><td style="text-align:left"><code>parallelStream()</code></td><td style="text-align:left">返回此集合的并行流</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>boolean</code></td><td style="text-align:left"><code>remove(Object o)</code></td><td style="text-align:left">从此集合中移除指定元素的单个实例（如果存在则删除成功，返回true，反之，false）</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>boolean</code></td><td style="text-align:left"><code>removeAll(Collection&lt;?&gt; c)</code></td><td style="text-align:left">从该集合的元素中删除入参集合的元素</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>default boolean</code></td><td style="text-align:left"><code>removeIf(Predicate&lt;? super E&gt; filter)</code></td><td style="text-align:left">从该集合的元素中删除满足入参Predicate的元素</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>boolean</code></td><td style="text-align:left"><code>retainAll(Collection&lt;?&gt; c)</code></td><td style="text-align:left">仅保留此集合中包含在指定集合中的元素（可选操作）</td><td style="text-align:left">UnsupportedOperationException- 如果此集合不支持retainAll操作 <br>ClassCastException- 如果此集合中的一个或多个元素的类型与指定的集合不兼容（可选）<br>NullPointerException- 如果此集合包含一个或多个null元素，并且指定的集合不允许null元素（可选），或者指定的集合为null</td></tr><tr><td style="text-align:left"><code>int</code></td><td style="text-align:left"><code>size()</code></td><td style="text-align:left">返回此集合中的元素个数（如果集合内元素个数大于Integer.MAX_VALUE，那么只返回Integer.MAX_VALUE）</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>default Spliterator&lt;E&gt;</code></td><td style="text-align:left"><code>spliterator()</code></td><td style="text-align:left">返回此集合的Spliterator（java1.8新增接口，为了对集合进行并行计算，用于对集合进行分区，在stream中使用很多）</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>default Stream&lt;E&gt;</code></td><td style="text-align:left"><code>stream()</code></td><td style="text-align:left">返回该集合的流</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>Object[]</code></td><td style="text-align:left"><code>toArray()</code></td><td style="text-align:left">将该集合转换成Object数组（如果该实现类是有序的，那么返回的数组顺序与之相同；并且返回的数组是新创建的，该集合不会保留数组引用，因此用户可以放心修改数组）</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>&lt;T&gt; T[]</code></td><td style="text-align:left"><code>toArray(T[] a)</code></td><td style="text-align:left">将该集合转换成入参类型的数组（满足toArray()的承诺。对于传入的数组，如果其长度大于该集合的长度，则对多出的部分填充null值）</td><td style="text-align:left"></td></tr></tbody></table><h2 id="list"><a class="header-anchor" href="#list"></a>List</h2><h3 id="职责-v3"><a class="header-anchor" href="#职责-v3"></a>职责</h3><p>有序集合(也称为序列)。这个接口的用户可以精确地控制列表中每个元素插入的位置。用户可以通过其整数索引(列表中的位置)访问元素，并在列表中搜索元素。与集合不同，列表通常允许重复元素。</p><p>List接口提供了一个特殊的迭代器，称为ListIterator，除了迭代器接口提供的常规操作之外，它还允许插入和替换元素，以及双向访问。提供了一个方法来获取从列表中指定位置开始的列表迭代器。</p><p>List接口提供了两个方法来搜索指定的对象。从性能的角度来看，应该谨慎使用这些方法。在许多实现中，它们将执行代价高昂的线性搜索（时间复杂度高）。</p><h3 id="核心方法-v3"><a class="header-anchor" href="#核心方法-v3"></a>核心方法</h3><p>除了包含Collection接口所有方法外，还有以下方法：</p><table><thead><tr><th>返回值类型</th><th>方法</th><th>职责描述</th></tr></thead><tbody><tr><td>boolean</td><td>addAll(int index, Collection&lt;? extends E&gt; c)</td><td>将指定的集合的元素按照原本的顺序插入到指定索引位置。比如list=[1, 2, 3], list2=[5,6,7],list.addAll(1,list2),那么list变成 [1,5,6,7,2,3]</td></tr><tr><td>void</td><td>replaceAll(UnaryOperator<e> operator)</e></td><td>将集合每一个元素替换成operator.apply(元素)的结果</td></tr><tr><td>sort</td><td>sort(Comparator&lt;? super E&gt; c)</td><td>将列表根据制定的比较器进行排序。</td></tr><tr><td>E</td><td>get(int index)</td><td>返回位于该索引的元素</td></tr><tr><td>E</td><td>set(int index, E element)</td><td>将列表index位置的元素替换为element</td></tr><tr><td>E</td><td>add(int index, E element)</td><td>在列表index位置之后插入element，原先位置的元素索引往右移动一位</td></tr><tr><td>E</td><td>remove(int index)</td><td>删除列表index位置的元素，该位置后的元素向左移动一位</td></tr><tr><td>int</td><td>indexOf(Object o)</td><td>返回列表中从左往右首个匹配元素o的索引，如果列表中没有o，返回-1</td></tr><tr><td>int</td><td>lastIndexOf(Object o)</td><td>返回列表中从右往左首个匹配元素o的索引，如果列表中没有o，返回-1</td></tr><tr><td>ListIterato</td><td>listIterator()</td><td>返回该列表的迭代器</td></tr><tr><td>List</td><td>sublist(int fromIndex, int toIndex)</td><td>返回一个列表索引从from到to的视图，对该视图的所有操作本质上都是在操作原列表</td></tr></tbody></table><h2 id="queue"><a class="header-anchor" href="#queue"></a>Queue</h2><h3 id="职责-v4"><a class="header-anchor" href="#职责-v4"></a>职责</h3><h3 id="核心方法-v4"><a class="header-anchor" href="#核心方法-v4"></a>核心方法</h3><h1 id="字典类"><a class="header-anchor" href="#字典类"></a>字典类</h1><h2 id="map"><a class="header-anchor" href="#map"></a>Map</h2><h3 id="职责-v5"><a class="header-anchor" href="#职责-v5"></a>职责</h3><h3 id="核心方法-v5"><a class="header-anchor" href="#核心方法-v5"></a>核心方法</h3><h2 id="sortedmap"><a class="header-anchor" href="#sortedmap"></a>SortedMap</h2><h3 id="职责-v6"><a class="header-anchor" href="#职责-v6"></a>职责</h3><h3 id="核心方法-v6"><a class="header-anchor" href="#核心方法-v6"></a>核心方法</h3><h2 id="navigablemap"><a class="header-anchor" href="#navigablemap"></a>NavigableMap</h2><h3 id="职责-v7"><a class="header-anchor" href="#职责-v7"></a>职责</h3><h3 id="核心方法-v7"><a class="header-anchor" href="#核心方法-v7"></a>核心方法</h3>]]></content>
      
      
      <categories>
          
          <category> 源码剖析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java集合 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
