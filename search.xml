<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>一张图澄清架构设计模式</title>
      <link href="/2019/06/01/%E4%B8%80%E5%BC%A0%E5%9B%BE%E6%BE%84%E6%B8%85%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/06/01/%E4%B8%80%E5%BC%A0%E5%9B%BE%E6%BE%84%E6%B8%85%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/06/01/一张图澄清架构设计模式/%E4%B8%80%E5%BC%A0%E5%9B%BE%E6%BE%84%E6%B8%85%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.svg" alt="一张图澄清架构设计模式"></p>]]></content>
      
      
      <categories>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM入门</title>
      <link href="/2019/02/06/JVM%E5%85%A5%E9%97%A8/"/>
      <url>/2019/02/06/JVM%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="第一部分"><a class="header-anchor" href="#第一部分"></a>第一部分</h1><h2 id="自动内存管理"><a class="header-anchor" href="#自动内存管理"></a>自动内存管理</h2><h3 id="什么是内存管理？"><a class="header-anchor" href="#什么是内存管理？"></a>什么是内存管理？</h3><p>wiki对其定义如下：</p><blockquote><p><strong>内存管理</strong>是一种应用于<a href="https://en.wikipedia.org/wiki/Computer_memory" target="_blank" rel="noopener">计算机内存</a>的<a href="https://en.wikipedia.org/wiki/Resource_management_(computing)" target="_blank" rel="noopener">资源管理</a>。内存管理的基本要求是提供根据请求动态分配部分内存到程序的方法，并在不再需要时将其释放以供重用。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p></blockquote><p>通俗的讲，针对JVM平台，就是对Object的内存生命周期管理，包含创建Object时的内存申请和当该Object没有用时作为垃圾回收，释放内存。</p><p>我们分别用C和Java来举例说明：</p><p>Writting in C</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 申请内存</span></span><br><span class="line"><span class="keyword">int</span>* <span class="built_in">array</span> = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式的释放内存</span></span><br><span class="line"><span class="built_in">free</span>(<span class="built_in">array</span>);</span><br></pre></td></tr></table></figure><p>Writting in Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为一个字符串申请内存</span></span><br><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"Hello World"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不需要像C一样显式的释放内存</span></span><br><span class="line"><span class="comment">// JVM垃圾收集器会在适当的时候判定s为「Garbage」，然后会释放它</span></span><br></pre></td></tr></table></figure><p>那么JVM到底是如何管理Java内存的？</p><h2 id="hotspot-jvm垃圾收集分代和内存空间"><a class="header-anchor" href="#hotspot-jvm垃圾收集分代和内存空间"></a>HotSpot JVM垃圾收集分代和内存空间</h2><h2 id="hotspot-jvm垃圾收集器"><a class="header-anchor" href="#hotspot-jvm垃圾收集器"></a>HotSpot JVM垃圾收集器</h2><h2 id="java7-8-9中垃圾收集的改变"><a class="header-anchor" href="#java7-8-9中垃圾收集的改变"></a>Java7、8、9中垃圾收集的改变</h2><h1 id="第二部分"><a class="header-anchor" href="#第二部分"></a>第二部分</h1><h2 id="内存故障的症状"><a class="header-anchor" href="#内存故障的症状"></a>内存故障的症状</h2><h2 id="内存故障的原因"><a class="header-anchor" href="#内存故障的原因"></a>内存故障的原因</h2><h2 id="outofmemoryerror"><a class="header-anchor" href="#outofmemoryerror"></a>OutOfMemoryError</h2><h1 id="第三部分"><a class="header-anchor" href="#第三部分"></a>第三部分</h1><h2 id="java堆内存问题"><a class="header-anchor" href="#java堆内存问题"></a>Java堆内存问题</h2><h2 id="finalization导致的finalization"><a class="header-anchor" href="#finalization导致的finalization"></a>Finalization导致的Finalization</h2><h2 id="permgen-metaspace问题"><a class="header-anchor" href="#permgen-metaspace问题"></a>PermGen/Metaspace问题</h2><h2 id="codecache问题"><a class="header-anchor" href="#codecache问题"></a>CodeCache问题</h2><h2 id="native-memory问题"><a class="header-anchor" href="#native-memory问题"></a>Native Memory问题</h2><h1 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h1><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://en.wikipedia.org/wiki/Memory_management" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Memory_management</a> <a href="#fnref1" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 故障分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>调用模型</title>
      <link href="/2018/08/30/%E8%B0%83%E7%94%A8%E6%A8%A1%E5%9E%8B/"/>
      <url>/2018/08/30/%E8%B0%83%E7%94%A8%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>提示: 本文是<a href="http://houqian.xyz/2018/08/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/#%E7%AE%97%E6%B3%95%E4%BE%A7">模型部署方案</a>的一部分</p><h1 id="依赖"><a class="header-anchor" href="#依赖"></a>依赖</h1><ul><li>java8</li><li>pmml-evaluator 1.4.2</li><li>pmml-evaluator-extension 1.4.2</li></ul><h1 id="步骤"><a class="header-anchor" href="#步骤"></a>步骤</h1><ol><li><p>使用JPMML执行引擎反序列化pmml文件</p></li><li><p>模型校验（此处具体校验的问题，笔者以后另开一篇）</p></li></ol><a id="more"></a><h1 id="我们开始吧"><a class="header-anchor" href="#我们开始吧"></a>我们开始吧</h1><p>maven依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pmml-evaluator.version</span>&gt;</span>1.4.2<span class="tag">&lt;/<span class="name">pmml-evaluator.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--运行模型--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jpmml<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pmml-evaluator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;pmml-evaluator.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jpmml<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pmml-evaluator-extension<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;pmml-evaluator.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="一网打尽"><a class="header-anchor" href="#一网打尽"></a>一网打尽</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.houqian.jpmml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jpmml.evaluator.*;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.SAXException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.bind.JAXBException;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : houqian</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> : 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> : 2018-08-30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Execute</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JAXBException, SAXException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 从pmml文件实例化模型执行引擎</span></span><br><span class="line">    Evaluator evaluator = <span class="keyword">new</span> LoadingModelEvaluatorBuilder()</span><br><span class="line">            .setLocatable(<span class="keyword">false</span>)</span><br><span class="line">            .setVisitors(<span class="keyword">new</span> DefaultVisitorBattery())</span><br><span class="line">            <span class="comment">//.setOutputFilter(OutputFilters.KEEP_FINAL_RESULTS)</span></span><br><span class="line">            .load(<span class="keyword">new</span> File(<span class="string">"src/main/resources/pipeline.pmml.xml"</span>))</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验模型合法性</span></span><br><span class="line">    evaluator.verify();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入变量</span></span><br><span class="line">    List&lt;? extends InputField&gt; inputFields = evaluator.getInputFields();</span><br><span class="line">    System.out.println(<span class="string">"Input fields: "</span> + inputFields);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标签</span></span><br><span class="line">    List&lt;? extends TargetField&gt; targetFields = evaluator.getTargetFields();</span><br><span class="line">    System.out.println(<span class="string">"Target field(s): "</span> + targetFields);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出变量</span></span><br><span class="line">    List&lt;? extends OutputField&gt; outputFields = evaluator.getOutputFields();</span><br><span class="line">    System.out.println(<span class="string">"Output fields: "</span> + outputFields);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放引用，优化GC</span></span><br><span class="line">    evaluator = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deploy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>加载模型文件</title>
      <link href="/2018/08/30/%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B%E6%96%87%E4%BB%B6/"/>
      <url>/2018/08/30/%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>提示: 本文是<a href="http://houqian.xyz/2018/08/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/#%E7%AE%97%E6%B3%95%E4%BE%A7">模型部署方案</a>的一部分</p><h1 id="依赖"><a class="header-anchor" href="#依赖"></a>依赖</h1><ul><li>java8</li><li>pmml-model 1.4.2</li></ul><h1 id="步骤"><a class="header-anchor" href="#步骤"></a>步骤</h1><ol><li>加载反序列化模型文件为PMML对象</li><li>优化模型，并写到新模型文件</li></ol><a id="more"></a><h1 id="我们开始吧"><a class="header-anchor" href="#我们开始吧"></a>我们开始吧</h1><p>maven依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pmml-model.version</span>&gt;</span>1.4.2<span class="tag">&lt;/<span class="name">pmml-model.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--pmml模型--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jpmml<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pmml-model<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;pmml-model.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="加载模型-更新模型"><a class="header-anchor" href="#加载模型-更新模型"></a>加载模型 &amp; 更新模型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.houqian.jpmml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> org.dmg.pmml.PMML;</span><br><span class="line"><span class="keyword">import</span> org.jpmml.model.PMMLUtil;</span><br><span class="line"><span class="keyword">import</span> org.jpmml.model.visitors.LocatorNullifier;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.SAXException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.bind.JAXBException;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : houqian</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> : 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> : 2018-08-30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Load</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException, JAXBException, SAXException, JsonProcessingException </span>&#123;</span><br><span class="line">    <span class="comment">// 这里的pmml是之前sklearn、sparkml导出的文件，任选其一即可</span></span><br><span class="line">    FileInputStream srcModelIs = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"src/main/resources/pipeline.pmml.xml"</span>));</span><br><span class="line">    PMML pmml = PMMLUtil.unmarshal(srcModelIs);</span><br><span class="line"></span><br><span class="line">    optimize(pmml);</span><br><span class="line"></span><br><span class="line">    FileOutputStream newModelOs = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"src/main/resources/new-pipeline.pmml.xml"</span>));</span><br><span class="line">    store(pmml, newModelOs);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">optimize</span><span class="params">(PMML pmml)</span></span>&#123;</span><br><span class="line">    LocatorNullifier nullifier = <span class="keyword">new</span> LocatorNullifier();</span><br><span class="line">    nullifier.applyTo(pmml);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">store</span><span class="params">(PMML pmml, OutputStream os)</span> <span class="keyword">throws</span> JAXBException </span>&#123;</span><br><span class="line">    org.jpmml.model.PMMLUtil.marshal(pmml, os);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>笔者没有找到如何验证以上操作和模型正确性的关系，现在姑且先让它这样不报错跑通吧。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜  src git:(master) ✗ tree -L 3 </span><br><span class="line">.</span><br><span class="line">├── main</span><br><span class="line">│   ├── java</span><br><span class="line">│   │   ├── com</span><br><span class="line">│   │   └── org</span><br><span class="line">│   └── resources</span><br><span class="line">│       ├── application.properties</span><br><span class="line">│       ├── application.yml</span><br><span class="line">│       ├── import.sql</span><br><span class="line">│       ├── kafka</span><br><span class="line">│       ├── new-pipeline.pmml.xml   &lt;--生成的新模型文件</span><br><span class="line">│       └── pipeline.pmml.xml       &lt;--之前sklearn输出的模型文件</span><br><span class="line">└── test</span><br><span class="line">    └── java</span><br><span class="line">        └── org</span><br><span class="line"></span><br><span class="line">9 directories, 5 files</span><br></pre></td></tr></table></figure><h1 id="参考"><a class="header-anchor" href="#参考"></a>参考</h1><ol><li><a href="https://github.com/jpmml/jpmml-model" target="_blank" rel="noopener">https://github.com/jpmml/jpmml-model</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deploy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SparkML 导出 JPMML</title>
      <link href="/2018/08/30/sparkml%E5%AF%BC%E5%87%BAjpmml/"/>
      <url>/2018/08/30/sparkml%E5%AF%BC%E5%87%BAjpmml/</url>
      
        <content type="html"><![CDATA[<p>提示: 本文是<a href="http://houqian.xyz/2018/08/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/#%E7%AE%97%E6%B3%95%E4%BE%A7">模型部署方案</a>的一部分</p><h1 id="依赖"><a class="header-anchor" href="#依赖"></a>依赖</h1><ul><li>spark 2.2</li><li>jpmml-sparkml 1.3.8</li><li>scala 2.11</li></ul><h1 id="步骤"><a class="header-anchor" href="#步骤"></a>步骤</h1><ol><li>使用spark ml训练一个决策树模型</li><li>在控制台验证可以输出后，写到文件中</li></ol><a id="more"></a><h1 id="我们开始吧"><a class="header-anchor" href="#我们开始吧"></a>我们开始吧</h1><p>maven依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scala.version</span>&gt;</span>2.11.12<span class="tag">&lt;/<span class="name">scala.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scala.compat.version</span>&gt;</span>2.11<span class="tag">&lt;/<span class="name">scala.compat.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">spark-core.version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">spark-core.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">jpmml-sparkml.version</span>&gt;</span>1.3.8<span class="tag">&lt;/<span class="name">jpmml-sparkml.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--整合jpmml--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jpmml<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jpmml-sparkml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jpmml-sparkml.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--spark mllib--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-mllib_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spark-core.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--spark--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-core_$&#123;scala.compat.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spark-core.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-sql_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spark-core.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="模型训练-输出"><a class="header-anchor" href="#模型训练-输出"></a>模型训练 &amp; 输出</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.houqian.spark.jpmml</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.<span class="type">File</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.ml.classification.<span class="type">DecisionTreeClassifier</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.ml.feature.<span class="type">RFormula</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.ml.&#123;<span class="type">Pipeline</span>, <span class="type">PipelineStage</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">SparkSession</span></span><br><span class="line"><span class="keyword">import</span> org.jpmml.model.<span class="type">JAXBUtil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @author : houqian</span></span><br><span class="line"><span class="comment">  * @version : 1.0</span></span><br><span class="line"><span class="comment">  * @since : 2018-08-30</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Pipeline</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> spark = <span class="type">SparkSession</span></span><br><span class="line">      .builder</span><br><span class="line">      .appName(<span class="string">"Pipeline"</span>)</span><br><span class="line">      .master(<span class="string">"local[4]"</span>)</span><br><span class="line">      .getOrCreate()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载训练集</span></span><br><span class="line">    <span class="keyword">val</span> irisData = spark</span><br><span class="line">      .read</span><br><span class="line">      .format(<span class="string">"csv"</span>)</span><br><span class="line">      .option(<span class="string">"header"</span>, <span class="string">"true"</span>)</span><br><span class="line">      .load(<span class="string">"file:///Users/houqian/repo/github/data-notebook/src/main/resources/Iris.csv"</span>)</span><br><span class="line"></span><br><span class="line">    irisData.show()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 特征选择</span></span><br><span class="line">    <span class="keyword">val</span> formula = <span class="keyword">new</span> <span class="type">RFormula</span>().setFormula(<span class="string">"Species ~ ."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置决策树分类器</span></span><br><span class="line">    <span class="keyword">val</span> classifier = <span class="keyword">new</span> <span class="type">DecisionTreeClassifier</span>().setLabelCol(formula.getLabelCol).setFeaturesCol(formula.getFeaturesCol)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组合pipeline</span></span><br><span class="line">    <span class="keyword">val</span> pipeline = <span class="keyword">new</span> <span class="type">Pipeline</span>().setStages(<span class="type">Array</span>[<span class="type">PipelineStage</span>](formula, classifier))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 训练</span></span><br><span class="line">    <span class="keyword">val</span> pipelineModel = pipeline.fit(irisData)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> javax.xml.transform.stream.<span class="type">StreamResult</span></span><br><span class="line">    <span class="keyword">import</span> org.jpmml.sparkml.<span class="type">PMMLBuilder</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> schema = irisData.schema</span><br><span class="line">    <span class="keyword">val</span> pmml = <span class="keyword">new</span> <span class="type">PMMLBuilder</span>(schema, pipelineModel).build</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将pmml以流的形式输出到控制台</span></span><br><span class="line">    <span class="type">JAXBUtil</span>.marshalPMML(pmml, <span class="keyword">new</span> <span class="type">StreamResult</span>(<span class="type">System</span>.out))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将pmml写到文件</span></span><br><span class="line">    <span class="keyword">new</span> <span class="type">PMMLBuilder</span>(schema, pipelineModel).buildFile(<span class="keyword">new</span> <span class="type">File</span>(<span class="string">"/Users/houqian/repo/github/data-notebook/src/main/resources/pipeline.pmml"</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行，控制台输出：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">PMML</span> <span class="attr">xmlns</span>=<span class="string">"http://www.dmg.org/PMML-4_3"</span> <span class="attr">xmlns:data</span>=<span class="string">"http://jpmml.org/jpmml-model/InlineTable"</span> <span class="attr">version</span>=<span class="string">"4.3"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Header</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Application</span> <span class="attr">name</span>=<span class="string">"JPMML-SparkML"</span> <span class="attr">version</span>=<span class="string">"1.5.3"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Timestamp</span>&gt;</span>2018-08-30T14:03:52Z<span class="tag">&lt;/<span class="name">Timestamp</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">DataDictionary</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">DataField</span> <span class="attr">name</span>=<span class="string">"Species"</span> <span class="attr">optype</span>=<span class="string">"categorical"</span> <span class="attr">dataType</span>=<span class="string">"string"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"versicolor"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"virginica"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"setosa"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">DataField</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">DataField</span> <span class="attr">name</span>=<span class="string">"Petal_Width"</span> <span class="attr">optype</span>=<span class="string">"categorical"</span> <span class="attr">dataType</span>=<span class="string">"string"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"0.2"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"1.3"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"1.5"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"1.8"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"2.3"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"1.4"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"0.4"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"0.3"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"2.1"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"2"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"0.1"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"1.9"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"1.2"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"1.6"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"2.4"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"1.1"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"2.5"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"2.2"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"1.7"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"0.5"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Value</span> <span class="attr">value</span>=<span class="string">"0.6"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">DataField</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">DataDictionary</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TreeModel</span> <span class="attr">functionName</span>=<span class="string">"classification"</span> <span class="attr">missingValueStrategy</span>=<span class="string">"nullPrediction"</span> <span class="attr">splitCharacteristic</span>=<span class="string">"multiSplit"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">MiningSchema</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">MiningField</span> <span class="attr">name</span>=<span class="string">"Species"</span> <span class="attr">usageType</span>=<span class="string">"target"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">MiningField</span> <span class="attr">name</span>=<span class="string">"Petal_Width"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">MiningSchema</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Output</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">OutputField</span> <span class="attr">name</span>=<span class="string">"pmml(prediction)"</span> <span class="attr">optype</span>=<span class="string">"categorical"</span> <span class="attr">dataType</span>=<span class="string">"string"</span> <span class="attr">feature</span>=<span class="string">"predictedValue"</span> <span class="attr">isFinalResult</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">OutputField</span> <span class="attr">name</span>=<span class="string">"prediction"</span> <span class="attr">optype</span>=<span class="string">"categorical"</span> <span class="attr">dataType</span>=<span class="string">"double"</span> <span class="attr">feature</span>=<span class="string">"transformedValue"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">MapValues</span> <span class="attr">outputColumn</span>=<span class="string">"data:output"</span> <span class="attr">dataType</span>=<span class="string">"double"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">FieldColumnPair</span> <span class="attr">field</span>=<span class="string">"pmml(prediction)"</span> <span class="attr">column</span>=<span class="string">"data:input"</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">InlineTable</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">row</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">data:input</span>&gt;</span>versicolor<span class="tag">&lt;/<span class="name">data:input</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">data:output</span>&gt;</span>0<span class="tag">&lt;/<span class="name">data:output</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">row</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">row</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">data:input</span>&gt;</span>virginica<span class="tag">&lt;/<span class="name">data:input</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">data:output</span>&gt;</span>1<span class="tag">&lt;/<span class="name">data:output</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">row</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">row</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">data:input</span>&gt;</span>setosa<span class="tag">&lt;/<span class="name">data:input</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">data:output</span>&gt;</span>2<span class="tag">&lt;/<span class="name">data:output</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">row</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">InlineTable</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">MapValues</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">OutputField</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">OutputField</span> <span class="attr">name</span>=<span class="string">"probability(versicolor)"</span> <span class="attr">optype</span>=<span class="string">"continuous"</span> <span class="attr">dataType</span>=<span class="string">"double"</span> <span class="attr">feature</span>=<span class="string">"probability"</span> <span class="attr">value</span>=<span class="string">"versicolor"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">OutputField</span> <span class="attr">name</span>=<span class="string">"probability(virginica)"</span> <span class="attr">optype</span>=<span class="string">"continuous"</span> <span class="attr">dataType</span>=<span class="string">"double"</span> <span class="attr">feature</span>=<span class="string">"probability"</span> <span class="attr">value</span>=<span class="string">"virginica"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">OutputField</span> <span class="attr">name</span>=<span class="string">"probability(setosa)"</span> <span class="attr">optype</span>=<span class="string">"continuous"</span> <span class="attr">dataType</span>=<span class="string">"double"</span> <span class="attr">feature</span>=<span class="string">"probability"</span> <span class="attr">value</span>=<span class="string">"setosa"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Output</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Node</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">True</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Node</span> <span class="attr">score</span>=<span class="string">"setosa"</span> <span class="attr">recordCount</span>=<span class="string">"29"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">SimplePredicate</span> <span class="attr">field</span>=<span class="string">"Petal_Width"</span> <span class="attr">operator</span>=<span class="string">"equal"</span> <span class="attr">value</span>=<span class="string">"0.2"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ScoreDistribution</span> <span class="attr">value</span>=<span class="string">"versicolor"</span> <span class="attr">recordCount</span>=<span class="string">"0.0"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ScoreDistribution</span> <span class="attr">value</span>=<span class="string">"virginica"</span> <span class="attr">recordCount</span>=<span class="string">"0.0"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ScoreDistribution</span> <span class="attr">value</span>=<span class="string">"setosa"</span> <span class="attr">recordCount</span>=<span class="string">"29.0"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Node</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Node</span> <span class="attr">score</span>=<span class="string">"versicolor"</span> <span class="attr">recordCount</span>=<span class="string">"13"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">SimplePredicate</span> <span class="attr">field</span>=<span class="string">"Petal_Width"</span> <span class="attr">operator</span>=<span class="string">"equal"</span> <span class="attr">value</span>=<span class="string">"1.3"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ScoreDistribution</span> <span class="attr">value</span>=<span class="string">"versicolor"</span> <span class="attr">recordCount</span>=<span class="string">"13.0"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ScoreDistribution</span> <span class="attr">value</span>=<span class="string">"virginica"</span> <span class="attr">recordCount</span>=<span class="string">"0.0"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ScoreDistribution</span> <span class="attr">value</span>=<span class="string">"setosa"</span> <span class="attr">recordCount</span>=<span class="string">"0.0"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Node</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Node</span> <span class="attr">score</span>=<span class="string">"setosa"</span> <span class="attr">recordCount</span>=<span class="string">"7"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">SimplePredicate</span> <span class="attr">field</span>=<span class="string">"Petal_Width"</span> <span class="attr">operator</span>=<span class="string">"equal"</span> <span class="attr">value</span>=<span class="string">"0.4"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ScoreDistribution</span> <span class="attr">value</span>=<span class="string">"versicolor"</span> <span class="attr">recordCount</span>=<span class="string">"0.0"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ScoreDistribution</span> <span class="attr">value</span>=<span class="string">"virginica"</span> <span class="attr">recordCount</span>=<span class="string">"0.0"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ScoreDistribution</span> <span class="attr">value</span>=<span class="string">"setosa"</span> <span class="attr">recordCount</span>=<span class="string">"7.0"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Node</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Node</span> <span class="attr">score</span>=<span class="string">"setosa"</span> <span class="attr">recordCount</span>=<span class="string">"7"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">SimplePredicate</span> <span class="attr">field</span>=<span class="string">"Petal_Width"</span> <span class="attr">operator</span>=<span class="string">"equal"</span> <span class="attr">value</span>=<span class="string">"0.3"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ScoreDistribution</span> <span class="attr">value</span>=<span class="string">"versicolor"</span> <span class="attr">recordCount</span>=<span class="string">"0.0"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ScoreDistribution</span> <span class="attr">value</span>=<span class="string">"virginica"</span> <span class="attr">recordCount</span>=<span class="string">"0.0"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ScoreDistribution</span> <span class="attr">value</span>=<span class="string">"setosa"</span> <span class="attr">recordCount</span>=<span class="string">"7.0"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Node</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Node</span> <span class="attr">score</span>=<span class="string">"setosa"</span> <span class="attr">recordCount</span>=<span class="string">"5"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">SimplePredicate</span> <span class="attr">field</span>=<span class="string">"Petal_Width"</span> <span class="attr">operator</span>=<span class="string">"equal"</span> <span class="attr">value</span>=<span class="string">"0.1"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ScoreDistribution</span> <span class="attr">value</span>=<span class="string">"versicolor"</span> <span class="attr">recordCount</span>=<span class="string">"0.0"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ScoreDistribution</span> <span class="attr">value</span>=<span class="string">"virginica"</span> <span class="attr">recordCount</span>=<span class="string">"0.0"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ScoreDistribution</span> <span class="attr">value</span>=<span class="string">"setosa"</span> <span class="attr">recordCount</span>=<span class="string">"5.0"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Node</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Node</span> <span class="attr">score</span>=<span class="string">"virginica"</span> <span class="attr">recordCount</span>=<span class="string">"89"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">True</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ScoreDistribution</span> <span class="attr">value</span>=<span class="string">"versicolor"</span> <span class="attr">recordCount</span>=<span class="string">"37.0"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ScoreDistribution</span> <span class="attr">value</span>=<span class="string">"virginica"</span> <span class="attr">recordCount</span>=<span class="string">"50.0"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ScoreDistribution</span> <span class="attr">value</span>=<span class="string">"setosa"</span> <span class="attr">recordCount</span>=<span class="string">"2.0"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Node</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Node</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">TreeModel</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">PMML</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们成功生成的pmml文件：</p><p><img src="/2018/08/30/sparkml导出jpmml/image-20180830161456730.png" alt="image-20180830161456730.png"></p><h1 id="参考"><a class="header-anchor" href="#参考"></a>参考</h1><ol><li><p><a href="https://openscoring.io/blog/2018/07/09/converting_sparkml_pipeline_pmml/" target="_blank" rel="noopener">https://openscoring.io/blog/2018/07/09/converting_sparkml_pipeline_pmml/</a></p></li><li><p><a href="https://github.com/jpmml/jpmml-sparkml" target="_blank" rel="noopener">https://github.com/jpmml/jpmml-sparkml</a></p></li><li><p>用到的训练集Iris.csv：<a href="https://github.com/jpmml/jpmml-sparkml/blob/1.3.X/src/test/resources/csv/Iris.csv" target="_blank" rel="noopener">https://github.com/jpmml/jpmml-sparkml/blob/1.3.X/src/test/resources/csv/Iris.csv</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deploy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>scikit-learn 导出 JPMML</title>
      <link href="/2018/08/30/sklearn%E5%AF%BC%E5%87%BAjpmml/"/>
      <url>/2018/08/30/sklearn%E5%AF%BC%E5%87%BAjpmml/</url>
      
        <content type="html"><![CDATA[<p>提示: 本文是<a href="http://houqian.xyz/2018/08/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/#%E7%AE%97%E6%B3%95%E4%BE%A7">模型部署方案</a>的一部分</p><h1 id="依赖"><a class="header-anchor" href="#依赖"></a>依赖</h1><ul><li>Python 2.7, 3.4 or newer.</li><li><a href="https://pypi.python.org/pypi/scikit-learn" target="_blank" rel="noopener"><code>scikit-learn</code></a> 0.16.0 or newer.</li><li><a href="https://pypi.python.org/pypi/sklearn-pandas" target="_blank" rel="noopener"><code>sklearn-pandas</code></a> 0.0.10 or newer.</li><li><a href="https://github.com/jpmml/sklearn2pmml" target="_blank" rel="noopener"><code>sklearn2pmml</code></a> 0.14.0 or newer.</li></ul><h1 id="步骤"><a class="header-anchor" href="#步骤"></a>步骤</h1><ol><li>使用sklearn训练一个模型</li><li>使用sklearn原生API将模型到处为 <code>pickle</code> 格式</li><li>使用 JPMML-SkLearn命令将原始<code>pickle</code> 格式文件转换成JPMML文件</li></ol><a id="more"></a><h1 id="我们开始吧"><a class="header-anchor" href="#我们开始吧"></a>我们开始吧</h1><h2 id="训练模型-导出pickle"><a class="header-anchor" href="#训练模型-导出pickle"></a>训练模型 &amp; 导出pickle</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0. 使用pandas加载iris数据集</span></span><br><span class="line">df = pandas.read_csv(<span class="string">"file:./csv/Iris.csv"</span>)</span><br><span class="line"></span><br><span class="line">iris_X = df[df.columns.difference([<span class="string">"Species"</span>])]</span><br><span class="line">iris_y = df[<span class="string">"Species"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 创建一个sklearn_pandas.DataFrameMapper对象，它主要提供面向列的特征工程、标准化功能</span></span><br><span class="line"><span class="keyword">from</span> sklearn_pandas <span class="keyword">import</span> DataFrameMapper</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn2pmml.decoration <span class="keyword">import</span> ContinuousDomain</span><br><span class="line"></span><br><span class="line">column_preprocessor = DataFrameMapper([</span><br><span class="line">    ([<span class="string">"Sepal.Length"</span>, <span class="string">"Sepal.Width"</span>, <span class="string">"Petal.Length"</span>, <span class="string">"Petal.Width"</span>], [ContinuousDomain(), StandardScaler()])</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 创建一个Transformer和Selector对象，它主要提供面向表的特征工程、标准化功能</span></span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest</span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line"><span class="keyword">from</span> sklearn2pmml <span class="keyword">import</span> SelectorProxy</span><br><span class="line"></span><br><span class="line">table_preprocessor = Pipeline([</span><br><span class="line">(<span class="string">"pca"</span>, PCA(n_components = <span class="number">3</span>)),</span><br><span class="line">(<span class="string">"selector"</span>, SelectorProxy(SelectKBest(k = <span class="number">2</span>)))</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 创建一个Estimator对象</span></span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"></span><br><span class="line">classifier = DecisionTreeClassifier(min_samples_leaf = <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将上面的对象作为参数与sklearn2pmml.pipeline.PMMLPipeline对象组合起来，此时可以运行一下，看看能不能跑通</span></span><br><span class="line"><span class="keyword">from</span> sklearn2pmml.pipeline <span class="keyword">import</span> PMMLPipeline</span><br><span class="line"></span><br><span class="line">pipeline = PMMLPipeline([</span><br><span class="line">    (<span class="string">"columns"</span>, column_preprocessor),</span><br><span class="line">    (<span class="string">"table"</span>, table_preprocessor),</span><br><span class="line">    (<span class="string">"classifier"</span>, classifier)</span><br><span class="line">])</span><br><span class="line">pipeline.fit(iris_X, iris_y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 内置的模型验证功能</span></span><br><span class="line">pipeline.verify(iris_X.sample(n = <span class="number">15</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将拟合好的PMMLPipeline对象，用joblib导出为pickle格式的文件</span></span><br><span class="line"><span class="keyword">from</span> sklearn.externals <span class="keyword">import</span> joblib</span><br><span class="line"></span><br><span class="line">joblib.dump(pipeline, <span class="string">"pipeline.pkl.z"</span>, compress = <span class="number">9</span>)</span><br></pre></td></tr></table></figure><p>此时，我们得到了原始模型文件</p><p><img src="/2018/08/30/sklearn导出jpmml/image-20180830134051087.png" alt="image-20180830134051087.png"></p><h2 id="转换jpmml"><a class="header-anchor" href="#转换jpmml"></a>转换JPMML</h2><p>我们需要jpmml-sklearn的帮助，来转换原始模型文件。目前该子项目的最新版本为1.5.4，我们可以下载编译好的jar包，或者自己编译。</p><p><img src="/2018/08/30/sklearn导出jpmml/image-20180830134831357.png" alt="image-20180830134831357.png"></p><p>这里笔者选择自行编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/jpmml/jpmml-sklearn.git</span></span><br><span class="line">cd jpmml-sklearn &amp;&amp; mvn clean install -DskipTests</span><br></pre></td></tr></table></figure><p>讲我们上面得到的原始文件拷贝到jpmml-sklearn目录下, 执行:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar target/jpmml-sklearn-executable-<span class="number">1.5</span>-SNAPSHOT.jar --pkl-input pipeline.pkl.z --pmml-output pipeline.pmml</span><br></pre></td></tr></table></figure><p>我们成功的得到了pmml模型文件</p><p><img src="/2018/08/30/sklearn导出jpmml/image-20180830135636503.png" alt="image-20180830135636503.png"></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deploy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>机器学习模型部署方案</title>
      <link href="/2018/08/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/"/>
      <url>/2018/08/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a class="header-anchor" href="#背景"></a>背景</h1><p>目前，我们组反欺诈业务已经进行到了较为后期的阶段，初步有了基础的数据平台、计算平台。此时，算法同事也升级了过往基于统计分布的简单算法实现，而采用了更为强大的机器学习模型，目前已知的将会使用以下几类算法：离群点检测算法、树类算法等（笔者仅了解常见算法，描述不准确还望见谅。）</p><h1 id="问题"><a class="header-anchor" href="#问题"></a>问题</h1><p>算法同学日常使用sk-learn或者spark ml居多，其中前者使用python后者使用scala作为日常开发语言。笔者目前所做的属于算法工程化，需要对接线上实时数据流、离线数据实现对算法同学产出的模型的上线。</p><p>目前，已知的其他团队的方案有：</p><ol><li>使用python语言实现backend，并对接实时、离线数据</li><li>使用Java重新实现一遍算法逻辑，然后实现web api，并对接实时、离线数据</li></ol><p>分析一下这两种方案：</p><p>对于1，他们这么做的理由是算法同学自己的工程能力非常强，可以自己用python一站式搞定模型训练、上线，并且他们的业务离线居多，对实时性的要求不高。</p><p>对于2，他们这么做的理由是算法同学工程能力较弱，自己无法搞定一站式。使用线性模型比较多，后端Java同学实现起来还是比较简单的，性能也非常好。</p><p>然而，这两种方案目前看来都不能满足我们组的需求。</p><ul><li>我们的模型比较复杂，用Java实现一遍显的复杂性不可控，验证实现正确性的成本也很高。</li><li>主要是实时、数据量较少的场景，对实时性要求比较高（查询四五个数据源，加上模型逻辑，需要在1秒内给业务方返回）</li><li>希望做到模型的部署和训练接耦，算法同学和后端同学各自专注自己的事情</li></ul><a id="more"></a><h1 id="方案"><a class="header-anchor" href="#方案"></a>方案</h1><p>针对如上特征，笔者进行了调查。发现使用<code>模型训练</code>—&gt;<code>导出模型文件</code>—&gt;<code>服务端加载模型文件，对接数据源</code>这种模式比较适合我们。</p><p>目前业界使用的比较多的模型文件标准是PMML，以下是对该标准的简单描述：</p><blockquote><p>PMML 是一种事实标准语言，用于呈现数据挖掘模型。PMML 允许您在不同的应用程序之间轻松共享预测分析模型。因此，您可以在一个系统中定型一个模型，在 PMML 中对其进行表达，然后将其移动到另一个系统中。</p><p>PMML 是数据挖掘群组的产物，该群组是一个由供应商领导的委员会，由各种商业和开放源码分析公司组成。因此，现在的大部分领先数据挖掘工具都可以导出或导入 PMML。作为一个已发展 10 多年的成熟标准，PMML 既可以呈现用于从数据中了解模型的统计技术（如人工神经网络和决策树），也可以呈现原始输入数据的预处理以及模型输出的后处理。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p></blockquote><p>可以看到，PMML作为一个10几年的标准，在数据挖掘领域是很成熟的。笔者在Github也找到了该标准的Java实现<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。</p><p><img src="/2018/08/29/机器学习模型部署方案/image-20180829123430675.png" alt="image-20180829123430675.png"></p><p>可以看到其子项目分类非常清晰：</p><ul><li><p>jpmml-evaluatorjava加载jpmml格式文件API，这个也是我们服务端重点关注的</p></li><li><p>jpmml-modeljpmml文件对应的Java类</p></li><li><p>jpmml-sparkml与sparkml整合以导出jpmml文件</p></li><li><p>jpmml-sklearn</p><p>与sklearn整合以导出jpmml文件</p></li><li><p>jpmml-r</p></li><li><p>jpmml-xgboost</p></li></ul><p>如果使用这种方案，改动量：</p><ul><li>算法同学需要整合jpmml-sparkml、jpmml-sklearn</li><li>后端工程同学需要整合jpmml-evaluator、jpmml-model</li></ul><p>改动量还是比较大的，目前也主要是笔者自己进行相关的调研，接下来笔者尝试跑通<code>模型训练</code>—&gt;<code>导出模型文件</code>—&gt;<code>服务端加载模型文件，对接数据源</code>这个流程。</p><h1 id="实现"><a class="header-anchor" href="#实现"></a>实现</h1><h2 id="算法侧"><a class="header-anchor" href="#算法侧"></a>算法侧</h2><p><a href="http://houqian.xyz/2018/08/30/sklearn%E5%AF%BC%E5%87%BAjpmml/">sklearn导出jpmml</a></p><p><a href="http://houqian.xyz/2018/08/30/sklearn%E5%AF%BC%E5%87%BAjpmml/">sparkml导出jpmml</a></p><h2 id="工程侧"><a class="header-anchor" href="#工程侧"></a>工程侧</h2><p><a href="http://houqian.xyz/2018/08/30/%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B%E6%96%87%E4%BB%B6">加载模型文件</a></p><p><a href="http://houqian.xyz/2018/08/30/%E8%B0%83%E7%94%A8%E6%A8%A1%E5%9E%8B">调用模型</a></p><h1 id="总结"><a class="header-anchor" href="#总结"></a>总结</h1><h2 id="该方案的优势"><a class="header-anchor" href="#该方案的优势"></a>该方案的优势</h2><ul><li>解耦使用PMML作为中间层，解耦了模型训练、部署这两个环节，使得算法同学专注效果、后端同学专注性能</li><li>成熟度很高已经有10几年的历史</li></ul><h2 id="该方案的缺点"><a class="header-anchor" href="#该方案的缺点"></a>该方案的缺点</h2><ul><li><p>故障追踪相对困难</p><p>增加了一层模型文件，引入了几个子项目，出了问题定位起来相对以前要难上一些。不过，如果满足我们的需求，相信随着对源码的逐步掌握，我们可以在关键节点做埋点日志，结合已有的tracing系统，这个问题也不大</p></li></ul><h2 id="心得"><a class="header-anchor" href="#心得"></a>心得</h2><p>这次总共花了1天多的时间研究更好的模型上线方案，初步确定了JPMML这一生成中间文件的方案。目前，已经跑通了从算法模型训练（覆盖sklearn、spark ml的jpmml文件输出）到使用jpmml模型文件部署的整个流程。</p><p>过程中还算比较顺利，github上的文档虽少但足够精炼，已经覆盖了主要流程。但并没有覆盖到算法同学的复杂模型case，因此还需要和算法同学细化使用场景。</p><p>如果该方案最终被采用，笔者会撰写更为深入的源码分析系列文章。</p><p><strong>Reference</strong></p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>何为PMML？<a href="https://www.ibm.com/developerworks/cn/opensource/ind-PMML1/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/opensource/ind-PMML1/index.html</a> <a href="#fnref1" class="footnote-backref">↩</a></p></li><li id="fn2" class="footnote-item"><p>Jpmml Github <a href="https://github.com/jpmml" target="_blank" rel="noopener">https://github.com/jpmml</a> <a href="#fnref2" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deploy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>监控调研</title>
      <link href="/2017/08/29/%E7%9B%91%E6%8E%A7%E8%B0%83%E7%A0%94/"/>
      <url>/2017/08/29/%E7%9B%91%E6%8E%A7%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a class="header-anchor" href="#背景"></a>背景</h3><p>性能压测后，逐个埋点添加各种StopWatch。</p><p><strong>两个缺点：</strong></p><ol><li>侵入了业务逻辑，降低可读性</li><li>耗时，工作量大</li></ol><p><strong>期望：</strong></p><ol><li>【注解】 基于配置或注解可以精确控制要添加性能监控的method或class</li><li>【指标维度全面】监控指标全面，除了常见的QPS、Req Cost Time，还要有TPS, P90, P95 ,P99等指标</li><li>【可视化】最好有图形化的界面可以实时看到各个method的性能状况</li></ol><a id="more"></a><h3 id="方案调研"><a class="header-anchor" href="#方案调研"></a>方案调研</h3><ol><li>商业OneAPM、NewRelic等基于java agent实现无侵入监控性能指标。</li><li>开源【一站式】open-tracing【定制化】metrics + aop + AMQP中间件 + <a href="https://www.influxdata.com/" target="_blank" rel="noopener">InfluxDB</a> + <a href="https://grafana.com/" target="_blank" rel="noopener">Grafana</a></li></ol><p>分析</p><p>根据目前的需求，需要灵活的定制化监控项，可控的监控数据流，因此原则定制化开源项。</p><h3 id="方案细节"><a class="header-anchor" href="#方案细节"></a>方案细节</h3><ol><li><h4 id="组件调研"><a class="header-anchor" href="#组件调研"></a>组件调研</h4><h5 id="监控指标采集"><a class="header-anchor" href="#监控指标采集"></a>监控指标采集</h5><ul><li><a href="evernote:///view/476088119/s5/95bcac4c-8c7e-4a74-8b86-7a2b7f6a43d9/95bcac4c-8c7e-4a74-8b86-7a2b7f6a43d9/" target="_blank" rel="noopener">Metrics</a></li><li>AOP</li></ul><h5 id="指标数据传输"><a class="header-anchor" href="#指标数据传输"></a>指标数据传输</h5><ul><li>AMQP选型</li></ul><h5 id="指标数据落地"><a class="header-anchor" href="#指标数据落地"></a>指标数据落地</h5><ul><li><p>时间序列数据库</p><p>InfluxDB</p></li></ul><h5 id="指标数据展示"><a class="header-anchor" href="#指标数据展示"></a>指标数据展示</h5><ul><li>Grafana</li></ul></li><li><h4 id="方案打通"><a class="header-anchor" href="#方案打通"></a>方案打通</h4></li><li><h4 id="测试上线"><a class="header-anchor" href="#测试上线"></a>测试上线</h4></li></ol><p><strong>Reference</strong></p><ol><li><a href="http://www.jianshu.com/p/e4f70ddbc287" target="_blank" rel="noopener">Metrics —— JVM上的实时监控类库</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> APM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java性能监控 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Shell编程实战总结</title>
      <link href="/2017/08/25/shell%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
      <url>/2017/08/25/shell%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h4 id="linux显示彩色字体"><a class="header-anchor" href="#linux显示彩色字体"></a>Linux显示彩色字体</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">echo -e "\033[30m 黑色字 \033[0m"</span><br><span class="line">echo -e "\033[31m 红色字 \033[0m"</span><br><span class="line">echo -e "\033[32m 绿色字 \033[0m"</span><br><span class="line">echo -e "\033[33m 黄色字 \033[0m"</span><br><span class="line">echo -e "\033[34m 蓝色字 \033[0m"</span><br><span class="line">echo -e "\033[35m 紫色字 \033[0m"</span><br><span class="line">echo -e "\033[36m 天蓝字 \033[0m"</span><br><span class="line">echo -e "\033[37m 白色字 \033[0m"</span><br><span class="line"> </span><br><span class="line">echo -e "\033[40;37m 黑底白字 \033[0m"</span><br><span class="line">echo -e "\033[41;37m 红底白字 \033[0m"</span><br><span class="line">echo -e "\033[42;37m 绿底白字 \033[0m"</span><br><span class="line">echo -e "\033[43;37m 黄底白字 \033[0m"</span><br><span class="line">echo -e "\033[44;37m 蓝底白字 \033[0m"</span><br><span class="line">echo -e "\033[45;37m 紫底白字 \033[0m"</span><br><span class="line">echo -e "\033[46;37m 天蓝底白字 \033[0m"</span><br><span class="line">echo -e "\033[47;30m 白底黑字 \033[0m"</span><br></pre></td></tr></table></figure><h4 id="隔一秒检查mysql在执行的dml语句"><a class="header-anchor" href="#隔一秒检查mysql在执行的dml语句"></a>隔一秒检查MySQL在执行的DML语句</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span> </span><br><span class="line">  sudo mysql --default-character-set=utf8 -h <span class="variable">$&#123;hostname&#125;</span> -P 3306  -u<span class="variable">$&#123;username&#125;</span>  -p<span class="variable">$&#123;password&#125;</span> -e <span class="string">"show processlist"</span> | grep Query; </span><br><span class="line">sleep 1; </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h4 id="以逗号分隔每一行-取第一列"><a class="header-anchor" href="#以逗号分隔每一行-取第一列"></a>以逗号分隔每一行，取第一列</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F, <span class="string">'&#123;print $1&#125;'</span> doufen_uid_name</span><br></pre></td></tr></table></figure><h4 id="批量行首添加字符串"><a class="header-anchor" href="#批量行首添加字符串"></a>批量行首添加字符串</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以后研究下列模式能否实现</span></span><br><span class="line">vim mode下 </span><br><span class="line">:%s/^/del user_item__/g</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="查看jar包内容"><a class="header-anchor" href="#查看jar包内容"></a>查看jar包内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar -tf xxxx.jar</span><br></pre></td></tr></table></figure><h4 id="统计一个文件的行数"><a class="header-anchor" href="#统计一个文件的行数"></a>统计一个文件的行数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法1：先用wc -l算出行数，awk取第一个字段</span></span><br><span class="line">wc -l filename | awk <span class="string">'&#123;print $1&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2：巧用END函数和内置变量NR直接输出行数</span></span><br><span class="line"><span class="comment"># NR变量可以输出当前行号，END函数是awk读取完文件之后执行的操作</span></span><br><span class="line">awk <span class="string">'END&#123;pint NR&#125;'</span> filename</span><br></pre></td></tr></table></figure><h4 id="如何获取当前脚本的名称？当前路径文件的名称？"><a class="header-anchor" href="#如何获取当前脚本的名称？当前路径文件的名称？"></a>如何获取当前脚本的名称？当前路径文件的名称？</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># shell script</span></span><br><span class="line">basename <span class="variable">$0</span></span><br></pre></td></tr></table></figure><h4 id="linux下的进程管理"><a class="header-anchor" href="#linux下的进程管理"></a>Linux下的进程管理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. bg,fg,&amp;,ctrl+c, ctrl+z, jobs</span></span><br><span class="line"><span class="comment"># 查看后台进程任务</span></span><br><span class="line"><span class="built_in">bg</span></span><br><span class="line"><span class="comment"># 将一个后台任务唤醒start并切到前台</span></span><br><span class="line"><span class="built_in">fg</span></span><br><span class="line"><span class="comment"># 将一个任务转为daemon进程在后台运行</span></span><br><span class="line">&amp;</span><br><span class="line"><span class="comment"># 停止当前正在运行的进程</span></span><br><span class="line">ctrl+c</span><br><span class="line"><span class="comment"># 将当前进程放到后天并挂起[stop]</span></span><br><span class="line">ctrl+z</span><br><span class="line"><span class="comment"># 查看当前用户下的所有后台任务</span></span><br><span class="line"><span class="built_in">jobs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 工作流实践</span></span><br><span class="line"><span class="comment"># 1.vim 打开一个log文件</span></span><br><span class="line"><span class="comment"># 2.ctrl + z在后台挂起</span></span><br><span class="line"><span class="comment"># 3.jobs</span></span><br><span class="line"><span class="comment"># 4.fg + 编号唤醒相应的进程</span></span><br></pre></td></tr></table></figure><h4 id="实时的监控网卡流量"><a class="header-anchor" href="#实时的监控网卡流量"></a>实时的监控网卡流量</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptraf</span><br></pre></td></tr></table></figure><p><img src="/2017/08/25/shell编程实战/iptraf01.png" alt="iptraf01"></p><p><img src="/2017/08/25/shell编程实战/iptraf02.png" alt="iptraf02"></p><p><a href="http://www.ttlsa.com/linux-command/ss-replace-netstat/" target="_blank" rel="noopener">网络状态工具SS</a></p><h4 id="取出中括号内的内容"><a class="header-anchor" href="#取出中括号内的内容"></a>取出中括号内的内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 123[321]123 | cut -d <span class="string">"["</span> -f2 | cut -d <span class="string">"]"</span> -f1</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">321</span><br><span class="line"></span><br><span class="line"><span class="comment"># cut语法理解：</span></span><br><span class="line">cut -d 会根据指定的分隔符切分字符串（或者从文件中读取），-f&#123;<span class="variable">$num</span>&#125;的num是按照该分隔符分割后取哪一块内容（也就是分割后是一个字符串数组，你可以根据下标获取期望的子串，只不过该数组下标从）</span><br></pre></td></tr></table></figure><h4 id="使用vim去除段落内行尾的空格与tab"><a class="header-anchor" href="#使用vim去除段落内行尾的空格与tab"></a>使用VIM去除段落内行尾的空格与tab</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s<span class="comment">#\s\+$##</span></span><br></pre></td></tr></table></figure><h4 id="过滤并高亮"><a class="header-anchor" href="#过滤并高亮"></a>过滤并高亮</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep --color -C30 <span class="string">'RESPONSE'</span> test.log</span><br></pre></td></tr></table></figure><p><img src="/2017/08/25/shell编程实战/%E8%BF%87%E6%BB%A4%E5%B9%B6%E9%AB%98%E4%BA%AE.png" alt="过滤并高亮"></p><h4 id="osx下利用xargs传参"><a class="header-anchor" href="#osx下利用xargs传参"></a>osx下利用xargs传参</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls | grep json |grep -v <span class="string">'('</span> |  xargs -I  % cp % <span class="built_in">test</span>/</span><br><span class="line"><span class="comment"># %%内包起来要执行的命令即可，不需要&#123;&#125;占位符</span></span><br><span class="line"><span class="comment"># 注意：OSX的xargs与Linux不同</span></span><br></pre></td></tr></table></figure><h4 id="查看系统中的内存占用"><a class="header-anchor" href="#查看系统中的内存占用"></a>查看系统中的内存占用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -A --sort -rss -o pid,comm,pmem,rss | less</span><br></pre></td></tr></table></figure><h4 id="查看进程打开的文件句柄数"><a class="header-anchor" href="#查看进程打开的文件句柄数"></a>查看进程打开的文件句柄数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> $(pidof java); <span class="keyword">do</span> <span class="built_in">echo</span> <span class="string">"PID # <span class="variable">$p</span> has <span class="variable">$(lsof -n -a -p $p|wc -l)</span> fd opened."</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure><h4 id="linux根据pid查找执行路径及其他详情"><a class="header-anchor" href="#linux根据pid查找执行路径及其他详情"></a>Linux根据PID查找执行路径及其他详情</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll /proc/PID</span><br></pre></td></tr></table></figure><p><img src="/2017/08/25/shell编程实战/Linux%E6%A0%B9%E6%8D%AEPID%E6%9F%A5%E6%89%BE%E6%89%A7%E8%A1%8C%E8%B7%AF%E5%BE%84%E5%8F%8A%E5%85%B6%E4%BB%96%E8%AF%A6%E6%83%85.png" alt="Linux根据PID查找执行路径及其他详情"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AQS论文翻译</title>
      <link href="/2017/08/04/AQS%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/"/>
      <url>/2017/08/04/AQS%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a class="header-anchor" href="#背景"></a>背景</h1><p>最近对并发底层实现比较有兴趣，正巧看到这篇译文不错，这里记录一下<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p><a id="more"></a><h1 id="摘要"><a class="header-anchor" href="#摘要"></a>摘要</h1><p>在J2SE 1.5的java.util.concurrent包（下称j.u.c包）中，大部分的同步器（例如锁，屏障等等）都是基于AbstractQueuedSynchronizer类（下称AQS类），这个简单的框架而构建的。这个框架为同步状态的原子性管理、线程的阻塞和解除阻塞以及排队提供了一种通用的机制。这篇论文主要描述了这个框架基本原理、设计、实现、用法以及性能。</p><h2 id="1-背景介绍"><a class="header-anchor" href="#1-背景介绍"></a>1. 背景介绍</h2><p>通过JCP的JSR166规范，Java的1.5版本引入了j.u.c包，这个包提供了一系列支持中等程度并发的类。这些组件是一系列的同步器（抽象数据类型(ADT)）。这些同步器主要维护着以下几个功能：内部同步状态的管理(例如：表示一个锁的状态是获取还是释放)，同步状态的更新和检查操作，且至少有一个方法会导致调用线程在同步状态被获取时阻塞，以及在其他线程改变这个同步状态时解除线程的阻塞。上述的这些的实际例子包括：互斥排它锁的不同形式、读写锁、信号量、屏障、Future、事件指示器以及传送队列等。</p><p>几乎任一同步器都可以用来实现其他形式的同步器。例如，可以用可重入锁实现信号量或者用信号量实现可重入锁。但是，这样做带来的复杂性，开销，不灵活使其至多只能是个二流工程。且缺乏吸引力。如果任何这样的构造方式不能在本质上比其他形式更简洁，那么开发者就不应该随意地选择其中的某个来构建另一个同步器。取而代之，JSR166建立了一个小框架，AQS类。这个框架为构造同步器提供一种通用的机制，并且被j.u.c包中大部分类使用，同时很多用户也用它来定义自己的同步器。</p><p>在这篇论文的下面部分会讨论这个框架的需求、设计与实现背后的主要思路、示例用法，以及性能指标的一些测量。</p><h1 id="2-需求"><a class="header-anchor" href="#2-需求"></a>2. 需求</h1><h2 id="2-1-功能"><a class="header-anchor" href="#2-1-功能"></a>2.1 功能</h2><p>同步器一般包含两种方法，一种是acquire，另一种是release。acquire操作阻塞调用的线程，直到或除非同步状态允许其继续执行。而release操作则是通过某种方式改变同步状态，使得一或多个被acquire阻塞的线程继续执行。</p><p>j.u.c包中并没有对同步器的API做一个统一的定义。因此，有一些类定义了通用的接口（如Lock），而另外一些则定义了其专有的版本。因此在不同的类中，acquire和release操作的名字和形式会各有不同。例如：Lock.lock，Semaphore.acquire，CountDownLatch.await和FutureTask.get，在这个框架里，这些方法都是acquire操作。但是，J.U.C为支持一系列常见的使用选项，在类间都有个一致约定。在有意义的情况下，每一个同步器都支持下面的操作：</p><ul><li>阻塞和非阻塞（例如tryLock）同步。</li><li>可选的超时设置，让调用者可以放弃等待</li><li>通过中断实现的任务取消，通常是分为两个版本，一个acquire可取消，而另一个不可以。</li></ul><p>同步器的实现根据其状态是否独占而有所不同。独占状态的同步器，在同一时间只有一个线程可以通过阻塞点，而共享状态的同步器可以同时有多个线程在执行。一般锁的实现类往往只维护独占状态，但是，例如计数信号量在数量许可的情况下，允许多个线程同时执行。为了使框架能得到广泛应用，这两种模式都要支持。</p><p>j.u.c包里还定义了Condition接口，用于支持监控形式的await/signal操作，这些操作与独占模式的Lock类有关，且Condition的实现天生就和与其关联的Lock类紧密相关。</p><h2 id="2-2-性能目标"><a class="header-anchor" href="#2-2-性能目标"></a>2.2 性能目标</h2><p>Java内置锁（使用synchronized的方法或代码块）的性能问题一直以来都在被人们关注，并且已经有一系列的文章描述其构造（例如引文[1],[3]）。然而，大部分的研究主要关注的是在单核处理器上大部分时候使用于单线程上下文环境中时，如何尽量降低其空间（因为任何的Java对象都可以当成是锁）和时间的开销。对于同步器来说这些都不是特别重要：程序员仅在需要的时候才会使用同步器，因此并不需要压缩空间来避免浪费，并且同步器几乎是专门用在多线程设计中（特别是在多核处理器上），在这种环境下，偶尔的竞争是在意料之中的。因此，常规的JVM锁优化策略主要是针对零竞争的场景，而其它场景则使用缺乏可预见性的“慢速路径（slow paths）” ，所以常规的JVM锁优化策略并不适用于严重依赖于J.U.C包的典型多线程服务端应用。</p><p>这里主要的性能目标是可伸缩性，即在大部分情况下，即使，或特别在同步器有竞争的情况下，稳定地保证其效率。在理想的情况下，不管有多少线程正试图通过同步点，通过同步点的开销都应该是个常量。在某一线程被允许通过同步点但还没有通过的情况下，使其耗费的总时间最少，这是主要目标之一。然而，这也必须考虑平衡各种资源，包括总CPU时间的需求，内存负载以及线程调度的开销。例如：获取自旋锁通常比阻塞锁所需的时间更短，但是通常也会浪费CPU时钟周期，并且造成内存竞争，所以使用的并不频繁。</p><p>实现同步器的这些目标包含了两种不同的使用类型。大部分应用程序是最大化其总的吞吐量，容错性，并且最好保证尽量减少饥饿的情况。然而，对于那些控制资源分配的程序来说，更重要是去维持多线程读取的公平性，可以接受较差的总吞吐量。没有任何框架可以代表用户去决定应该选择哪一个方式，因此，应该提供不同的公平策略。</p><p>无论同步器的内部实现是多么的精雕细琢，它还是会在某些应用中产生性能瓶颈。因此，框架必须提供相应的监视工具让用户发现和缓和这些瓶颈。至少需要提供一种方式来确定有多少线程被阻塞了。</p><h1 id="3-设计与实现"><a class="header-anchor" href="#3-设计与实现"></a>3. 设计与实现</h1><p>同步器背后的基本思想非常简单。acquire操作如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (同步状态不允许获取) &#123;</span><br><span class="line">如果尚未排队,则将当前线程排入队列;</span><br><span class="line">可能阻塞当前线程;</span><br><span class="line">&#125;</span><br><span class="line">如果当前线程在排队则将其取消;</span><br></pre></td></tr></table></figure><p>release操作如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">更新同步状态;</span><br><span class="line"><span class="keyword">if</span> (状态允许阻塞线程获取)</span><br><span class="line">解锁一个或者多个已经入队的线程;</span><br></pre></td></tr></table></figure><p>为了实现上述操作，需要下面三个基本组件的相互协作：</p><ul><li>同步状态的原子性管理；</li><li>线程的阻塞与解除阻塞；</li><li>队列的管理；</li></ul><p>创建一个框架分别实现这三个组件是有可能的。但是，这会让整个框架既难用又没效率。例如：存储在队列节点的信息必须与解除阻塞所需要的信息一致，而暴露出的方法的签名必须依赖于同步状态的特性。</p><p>同步器框架的核心决策是为这三个组件选择一个具体实现，同时在使用方式上又有大量选项可用。这里有意地限制了其适用范围，但是提供了足够的效率，使得实际上没有理由在合适的情况下不用这个框架而去重新建造一个。</p><h2 id="3-1-同步状态"><a class="header-anchor" href="#3-1-同步状态"></a>3.1 同步状态</h2><p>AQS类使用单个<code>int</code>（32位）来保存同步状态，并暴露出<code>getState</code>、<code>setState</code>以及<code>compareAndSet</code>操作来读取和更新这个状态。这些方法都依赖于j.u.c.atomic包的支持，这个包提供了兼容JSR133中<code>volatile</code>在读和写上的语义，并且通过使用本地的compare-and-swap或load-linked/store-conditional指令来实现<code>compareAndSetState</code>，使得仅当同步状态拥有一个期望值的时候，才会被原子地设置成新值。</p><p>将同步状态限制为一个32位的整形是出于实践上的考量。虽然JSR166也提供了64位<code>long</code>字段的原子性操作，但这些操作在很多平台上还是使用内部锁的方式来模拟实现的，这会使同步器的性能可能不会很理想。当然，将来可能会有一个类是专门使用64位的状态的。然而现在就引入这么一个类到这个包里并不是一个很好的决定（<em>译者注：JDK1.6中已经包含java.util.concurrent.locks.AbstractQueuedLongSynchronizer类，即使用 long 形式维护同步状态的一个 AbstractQueuedSynchronizer 版本</em>）。目前来说，32位的状态对大多数应用程序都是足够的。在j.u.c包中，只有一个同步器类可能需要多于32位来维持状态，那就是<code>CyclicBarrier</code>类，所以，它用了锁（该包中大多数更高层次的工具亦是如此）。</p><p>基于AQS的具体实现类必须根据暴露出的状态相关的方法定义<code>tryAcquire</code>和<code>tryRelease</code>方法，以控制acquire和release操作。当同步状态满足时，<code>tryAcquire</code>方法必须返回<code>true</code>，而当新的同步状态允许后续acquire时，<code>tryRelease</code>方法也必须返回<code>true</code>。这些方法都接受一个<code>int</code>类型的参数用于传递想要的状态。例如：可重入锁中，当某个线程从条件等待中返回，然后重新获取锁时，为了重新建立循环计数的场景。很多同步器并不需要这样一个参数，因此忽略它即可。</p><h2 id="3-2-阻塞"><a class="header-anchor" href="#3-2-阻塞"></a>3.2 阻塞</h2><p>在JSR166之前，阻塞线程和解除线程阻塞都是基于Java内置监视器，没有基于Java API可以用来创建同步器。唯一可以选择的是<code>Thread.suspend</code>和<code>Thread.resume</code>，但是它们都有无法解决的竞态问题，所以也没法用：当一个非阻塞的线程在一个正准备阻塞的线程调用<code>suspend</code>前调用了<code>resume</code>，这个<code>resume</code>操作将不会有什么效果。</p><p>j.u.c包有一个<code>LockSuport</code>类，这个类中包含了解决这个问题的方法。方法<code>LockSupport.park</code>阻塞当前线程除非/直到有个<code>LockSupport.unpark</code>方法被调用（<code>unpark</code>方法被提前调用也是可以的）。<code>unpark</code>的调用是没有被计数的，因此在一个<code>park</code>调用前多次调用<code>unpark</code>方法只会解除一个<code>park</code>操作。另外，它们作用于每个线程而不是每个同步器。一个线程在一个新的同步器上调用park操作可能会立即返回，因为在此之前可能有“剩余的”<code>unpark</code>操作。但是，在缺少一个<code>unpark</code>操作时，下一次调用park就会阻塞。虽然可以显式地消除这个状态（<em>译者注：就是多余的unpark调用</em>），但并不值得这样做。在需要的时候多次调用<code>park</code>会更高效。</p><p>这个简单的机制与有些用法在某种程度上是相似的，例如Solaris-9的线程库，WIN32中的“可消费事件”，以及Linux中的NPTL线程库。因此最常见的运行Java的平台上都有相对应的有效实现。（但目前Solaris和Linux上的Sun Hotspot JVM参考实现实际上是使用一个pthread的condvar来适应目前的运行时设计的）。<code>park</code>方法同样支持可选的相对或绝对的超时设置，以及与JVM的<code>Thread.interrupt</code>结合 —— 可通过中断来<code>unpark</code>一个线程。</p><h2 id="3-3-队列"><a class="header-anchor" href="#3-3-队列"></a>3.3 队列</h2><p>整个框架的关键就是如何管理被阻塞的线程的队列，该队列是严格的FIFO队列，因此，框架不支持基于优先级的同步。</p><p>同步队列的最佳选择是自身没有使用底层锁来构造的非阻塞数据结构，目前，业界对此很少有争议。而其中主要有两个选择：一个是Mellor-Crummey和Scott锁（MCS锁）<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup><sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup><sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>的变体。一直以来，CLH锁仅被用于自旋锁。但是，在这个框架中，CLH锁显然比MCS锁更合适。因为CLH锁可以更容易地去实现“取消（cancellation）”和“超时”功能，因此我们选择了CLH锁作为实现的基础。但是最终的设计已经与原来的CLH锁有较大的出入，因此下文将对此做出解释。</p><p>CLH队列实际上并不那么像队列，因为它的入队和出队操作都与它的用途（即用作锁）紧密相关。它是一个链表队列，通过两个字段<code>head</code>和<code>tail</code>来存取，这两个字段是可原子更新的，两者在初始化时都指向了一个空节点。</p><p><img src="/2017/08/04/AQS论文翻译/CLHNode-20190522123101755.png" alt="324242343"></p><p>一个新的节点，node，通过一个原子操作入队：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123; </span><br><span class="line">    pred = tail;</span><br><span class="line">&#125; <span class="keyword">while</span>(!tail.compareAndSet(pred, node));</span><br></pre></td></tr></table></figure><p>每一个节点的“释放”状态都保存在其前驱节点中。因此，自旋锁的“自旋”操作就如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (pred.status != RELEASED) ; <span class="comment">// spin</span></span><br></pre></td></tr></table></figure><p>自旋后的出队操作只需将head字段指向刚刚得到锁的节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head = node;</span><br></pre></td></tr></table></figure><p>CLH锁的优点在于其入队和出队操作是快速、无锁的，以及无障碍的（即使在竞争下，某个线程总会赢得一次插入机会而能继续执行）；且探测是否有线程正在等待也很快（只要测试一下head是否与tail相等）；同时，“释放”状态是分散的（<em>译者注：几乎每个节点都保存了这个状态，当前节点保存了其后驱节点的“释放”状态，因此它们是分散的，不是集中于一块的。</em>），避免了一些不必要的内存竞争。</p><p>在原始版本的CLH锁中，节点间甚至都没有互相链接。自旋锁中，<code>pred</code>变量可以是一个局部变量。然而，Scott和Scherer证明了通过在节点中显式地维护前驱节点，CLH锁就可以处理“超时”和各种形式的“取消”：如果一个节点的前驱节点取消了，这个节点就可以滑动去使用前面一个节点的状态字段。</p><p>为了将CLH队列用于阻塞式同步器，需要做些额外的修改以提供一种高效的方式定位某个节点的后继节点。在自旋锁中，一个节点只需要改变其状态，下一次自旋中其后继节点就能注意到这个改变，所以节点间的链接并不是必须的。但在阻塞式同步器中，一个节点需要显式地唤醒（<code>unpark</code>）其后继节点。</p><p>AQS队列的节点包含一个<code>next</code>链接到它的后继节点。但是，由于没有针对双向链表节点的类似<code>compareAndSet</code>的原子性无锁插入指令，因此这个<code>next</code>链接的设置并非作为原子性插入操作的一部分，而仅是在节点被插入后简单地赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pred.next = node;</span><br></pre></td></tr></table></figure><p><code>next</code>链接仅是一种优化。如果通过某个节点的<code>next</code>字段发现其后继结点不存在（或看似被取消了），总是可以使用<code>pred</code>字段从尾部开始向前遍历来检查是否真的有后续节点。</p><p>第二个对CLH队列主要的修改是将每个节点都有的状态字段用于控制阻塞而非自旋。在同步器框架中，仅在线程调用具体子类中的<code>tryAcquire</code>方法返回<code>true</code>时，队列中的线程才能从<code>acquire</code>操作中返回；而单个“released”位是不够的。但仍然需要做些控制以确保当一个活动的线程位于队列头部时，仅允许其调用<code>tryAcquire</code>；这时的<code>acquire</code>可能会失败，然后（重新）阻塞。这种情况不需要读取状态标识，因为可以通过检查当前节点的前驱是否为<code>head</code>来确定权限。与自旋锁不同，读取<code>head</code>以保证复制时不会有太多的内存竞争（ there is not enough memory contention reading head to warrant replication.）。然而，“取消”状态必须存在于状态字段中。</p><p>队列节点的状态字段也用于避免没有必要的<code>park</code>和<code>unpark</code>调用。虽然这些方法跟阻塞原语一样快，但在跨越Java和JVM runtime以及操作系统边界时仍有可避免的开销。在调用<code>park</code>前，线程设置一个“唤醒（signal me）”位，然后再一次检查同步和节点状态。一个释放的线程会清空其自身状态。这样线程就不必频繁地尝试阻塞，特别是在锁相关的类中，这样会浪费时间等待下一个符合条件的线程去申请锁，从而加剧其它竞争的影响。除非后继节点设置了“唤醒”位（<em>译者注：源码中为-1</em>），否则这也可避免正在release的线程去判断其后继节点。这反过来也消除了这些情形：除非“唤醒”与“取消”同时发生，否则必须遍历多个节点来处理一个似乎为null的<code>next</code>字段。</p><p>同步框架中使用的CLH锁的变体与其他语言中的相比，主要区别可能是同步框架中使用的CLH锁需要依赖垃圾回收管理节点的内存，这就避免了一些复杂性和开销。但是，即使依赖GC也仍然需要在确定链接字段不再需要时将其置为null。这往往可以与出队操作一起完成。否则，无用的节点仍然可触及，它们就没法被回收。</p><p>其它一些更深入的微调，包括CLH队列首次遇到竞争时才需要的初始空节点的延迟初始化等，都可以在J2SE1.5的版本的源代码文档中找到相应的描述。</p><p>抛开这些细节，基本的<code>acquire</code>操作的最终实现的一般形式如下（互斥，非中断，无超时）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">f (!tryAcquire(arg)) &#123;</span><br><span class="line">    node = 创建和入栈一个新的节点;</span><br><span class="line">    pred = 节点有效的前置节点;</span><br><span class="line">    <span class="keyword">while</span> (pred前置节点不是head节点 || !tryAcquire(arg)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (设置pred前置节点的信号位)</span><br><span class="line">        park();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        compareAndSet,设置前置节点信号位为<span class="keyword">true</span>;</span><br><span class="line">        pred = 节点有效的前置节点;</span><br><span class="line">    &#125;</span><br><span class="line">    head = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>release</code>操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(tryRelease(arg) &amp;&amp; head node<span class="string">'s signal bit is set) &#123;</span></span><br><span class="line"><span class="string">    compareAndSet head'</span>s bit to <span class="keyword">false</span>;</span><br><span class="line">    unpark head<span class="string">'s successor, if one exist</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><code>acquire</code>操作的主循环次数依赖于具体实现类中<code>tryAcquire</code>的实现方式。另一方面，在没有“取消”操作的情况下，每一个组件的<code>acquire</code>和<code>release</code>都是一个O(1)的操作，忽略<code>park</code>中发生的所有操作系统线程调度。</p><p>支持“取消”操作主要是要在<code>acquire</code>循环里的<code>park</code>返回时检查中断或超时。由超时或中断而被取消等待的线程会设置其节点状态，然后<code>unpark</code>其后继节点。在有“取消”的情况下，判断其前驱节点和后继节点以及重置状态可能需要O(n)的遍历（n是队列的长度）。由于“取消”操作，该线程再也不会被阻塞，节点的链接和状态字段可以被快速重建。</p><h2 id="3-4-条件队列"><a class="header-anchor" href="#3-4-条件队列"></a>3.4 条件队列</h2><p>AQS框架提供了一个<code>ConditionObject</code>类，给维护独占同步的类以及实现<code>Lock</code>接口的类使用。一个锁对象可以关联任意数目的条件对象，可以提供典型的管程风格的<code>await</code>、<code>signal</code>和<code>signalAll</code>操作，包括带有超时的，以及一些检测、监控的方法。</p><p>通过修正一些设计决策，<code>ConditionObject</code>类有效地将条件（conditions）与其它同步操作结合到了一起。该类只支持Java风格的管程访问规则，这些规则中，仅当当前线程持有锁且要操作的条件（condition）属于该锁时，条件操作才是合法的（一些替代操作的讨论参考[<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>）。这样，一个<code>ConditionObject</code>关联到一个<code>ReentrantLock</code>上就表现的跟内置的管程（通过<code>Object.wait</code>等）一样了。两者的不同仅仅在于方法的名称、额外的功能以及用户可以为每个锁声明多个条件。</p><p><code>ConditionObject</code>使用了与同步器一样的内部队列节点。但是，是在一个单独的条件队列中维护这些节点的。<code>signal</code>操作是通过将节点从条件队列转移到锁队列中来实现的，而没有必要在需要唤醒的线程重新获取到锁之前将其唤醒。</p><p>基本的<code>await</code>操作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">创建和添加新的节点到条件队列;</span><br><span class="line">释放锁;</span><br><span class="line">阻塞,直到节点c处于锁定队列;</span><br><span class="line">重新获得锁;</span><br></pre></td></tr></table></figure><p><code>signal</code>操作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将第一个节点从条件队列转移到锁定队列;</span><br></pre></td></tr></table></figure><p>因为只有在持有锁的时候才能执行这些操作，因此他们可以使用顺序链表队列操作来维护条件队列（在节点中用一个<code>nextWaiter</code>字段）。转移操作仅仅把第一个节点从条件队列中的链接解除，然后通过CLH插入操作将其插入到锁队列上。</p><p>实现这些操作主要复杂在，因超时或<code>Thread.interrupt</code>导致取消了条件等待时，该如何处理。“取消”和“唤醒”几乎同时发生就会有竞态问题，最终的结果遵照内置管程相关的规范。JSR133修订以后，就要求如果中断发生在<code>signal</code>操作之前，await方法必须在重新获取到锁后，抛出<code>InterruptedException</code>。但是，如果中断发生在<code>signal</code>后，<code>await</code>必须返回且不抛异常，同时设置线程的中断状态。</p><p>为了维护适当的顺序，队列节点状态变量中的一个位记录了该节点是否已经（或正在）被转移。“唤醒”和“取消”相关的代码都会尝试用<code>compareAndSet</code>修改这个状态。如果某次<code>signal</code>操作修改失败，就会转移队列中的下一个节点（如果存在的话）。如果某次“取消”操作修改失败，就必须中止此次转移，然后等待重新获得锁。后面的情况采用了一个潜在的无限的自旋等待。在节点成功的被插到锁队列之前，被“取消”的等待不能重新获得锁，所以必须自旋等待CLH队列插入（即<code>compareAndSet</code>操作）被“唤醒”线程成功执行。这里极少需要自旋，且自旋里使用<code>Thread.yield</code>来提示应该调度某一其它线程，理想情况下就是执行signal的那个线程。虽然有可能在这里为“取消”实现一个帮助策略以帮助插入节点，但这种情况实在太少，找不到合适的理由来增加这些开销。在其它所有的情况下，这个基本的机制都不需要自旋或<code>yield</code>，因此在单处理器上保持着合理的性能。</p><h1 id="4-用法"><a class="header-anchor" href="#4-用法"></a>4. 用法</h1><p>AQS类将上述的功能结合到一起，并且作为一种基于“模版方法模式”<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>的基类提供给同步器。子类只需定义状态的检查与更新相关的方法，这些方法控制着acquire和 release操作。然而，将AQS的子类作为同步器ADT并不适合，因为这个类必须提供方法在内部控制acquire和release的规则，这些都不应该被用户所看到。所有java.util.concurrent包中的同步器类都声明了一个私有的继承了<code>AbstractQueuedSynchronizer</code>的内部类，并且把所有同步方法都委托给这个内部类。这样各个同步器类的公开方法就可以使用适合自己的名称。</p><p>下面是一个最简单的<code>Mutex</code>类的实现，它使用同步状态0表示解锁，1表示锁定。这个类并不需要同步方法中的参数，因此这里在调用的时候使用0作为实参，方法实现里将其忽略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Sync</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> ignore)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> compareAndSetState(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> ignore)</span> </span>&#123;</span><br><span class="line">            setState(<span class="number">0</span>); <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; sync.acquire(<span class="number">0</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; sync.release(<span class="number">0</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子的一个更完整的版本，以及其它用法指南，可以在J2SE的文档中找到。还可以有一些变体。如，tryAcquire可以使用一种“test-and-test-and-set”策略，即在改变状态值前先对状态进行校验。</p><p>令人诧异的是，像互斥锁这样性能敏感的东西也打算通过委托和虚方法结合的方式来定义。然而，这正是现代动态编译器一直在重点研究的面向对象设计结构。编译器擅长将这方面的开销优化掉，起码会优化频繁调用同步器的那些代码。</p><p><code>AbstractQueuedSynchronizer</code>类也提供了一些方法用来协助策略控制。例如，基础的acquire方法有可超时和可中断的版本。虽然到目前为止，我们的讨论都集中在像锁这样的独占模式的同步器上，但<code>AbstractQueuedSynchronizer</code>类也包含另一组方法（如<code>acquireShared</code>），它们的不同点在于<code>tryAcquireShared</code>和<code>tryReleaseShared</code>方法能够告知框架（通过它们的返回值）尚能接受更多的请求，最终框架会通过级联的signal(cascading signals)唤醒多个线程。</p><p>虽然将同步器序列化（持久化存储或传输）一般来说没有太大意义，但这些类经常会被用于构造其它类，例如线程安全的集合，而这些集合通常是可序列化的。<code>AbstractQueuedSynchronizer</code>和<code>ConditionObject</code>类都提供了方法用于序列化同步状态，但不会序列化潜在的被阻塞的线程，也不会序列化其它内部暂时性的簿记（bookkeeping）变量。即使如此，在反序列化时，大部分同步器类也只仅将同步状态重置为初始值，这与内置锁的隐式策略一致 —— 总是反序列化到一个解锁状态。这相当于一个空操作，但仍必须显式地支持以便<code>final</code>字段能够反序列化。</p><h2 id="4-1-公平调度的控制"><a class="header-anchor" href="#4-1-公平调度的控制"></a>4.1 公平调度的控制</h2><p>尽管同步器是基于FIFO队列的，但它们并不一定就得是公平的。可以注意到，在基础的acquire算法（3.3节）中，<code>tryAcquire</code>是在入队前被执行的。因此一个新的acquire线程能够“窃取”本该属于队列头部第一个线程通过同步器的机会。</p><p>可<em>闯入</em>的FIFO策略通常会提供比其它技术更高的总吞吐率。当一个有竞争的锁已经空闲，而下一个准备获取锁的线程又正在解除阻塞的过程中，这时就没有线程可以获取到这个锁，如果使用<em>闯入</em>策略，则可减少这之间的时间间隔。与此同时，这种策略还可避免过分的，无效率的竞争，这种竞争是由于只允许一个（第一个）排队的线程被唤醒然后尝试acquire操作导致的。在只要求短时间持有同步器的场景中，创建同步器的开发者可以通过定义<code>tryAcquire</code>在控制权返回之前重复调用自己若干次，来进一步凸显<em>闯入</em>的效果。</p><p><img src="/2017/08/04/AQS论文翻译/fifo-300x90-20190522121813159.png" alt="img"></p><p>可闯入的FIFO同步器只有概率性的公平属性。锁队列头部一个解除了阻塞的线程拥有一次无偏向的机会（<em>译者注：即不会偏向队头的线程也不会偏向闯入的线程</em>）来赢得与<em>闯入</em>的线程之间的竞争，如果竞争失败，要么重新阻塞要么进行重试。然而，如果<em>闯入</em>的线程到达的速度比队头的线程解除阻塞快，那么在队列中的第一个线程将很难赢得竞争，以至于几乎总要重新阻塞，并且它的后继节点也会一直保持阻塞。对于短暂持有的同步器来说，在队列中第一个线程被解除阻塞期间，多处理器上很可能发生过多次<em>闯入</em>（<em>译者注：即闯入的线程的acquire操作</em>）和<code>release</code>了。正如下文所提到的，最终结果就是保持一或多个线程的高进展速度的同时，仍至少在一定概率上避免了饥饿的发生。</p><p>当有更高的公平性需求时，实现起来也很简单。如果需要严格的公平性，程序员可以把tryAcquire方法定义为，若当前线程不是队列的头节点（可通过<code>getFirstQueuedThread</code>方法检查，这是框架提供的为数不多的几个检测方法之一），则立即失败（返回false）。</p><p>一个更快，但非严格公平的变体可以这样做，若队列为空（判断的瞬间），仍然允许<code>tryAcquire</code>执行成功。在这种情况下，多个线程同时遇到一个空队列时可能会去竞争以使自己第一个获得锁，这样，通常至少有一个线程是无需入队列的。<code>java.util.concurrent</code>包中所有支持公平模式的同步器都采用了这种策略。</p><p>尽管公平性设置在实践中很有用，但是它们并没有保障，因为Java Language Specification没有提供这样的调度保证。例如：即使是严格公平的同步器，如果一组线程永远不需要阻塞来达到互相等待，那么JVM可能会决定纯粹以顺序方式运行它们。在实际中，单处理器上，在抢占式上下文切换之前，这样的线程有可能是各自运行了一段时间。如果这样一个线程正持有某个互斥锁，它将很快会被切换回来，仅是为了释放其持有的锁，然后会继续阻塞，因为它知道有另外一个线程需要这把锁，这更增加了同步器可用但没有线程能来获取之间的间隔。同步器公平性设置在多处理器上的影响可能会更大，因为在这种环境下会产生更多的交错，因此一个线程就会有更多的机会发现锁被另一个线程请求。</p><p>在高竞争下，当保护的是短暂持有锁的代码体时，尽管性能可能会较差，但公平锁仍然能有效地工作。例如，当公平性锁保护的是相对长的代码体和/或有着相对长的锁间(inter-lock)间隔，在这种情况下，<em>闯入</em>只能带来很小的性能优势，但却可能会大大增加无限等待的风险。同步器框架将这些工程决策留给用户来确定。</p><h2 id="4-2-同步器"><a class="header-anchor" href="#4-2-同步器"></a>4.2 同步器</h2><p>下面是<code>java.util.concurrent</code>包中同步器定义方式的概述：</p><p><code>ReentrantLock</code>类使用AQS同步状态来保存锁（重复）持有的次数。当锁被一个线程获取时，<code>ReentrantLock</code>也会记录下当前获得锁的线程标识，以便检查是否是重复获取，以及当错误的线程（<em>译者注：如果线程不是锁的持有者，在此线程中执行该锁的unlock操作就是非法的</em>）试图进行解锁操作时检测是否存在非法状态异常。<code>ReentrantLock</code>也使用了AQS提供的ConditionObject，还向外暴露了其它监控和监测相关的方法。<code>ReentrantLock</code>通过在内部声明两个不同的<code>AbstractQueuedSynchronizer</code>实现类（提供公平模式的那个禁用了<em>闯入</em>策略）来实现可选的公平模式，在创建ReentrantLock实例的时候根据设置（<em>译者注：即ReentrantLock构造方法中的fair参数</em>）使用相应的<code>AbstractQueuedSynchronizer</code>实现类。</p><p><code>ReentrantReadWriteLock</code>类使用AQS同步状态中的16位来保存写锁持有的次数，剩下的16位用来保存读锁的持有次数。<code>WriteLock</code>的构建方式同<code>ReentrantLock</code>。<code>ReadLock</code>则通过使用<code>acquireShared</code>方法来支持同时允许多个读线程。</p><p><code>Semaphore</code>类（计数信号量）使用AQS同步状态来保存信号量的当前计数。它里面定义的acquireShared方法会减少计数，或当计数为非正值时阻塞线程；<code>tryRelease</code>方法会增加计数，可能在计数为正值时还要解除线程的阻塞。</p><p><code>CountDownLatch</code>类使用AQS同步状态来表示计数。当该计数为0时，所有的acquire操作（<em>译者注：acquire操作是从aqs的角度说的，对应到CountDownLatch中就是await方法</em>）才能通过。</p><p><code>FutureTask</code>类使用AQS同步状态来表示某个异步计算任务的运行状态（初始化、运行中、被取消和完成）。设置（<em>译者注：FutureTask的set方法</em>）或取消（<em>译者注：FutureTask的cancel方法</em>）一个<code>FutureTask</code>时会调用AQS的<code>release</code>操作，等待计算结果的线程的阻塞解除是通过AQS的<code>acquire</code>操作实现的。</p><p><code>SynchronousQueues</code>类（一种CSP*（Communicating Sequential Processes）*形式的传递）使用了内部的等待节点，这些节点可以用于协调生产者和消费者。同时，它使用AQS同步状态来控制当某个消费者消费当前一项时，允许一个生产者继续生产，反之亦然。</p><p><code>java.util.concurrent</code>包的使用者当然也可以为自定义的应用定义自己的同步器。例如，那些曾考虑到过的，但没有采纳进这个包的同步器包括提供WIN32事件各种风格的语义类，二元信号量，集中管理的锁以及基于树的屏障。</p><h1 id="5-性能"><a class="header-anchor" href="#5-性能"></a>5. 性能</h1><p>虽然AQS框架除了支持互斥锁外，还支持其它形式的同步方式，但锁的性能是最容易测量和比较的。即使如此，也还存在许多不同的测量方式。这里的实验主要是设计来展示锁的开销和吞吐量。</p><p>在每个测试中，所有线程都重复的更新一个伪随机数，该随机数由<code>nextRandom(int seed)</code>方法计算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> t = (seed % <span class="number">127773</span>) * <span class="number">16807</span> – (seed / <span class="number">127773</span>) * <span class="number">2836</span>;</span><br><span class="line"><span class="keyword">return</span> (t &gt; <span class="number">0</span>)? t : t + <span class="number">0x7fffffff</span>;</span><br></pre></td></tr></table></figure><p>在每次迭代中，线程以概率S在一个互斥锁下更新共享的生成器，否则（<em>译者注：概率为1-S</em>）更新其自己局部的生成器，此时是不需要锁的。如此，锁占用区域的耗时是短暂的，这就使线程持有锁期间被抢占时的外界干扰降到了最小。这个函数的随机性主要是为了两个目的：确定是否需要使用锁（这个生成器足以应付这里的需求），以及使循环中的代码不可能被轻易地优化掉。</p><p>这里比较了四种锁：内置锁，用的是<code>synchronized</code>块；互斥锁，用的是像第四节例子中的那样简单的Mutex类；可重入锁，用的是<code>ReentrantLock</code>；以及公平锁，用的是<code>ReentrantLock</code>的公平模式。所有测试都运行在J2SE1.5 JDK build46（大致与beta2相同）的server模式下。在收集测试数据前，测试程序先运行20次非竞争的测试，以排除JVM“预热”（<em>译者注：更多关于“预热”的内容，参见：Java 理论与实践: 动态编译与性能测量</em>）过程的影响。除了公平模式下的测试只跑了一百万次迭代，其它每个线程中的测试都运行了一千万次迭代。</p><p>该测试运行在四个X86机器和四个UltraSparc机器上。所有X86机器都运行的是RedHat基于NPTL 2.4内核和库的Linux系统。所有的UltraSparc机器都运行的是Solaris-9。测试时所有系统的负载都很轻。根据该测试的特征，并不要求系统完全空闲（<em>译者注：即测试时操作系统上有其它较轻的负载也不会影响本次测试的结果。</em>）。“4P”这个名字反映出双核超线程的Xeon更像是4路机器，而不是2路机器。这里没有将测试数据规范化。如下所示，同步的相对开销与处理器的数量、类型、速度之间不具备简单的关系。</p><p><strong>表1 测试的平台</strong></p><table><thead><tr><th>名字</th><th>处理器数量</th><th>类型</th><th>速度(Mhz)</th></tr></thead><tbody><tr><td>1P</td><td>1</td><td>Pentium3</td><td>900</td></tr><tr><td>2P</td><td>2</td><td>Pentium3</td><td>1400</td></tr><tr><td>2A</td><td>2</td><td>Athlon</td><td>2000</td></tr><tr><td>4P</td><td>2HT</td><td>Pentium4/Xeon</td><td>2400</td></tr><tr><td>1U</td><td>1</td><td>UltraSparc2</td><td>650</td></tr><tr><td>4U</td><td>4</td><td>UltraSparc2</td><td>450</td></tr><tr><td>8U</td><td>8</td><td>UltraSparc3</td><td>750</td></tr><tr><td>24U</td><td>24</td><td>UltraSparc3</td><td>750</td></tr></tbody></table><h2 id="5-1-开销"><a class="header-anchor" href="#5-1-开销"></a>5.1 开销</h2><p>无竞争情况下的开销是通过仅运行一个线程，将概率S为1时的每次迭代时间减去概率S为0（访问共享内存的概率为0）时的每次迭代时间得到的（<em>译者注：这里的“概率S”即前文提到的“概率S”，概率为0时是没有锁操作的，概率为1时是每次都有锁操作，因此将概率为1时的耗时减去概率为0时的耗时就是整个锁操作的开销。</em>）。表2以纳秒为单位显示了非竞争场景下每次锁操作的开销。Mutex类最接近于框架的基本耗时，可重入锁的额外开销是记录当前所有者线程和错误检查的耗时，对于公平锁来说还包含开始时检查队列是否为空的耗时。</p><p>表格2也展示与内置锁的“快速路径（fast path）”对比，<code>tryAcquire</code>的耗时。这里的差异主要反映出了各锁和机器中使用的不同的原子指令以及内存屏障的耗时。在多处理器上，这些指令常常是完全优于所有其它指令的。内置锁和同步器类之间的主要差别，显然是由于Hotspot锁在锁定和解锁时都使用了一次<code>compareAndSet</code>，而同步器的<code>acquire</code>操作使用了一次<code>compareAndSet</code>，但<code>release</code>操作用的是一次<code>volatile</code>写（即，多处理器上的一次内存屏障以及所有处理器上的重排序限制）。每个锁的绝对的和相对耗时因机器的不同而不同。</p><p><strong>表2 无竞争时的单锁开销（单位：纳秒）</strong></p><table><thead><tr><th>机器</th><th>内置</th><th>互斥</th><th>可重入</th><th>公平可重入</th></tr></thead><tbody><tr><td>1P</td><td>18</td><td>9</td><td>31</td><td>37</td></tr><tr><td>2P</td><td>58</td><td>71</td><td>77</td><td>81</td></tr><tr><td>2A</td><td>13</td><td>21</td><td>31</td><td>30</td></tr><tr><td>4P</td><td>116</td><td>95</td><td>109</td><td>117</td></tr><tr><td>1U</td><td>90</td><td>40</td><td>58</td><td>67</td></tr><tr><td>4U</td><td>122</td><td>82</td><td>100</td><td>115</td></tr><tr><td>8U</td><td>160</td><td>83</td><td>103</td><td>123</td></tr><tr><td>24U</td><td>161</td><td>84</td><td>108</td><td>119</td></tr></tbody></table><p>从另一个极端看，表3展示了概率S为1，运行256个并发线程时产生了大规模的锁竞争下每个锁的开销。在完全饱和的情况下，可<em>闯入</em>的FIFO锁比内置锁的开销少了一个数量级（也就是更大的吞吐量），比公平锁更是少了两个数量级。这表现出即使有着极大的竞争，在维持线程进展方面可<em>闯入</em>FIFO策略的效率。</p><p>表3也说明了即使在内部开销比较低的情况下，公平锁的性能也完全是由上下文切换的时间所决定的。列出的时间大致上都与各平台上线程阻塞和解除线程阻塞的时间相称。</p><p>此外，后面增加的一个实验（仅使用机器4P）表明，对于这里用到的短暂持有的锁，公平参数的设置在总差异中的影响很小。这里将线程终止时间间的差异记录成一个粗粒度的离散量数。在4P的机器上，公平锁的时间度量的标准差平均为0.7%，可重入锁平均为6.0%。作为对比，为模拟一个长时间持有锁的场景，测试中使每个线程在持有锁的情况下计算了16K次随机数。这时，总运行时间几乎是相同的（公平锁：9.79s，可重入锁：9.72s）。公平模式下的差异依然很小，标准差平均为0.1%，而可重入锁上升到了平均29.5%。</p><p><strong>表格3 饱和时的单锁开销（单位：纳秒）</strong></p><table><thead><tr><th>机器</th><th>内置</th><th>互斥</th><th>可重入</th><th>公平可重入</th></tr></thead><tbody><tr><td>1P</td><td>521</td><td>46</td><td>67</td><td>8327</td></tr><tr><td>2P</td><td>930</td><td>108</td><td>132</td><td>14967</td></tr><tr><td>2A</td><td>748</td><td>79</td><td>84</td><td>33910</td></tr><tr><td>4P</td><td>1146</td><td>188</td><td>247</td><td>15328</td></tr><tr><td>1U</td><td>879</td><td>153</td><td>177</td><td>41394</td></tr><tr><td>4U</td><td>2590</td><td>347</td><td>368</td><td>30004</td></tr><tr><td>8U</td><td>1274</td><td>157</td><td>174</td><td>31084</td></tr><tr><td>24U</td><td>1983</td><td>160</td><td>182</td><td>32291</td></tr></tbody></table><h2 id="5-2-吞吐量"><a class="header-anchor" href="#5-2-吞吐量"></a>5.2 吞吐量</h2><p>大部分同步器都是用于无竞争和极大竞争之间的。这可以用实验在两个方面进行检查，通过修改固定个线程的竞争概率，和/或通过往拥有固定竞争概率的线程集合里增加更多的线程。为了说明这些影响，测试运行在不同的竞争概率和不同的线程数目下，都用的是可重入锁。附图使用了一个<em>slowdown</em>度量标准。</p><p><a href="http://ifeve.com/wp-content/uploads/2013/02/formula.jpg" target="_blank" rel="noopener"><img src="/2017/08/04/AQS论文翻译/formula-300x66-20190522121813117.jpg" alt="img"></a></p><p>这里，t是总运行时间，b是一个线程在没有竞争或同步下的基线时间，n是线程数，p是处理器数，S是共享访问的比例（<em>译者注：即前面的竞争概率S</em>）。计算结果是实际执行时间与理想执行时间（通常是无法得到的）的比率，理想执行时间是通过使用Amdahl’s法则计算出来的。理想时间模拟了一次没有同步开销，没有因锁争用而导致线程阻塞的执行过程。即使这样，在很低的竞争下，相比理想时间，有一些测试结果却表现出了很小的速度增长，大概是由于基线和测试之间的优化、流水线等方面有着轻微的差别。</p><p>图中用以2为底的对数为比例进行了缩放。例如，值为1表示实际时间是理想时间的两倍，4表示慢16倍。使用对数就不需要依赖一个随意的基线时间（这里指的是计算随机数的时间），因此，基于不同底数计算的结果表现出的趋势应该是类似的。这些测试使用的竞争概率从1/128（标识为“0.008”）到1，以2的幂为步长，线程的数量从1到1024，以2的幂的一半为步长。</p><p>在单处理器（1P和1U）上，性能随着竞争的上升而下降，但不会随着线程数的增加而下降。多处理器在遭遇竞争时，性能下降的更快。根据多处理器相关的图表显示，开始出现的峰值处虽然只有几个线程的竞争，但相对性能通常却最差。这反映出了一个性能的<em>过渡区域</em>，在这里<em>闯入</em>的线程和被唤醒的线程都准备获取锁，这会让它们频繁的迫使对方阻塞。在大部分时候，过渡区域后面会紧接着一个<em>平滑区域</em>，因为此时几乎没有空闲的锁，所以会与单处理器上顺序执行的模式差不多；在多处理器机器上会较早进入平滑区域。例如，请注意，在满竞争（标识为“1.000”）下这些值表示，在处理器越少的机器上，会有更糟糕的相对速度下降。</p><p>根据这些结果，可以针对阻塞（park/unpark）做进一步调优以减少上下文切换和相关的开销，这会给本框架带来小但显著的提升。此外，在多处理器上为短时间持有的但高竞争的锁采用某种形式的适应性自旋，可以避免这里看到的一些波动，这对同步器类大有裨益。虽然在跨不同上下文时适应性自旋很难很好的工作，但可以使用本框架为遇到这类使用配置的特定应用构建一个自定义形式的锁。</p><p><img src="/2017/08/04/AQS论文翻译/584866-20170721153333433-1036091107-20190522121812946.jpg" alt="img"></p><p><img src="/2017/08/04/AQS论文翻译/584866-20170721153344933-80322669-20190522121812997.jpg" alt="img"></p><p><img src="/2017/08/04/AQS论文翻译/584866-20170721153353714-548675583-20190522121813004.jpg" alt="img"></p><p><img src="/2017/08/04/AQS论文翻译/584866-20170721153402620-2093158242-20190522121812993.jpg" alt="img"></p><h1 id="6-总结"><a class="header-anchor" href="#6-总结"></a>6. 总结</h1><p>本文撰写之时，<code>java.util.concurrent</code>包中的同步器框架还太新所以还不能在实践中使用。因此在J2SE 1.5最终版本发布之前都很难看到其大范围的使用，并且，它的设计，API实现以及性能肯定还有无法预料的后果。但是，此时，这个框架明显能胜任其基本的目标，即为创建新的同步器提供一个高效的基础。</p><h1 id="7-致谢"><a class="header-anchor" href="#7-致谢"></a>7. 致谢</h1><p>Thanks to Dave Dice for countless ideas and advice during the development of this framework, to Mark Moir and Michael Scott for urging consideration of CLH queues, to David Holmes for critiquing early versions of the code and API, to Victor Luchangco and Bill Scherer for reviewing previous incarnations of the source code, and to the other members of the JSR166 Expert Group (Joe Bowbeer, Josh Bloch, Brian Goetz, David Holmes, and Tim Peierls) as well as Bill Pugh, for helping with design and specifications and commenting on drafts of this paper. Portions of this work were made possible by a DARPA PCES grant, NSF grant EIA-0080206 (for access to the 24way Sparc) and a Sun Collaborative Research Grant.</p><h3 id="参考文献"><a class="header-anchor" href="#参考文献"></a>参考文献</h3><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>译文原文链接：原文链接：<a href="http://ifeve.com/tag/aqs/" target="_blank" rel="noopener">http://ifeve.com/tag/aqs/</a> <a href="#fnref1" class="footnote-backref">↩</a></p></li><li id="fn2" class="footnote-item"><p>Craig, T. S. Building FIFO and priority-queueing spin locks from atomic swap. Technical Report TR 93-02-02,Department of Computer Science, University of Washington, Feb. 1993. <a href="#fnref2" class="footnote-backref">↩</a></p></li><li id="fn3" class="footnote-item"><p>Magnussen, P., A. Landin, and E. Hagersten. Queue locks on cache coherent multiprocessors. 8th Intl. Parallel Processing Symposium, Cancun, Mexico, Apr. 1994. <a href="#fnref3" class="footnote-backref">↩</a></p></li><li id="fn4" class="footnote-item"><p>M. L. Scott and W N. Scherer III. Scalable Queue-Based Spin Locks with Timeout. 8th ACM Symp. on Principles and Practice of Parallel Programming, Snowbird, UT, June 2001. <a href="#fnref4" class="footnote-backref">↩</a></p></li><li id="fn5" class="footnote-item"><p>Buhr, P. M. Fortier, and M. Coffin. Monitor Classification,ACM Computing Surveys, March 1995. <a href="#fnref5" class="footnote-backref">↩</a></p></li><li id="fn6" class="footnote-item"><p>Gamma, E., R. Helm, R. Johnson, and J. Vlissides. Design Patterns, Addison Wesley, 1996. <a href="#fnref6" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AQS </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深入理解 Java 内存模型</title>
      <link href="/2017/03/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2017/03/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="说明"><a class="header-anchor" href="#说明"></a>说明</h1><p>又发现一本不错的小书<a href="https://www.infoq.cn/article/java_memory_model" target="_blank" rel="noopener">《深入理解 Java 内存模型》</a>，趁着昨天周六一口气读完，虽然篇幅只有区区70页，可受益颇多。由于原文短小精悍，为了预留合理的上下文以助于理解，本文保留了大部分原文，并且在关键处使用笔者自己的理解对原文进行再解释（以表达方式再排列、语义扩充等方法，尽量在语义上确保大于等于原意）。好了废话不多说，我们开始吧~</p><h1 id="基础"><a class="header-anchor" href="#基础"></a>基础</h1><h2 id="并发编程的分类"><a class="header-anchor" href="#并发编程的分类"></a>并发编程的分类</h2><p>在并发编程中，我们需要处理两个关键问题：线程之间如何通信及线程之间如何同步（这里的线程是指并发执行的活动实体）。通信是指线程之间以何种机制来交换 信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。</p><p>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。在消息传递的并发模型里，线程之间没有公共状 态，线程之间必须通过明确的发送消息来显式进行通信。</p><p>同步是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之 间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前， 因此同步是隐式进行的。</p><p>Java 的并发采用的是共享内存模型，Java 线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的 Java 程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。</p><h2 id="java-内存模型的抽象"><a class="header-anchor" href="#java-内存模型的抽象"></a>Java 内存模型的抽象</h2><p>在java中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享（本文使用“共享变量”这个术语代指实例域，静态域和数组元素）。局部变量 （Local variables），方法定义参数（java语言规范称之为formal method parameters）和异常处理器参数（exception handler parameters）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。</p><p>Java 线程之间的通信由 Java 内存模型（本文简称为 JMM）控制，JMM 决定一个 线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java 内存模型的抽象示意图如下：</p><p><img src="/2017/03/12/深入理解Java内存模型/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%8A%BD%E8%B1%A1%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="Java内存模型抽象示意图"></p><p>从上图来看，线程 A 与线程 B 之间如要通信的话，必须要经历下面 2 个步骤：</p><ol><li>线程 A 把本地内存 A 中更新过的共享变量刷新到主内存中去</li><li>然后，线程 B 到主内存中去读取线程 A 之前已经更新过的共享变量</li></ol><p><img src="/2017/03/12/深入理解Java内存模型/%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%AD%A5%E9%AA%A4.jpg" alt="两个线程通信步骤"></p><p>举例说明Java线程间通信机制：</p><p>以上图为背景，线程 A 、B 有主内存中共享变量 x 的副本。</p><ol><li><p>假设一开始，这三个内存中的 x 的值都为 0.</p></li><li><p>线程 A 在执行时，把更新后的 x 值（假设值为1）临时存放在自己的本地内存 A 中。</p></li><li><p>当线程 A 和 B 需要通信时，线程 A 首先会把自己本地内存中修改后的 x 值刷新到主内存中，此时主内存中的 x 值变为了 1。</p></li><li><p>随后，线程 B 到主内存中去读线程 A 更新后的 x 值，此时线程 B 的本地内存的 x 值夜变为了 1。</p></li></ol><blockquote><p>整体来看，实质上是线程 A 向 B 发送消息，而且这个通信过程必须要经过主内存。JMM 通过控制主内存与每个线程的本地内存之间的交互，来为 Java 程序员提供内存可见性保证。</p></blockquote><a id="more"></a><h2 id="重排序"><a class="header-anchor" href="#重排序"></a>重排序</h2><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分为三种类型：</p><ol><li><p>编译器优化排序编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</p></li><li><p>指令级并行重排序现代处理器采用了指令级秉性技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应的机器指令的执行顺序。</p></li><li><p>内存系统的重排序</p><p>由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p></li></ol><p>从 Java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p><p><img src="/2017/03/12/深入理解Java内存模型/Java%E6%BA%90%E7%A0%81%E5%88%B0%E6%89%A7%E8%A1%8C%E6%B6%89%E5%8F%8A%E7%9A%84%E9%87%8D%E6%8E%92%E5%BA%8F.jpg" alt="Java 源码到执行涉及的重排序"></p><p>其中 1 属于编译器重排序，2 和 3 属于处理器重排序。</p><p>这些重排序都可能会导致多线程程序出现内存可见性问题。因此，为了避免此问题，JMM编译器设置了一些规则：</p><ul><li>对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。</li><li>对于处理器重排序，JMM 的处理器重排序规则会要求 Java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。</li></ul><blockquote><p>JMM 属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p></blockquote><h2 id="处理器重排序与内存屏障指令"><a class="header-anchor" href="#处理器重排序与内存屏障指令"></a>处理器重排序与内存屏障指令</h2><p>现代处理器使用写缓冲区来临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。虽然写缓冲区有这么多的好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产重要的影响：处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致！</p><p>我们来假设这样一种情况：</p><table><thead><tr><th>Processor A</th><th>Processor B</th></tr></thead><tbody><tr><td>a = 1;   //A1   <br>x = b;   //A2</td><td>b = 2;   //B1  <br> y = a;   //B2</td></tr></tbody></table><p>显然，我们期望得到的执行结果是: x = 2，y = 1。然而实际上，我们却可能得到 x = y = 0，这是为什么呢？</p><p><img src="/2017/03/12/深入理解Java内存模型/%E5%A4%84%E7%90%86%E5%99%A8%E9%87%8D%E6%8E%92%E5%BA%8F%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98.jpg" alt="处理器重排序导致的问题"></p><ul><li>这里处理器 A 和处理器 B 可以同时把共享变量写入自己的缓冲区（A1，B1）</li><li>然后从内存中读取另一个共享变量（A2，B2）</li><li>最后才把自己写缓存区保存的脏数据刷新到内存中（A3，B3）。当以这种时序执行时，程序就可以得到 x=y=0</li></ul><p>从内存操作实际发生的顺序看，直到处理器 A 执行 A3 来刷新自己的写缓存区 A，写操作 A1 才算真正执行了。虽然处理器 A 执行内存操作的顺序为：A1 -&gt; A2，但内存操作实际发生的顺序确是 A2 -&gt; A1。此时，处理器 A 的内存操作顺序被重排序了</p><p>处理器 B 和 A 的情况是类似的，这里不赘述了。</p><blockquote><p>产生这个结果的关键是，由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作顺序不一致。</p></blockquote><p>下面是常见处理器允许的重排序类型的列表：</p><table><thead><tr><th></th><th>Load-Load</th><th>Load-Store</th><th>Store-Store</th><th>Store-Load</th><th>数据依赖</th></tr></thead><tbody><tr><td>sparc- TSO</td><td>N</td><td>N</td><td>N</td><td>Y</td><td>N</td></tr><tr><td><strong>x86</strong></td><td>N</td><td>N</td><td>N</td><td>Y</td><td>N</td></tr><tr><td>ia64</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>PowerPC</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>N</td></tr></tbody></table><p>N 表示处理器不允许两个操作重排序，Y 反之。</p><p>从上表我们可以看出：常见的处理器都允许 Store-Load 重排序；常见的处理器都不允许对存在数据以来的操作做重排序。特别的，对于 x86 架构的处理器，仅仅会在 Store-Load 这种情况进行重排序。</p><p>到这里，有同学可能有疑问了，既然 CPU 肯定会对 Store-Load 这种情况进行重排序，那岂不是乱套了，我 Java 代码怎么写？？</p><p>实际上，为了解决这个问题，Java 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。</p><p>JMM 把内存屏障指令分为以下四类：</p><table><thead><tr><th>屏障类型</th><th>指令示例</th><th>说明</th></tr></thead><tbody><tr><td>LoadLoad Barriers</td><td>Load1; LoadLoad; Load2</td><td>确保 Load1 数据的装载，之前于Load2 及所有后续装载指令的装载。</td></tr><tr><td>StoreStore Barriers</td><td>Store1;StoreStore; Store2</td><td>确保 Store1 数据对其他处理器可 见（刷新到内存），之前于 Store2 及所有后续存储指令的存储。</td></tr><tr><td>LoadStore Barriers</td><td>Load1;LoadStore; Store2</td><td>确保 Load1 数据装载，之前于 Store2 及所有后续的存储指令刷 新到内存。</td></tr><tr><td>StoreLoad Barriers</td><td>Store1;StoreLoad; Load2</td><td>确保 Store1 数据对其他处理器变得可见（指刷新到内存），之前于 Load2 及所有后续装载指令的装载。StoreLoad Barriers 会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。</td></tr></tbody></table><blockquote><p>现代处理器大多支持 Store-Load Barriers （其他类型的屏障不一定被所有处理器支持）。但是执行该屏障的开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（buffer fully flush）。</p></blockquote><h2 id="happens-before"><a class="header-anchor" href="#happens-before"></a>happens-before</h2><p>从 JDK5 开始，Java 使用新的 JSR-133 内存模型（本文除非特别说明，针对的都是 JSR-133 内存模型）。JSR-133 使用 happens-before 的概念来阐述操作之间的内存可见性。</p><blockquote><p>在 JMM 中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同的线程之间。</p></blockquote><p>happens-before 规则如下：</p><ul><li>程序顺序规则一个线程中的每个操作，happens-before 于该线程中的任意后续操作</li><li>监视器锁规则对一个监视器的解锁，happens-before 于随后对这个监视器的加锁</li><li>volatile 变量规则对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读</li><li>传递性如果 A happens-before B，且 B happens-before C，那么 A happens-before C</li></ul><p>这里，解释一下 happens-before 关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before 仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前。这个定义看起来很微妙，后文具体说明为什么这么定义。</p><p>总结下happens-before 与 JMM 的关系，如下图所示：</p><p><img src="/2017/03/12/深入理解Java内存模型/happens-before%E4%B8%8EJMM%E7%9A%84%E5%85%B3%E7%B3%BB.jpg" alt="happens-before与JMM的关系"></p><p>如上图所示，一个 happens-before 规则对应一个或多个编译器和处理器重排序规则。对于 Java 程序员来说，happens-before 规则简单易懂，它避免 Java 程序员为了理解 JMM 提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现。</p><h1 id="重排序-v2"><a class="header-anchor" href="#重排序-v2"></a>重排序</h1><h2 id="数据依赖性"><a class="header-anchor" href="#数据依赖性"></a>数据依赖性</h2><p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时，这两个操作之间就存在数据依赖性。</p><p>数据依赖分下列三种类型：</p><table><thead><tr><th>名称</th><th>代码示例</th><th>说明</th></tr></thead><tbody><tr><td>写后读</td><td>a = 1;   <br>b = a;</td><td>写一个变量之后，再读这个位置。</td></tr><tr><td>写后写</td><td>a = 1;   <br>a = 2;</td><td>写一个变量之后，再写这个变量。</td></tr><tr><td>读后写</td><td>a = b;<br>b = 1;</td><td>读一个变量之后，再写这个变量。</td></tr></tbody></table><p>很容易对这三种情况得出如下结论：</p><p>上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。</p><p>前面提到过，编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。也就是说，上面三种情况，不会发生处理器重排序。</p><p>不过，这里需要注意，这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑（这种情况参考<a href="#%E5%A4%84%E7%90%86%E5%99%A8%E9%87%8D%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E6%8C%87%E4%BB%A4">前面</a>中的例子）</p><h2 id="as-if-serial-语义"><a class="header-anchor" href="#as-if-serial-语义"></a>as-if-serial 语义</h2><p>不管怎么重排序（编译器和处理器为了提升并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。</p><p>为了遵守 as-if-serial 语义，编译器和处理器不会对存在 <a href="#%E6%95%B0%E6%8D%AE%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB">数据依赖关系</a> 的操作做重排序，因为这种重排序会改变执行结果。</p><p>但是，如果操作之前不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。我们举例说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> pi = <span class="number">3.14</span>;<span class="comment">// A</span></span><br><span class="line"><span class="keyword">double</span> r = <span class="number">1.0</span>;<span class="comment">// B</span></span><br><span class="line"><span class="keyword">double</span> area = pi * r * r; <span class="comment">// C</span></span><br></pre></td></tr></table></figure><p>上面三个操作的数据依赖关系如下图所示：</p><p><img src="/2017/03/12/深入理解Java内存模型/%E4%B8%89%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB.jpg" alt="三个操作的数据依赖关系"></p><p>如上图所示，A 和 C 之间存在数据依赖关系，同时 B 和 C 之间也存在数据依赖关系。因此在最终执行的指令序列中，C 不能被重排序到 A 和 B 的前面（因为这种情况下程序结果将被改变）。但 A 和 B 之间是没有数据依赖关系的，编译器和处理器可以重排序 A 和 B 之间的执行顺序。下图是该程序的两种执行顺序：</p><p><img src="/2017/03/12/深入理解Java内存模型/%E4%B8%A4%E7%A7%8D%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.jpg" alt="两种执行顺序"></p><blockquote><p>as-if-serial 语义把单线程程序保护了起来，遵守 as-if-serial 语义的编译器、runtime和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序时按程序的顺序来执行的。as-if-serial 语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。</p></blockquote><h2 id="程序顺序规则"><a class="header-anchor" href="#程序顺序规则"></a>程序顺序规则</h2><p>根据 happens-before 的程序顺序规则，上面计算圆的面积的示例代码存在三个 happens-before 关系：</p><ol><li>A happens-before B</li><li>B happens-before C</li><li>A happens-before C（根据前两个推导出来的，即传递性）</li></ol><p>这里 A happens-before B ，但实际执行 B 却可以排在 A 之前执行（看上面那两种重排序后的执行顺序）。在<a href="#happens-before">前面</a>提到过，如果 A happens-before B ，JMM 并不要求 A 一定要在 B 之前执行。JMM 仅仅要求前一个操作（执行的结果）对后一个操作可见；而且重排序操作 A 和操作 B 后的执行结果，与操作 A 和 B 按照程序顺序执行的结果一致。在这种情况下，JMM 会认为这种重排序并不非法（not illegal），JMM 允许这种排序。</p><p>在计算机中，软件技术和硬件技术有一个共同的目标：在不改变程序执行结果的前提下，尽可能的开发并行度。编译器和处理器遵从这一目标，从 happens-before 的定义我们可以看出，JMM 同样遵从这一目标。</p><h2 id="重排序对多线程的影响"><a class="header-anchor" href="#重排序对多线程的影响"></a>重排序对多线程的影响</h2><p>现在让我们看看，重排序是否会改变多线程程序的执行结果。我们还用一个示例代入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecorderExample</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;              <span class="comment">// 1</span></span><br><span class="line">    flag = <span class="keyword">true</span>;        <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;         <span class="comment">// 3</span></span><br><span class="line">      <span class="keyword">int</span> i = a * a;    <span class="comment">// 4</span></span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flag 变量是一个标记，用来标识变量 a 是否已被写入。这里假设有两个线程 A 和 B，A 首先执行 writer()方法，随后 B 线程接着执行 reader()方法。线程 B 在执行操作 4 时，能否看到线程 A 在操作 1 对共享变量 a 的写入？</p><p>答案是：不一定看到。</p><p>由于操作 1 和操作 2 没有数据依赖关系，编译器和处理器可以对这两个操作重排序；同样，操作 3 和操作 4 没有数据依赖关系，编译器和处理器也可以对这两个操作重排序。让我们先来看看，当操作 1 和操作 2 重排序时，可能会产生什么效果？</p><p><img src="/2017/03/12/深入理解Java内存模型/%E6%93%8D%E4%BD%9C1%E5%92%8C%E6%93%8D%E4%BD%9C2%E9%87%8D%E6%8E%92%E5%BA%8F%E6%97%B6%EF%BC%8C%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%97%B6%E5%BA%8F%E5%9B%BE.jpg" alt="操作1和操作2重排序时，程序执行时序图"></p><p>注：本文统一用红色的虚箭线标识错误的读操作，用绿色的虚箭线标识正确的读操作</p><p>如上图所示，操作 1 和操作 2 做了重排序。程序执行时，线程 A 首先写标记变量 flag，随后线程 B 读这个变量。由于条件判断为真，线程 B 将读取变量 a。此时，变量 a 还根本没有被线程 A 写入，在这里多线程程序的语义被重排序破坏了！</p><p>现在再让我们看看，当操作 3 和操作 4 重排序时会产生什么效果（借助这个重排序，可以顺便说明控制依赖性）。如图所示，操作 3 和 4 重排序后，程序的执行时序：</p><p><img src="/2017/03/12/深入理解Java内存模型/%E6%93%8D%E4%BD%9C3%E5%92%8C%E6%93%8D%E4%BD%9C4%E9%87%8D%E6%8E%92%E5%BA%8F%E6%97%B6%EF%BC%8C%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%97%B6%E5%BA%8F%E5%9B%BE.jpg" alt="操作3和操作4重排序时，程序执行时序图"></p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存模型 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM Internals</title>
      <link href="/2017/02/11/JVM-Internals/"/>
      <url>/2017/02/11/JVM-Internals/</url>
      
        <content type="html"><![CDATA[<h1 id="说明"><a class="header-anchor" href="#说明"></a>说明</h1><p>本文系转载，并在转载译文基础上根据笔者经验略作修改。原文链接在<a href="#%E8%BD%AC%E8%BD%BD%E9%93%BE%E6%8E%A5">文末</a></p><h1 id="一-前言"><a class="header-anchor" href="#一-前言"></a>一、前言</h1><p>本文将介绍JVM内部架构。下图展示符合Java7规范的JVM内部主要组件。</p><p><img src="/2017/02/11/JVM-Internals/291701116593444.png" alt="img"></p><p>下面我们将上述组件分为线程相关和线程独立两种类型来介绍。</p><a id="more"></a><h1 id="二-thread"><a class="header-anchor" href="#二-thread"></a>二、Thread</h1><p>JVM允许进程包含多个并发的线程。Hotspot JVM中的Java线程与OS线程是一一对应的。当线程工作存储区（thread-local storage）、配置缓存（allocation buffers）、同步对象（synchronized objects）、栈和本地栈（stacks）和程序计数器（pragram counter）等Java线程相关的状态均准备好后，就会启动OS线程并有OS线程执行run函数。OS负责线程的调度。当以正常方式或异常抛出的方式退出run函数，OS线程均会判断当前Java线程的终止是否会导致进程的终止（进程的工作线程是否都终止了？），若要终止进程的化，则释放Java线程和OS线程所占的资源，否则就释放Java线程的资源，并回收OS线程。</p><h2 id="1-jvm-system-threads"><a class="header-anchor" href="#1-jvm-system-threads"></a>1、JVM System Threads</h2><p>若你用过jconsole或其他调试工具，你会发现除了主线程外还存在数个有JVM创建的系统线程。Hotspot JVM的系统线程有这5个：</p><h2 id="2-vm-thread-虚拟机线程"><a class="header-anchor" href="#2-vm-thread-虚拟机线程"></a>2、VM thread（虚拟机线程）</h2><p>VM thread 用于为一些需要防止堆变化操作提供执行环境，当要执行防止堆变化的操作时，就是要求JVM启动安全点（safe-point）,此时将会暂停GC、线程栈操作、线程恢         复和偏向锁解除。</p><h2 id="3-periodic-task-thread-周期性任务线程"><a class="header-anchor" href="#3-periodic-task-thread-周期性任务线程"></a>3、Periodic task thread（周期性任务线程）</h2><p>Periodic task thread负责定时事件（如interrupts），用于周期性执行计划任务</p><h2 id="4-gc-threads-垃圾回收线程"><a class="header-anchor" href="#4-gc-threads-垃圾回收线程"></a>4、GC threads（垃圾回收线程）</h2><p>GC threads 负责不同类型垃圾回收活动。</p><h2 id="5-compiler-threads-编译器线程"><a class="header-anchor" href="#5-compiler-threads-编译器线程"></a>5、Compiler threads（编译器线程）</h2><p>Compiler threads用于在运行时将字节码编译为CPU本地代码。</p><h2 id="6-signal-dispatcher-thread-信号量分发线程"><a class="header-anchor" href="#6-signal-dispatcher-thread-信号量分发线程"></a>6、Signal dispatcher thread（信号量分发线程）</h2><p>Singal dispatcher thread用于接收发送给JVM的信号量，并将其分发到合适的JVM方法来处理。</p><h1 id="三-per-thread"><a class="header-anchor" href="#三-per-thread"></a>三、Per Thread</h1><p>每个线程的执行环境均有以下的组件。</p><h2 id="1-program-counter-pc-程序计数器"><a class="header-anchor" href="#1-program-counter-pc-程序计数器"></a>1、Program Counter(PC)（程序计数器）</h2><p>用于存放当前指令（或操作码）的地址，若该指令为本地指令那么PC为undefined。当执行完当前指令后PC会自增（根据当前指令的定义自增1或N）从而指向下一个指令的地　　址，那么JVM就可以知道接下来要执行哪个指令了。事实上PC存放的是方法区（Method Area）中的内存地址。</p><h2 id="2-stack-堆栈"><a class="header-anchor" href="#2-stack-堆栈"></a>2、Stack（堆栈）</h2><p>每个线程有自定独立的堆栈用于存放在该线程执行的方法。堆栈是一个后进先出（LIFO）的数据结构，元素称为栈帧（frame）。当将要在线程上执行某方法时，则需要将代表　　该方法的栈帧压栈，当方法执行完毕后（正常退出或抛出未处理的异常）则将栈帧弹栈。栈帧可能分配在堆上（heap），而堆栈并不需要连续的存储空间。</p><h2 id="3-native-stack-本地堆栈"><a class="header-anchor" href="#3-native-stack-本地堆栈"></a>3、Native Stack（本地堆栈）</h2><p>不是每种JVM都支持本地方法，对于支持本地方法的JVM它门会提供线程本地堆栈。若JVM实现了通过C链接模型（C-linkage Model）来实现JNI，那么本地堆栈实质就是C堆　　栈（入参顺序和返回值均与C程序一致）。本地方法一般都可以调用Java方法，此时会在Java的堆栈中压入一个栈帧并按执行Java方法的流程处理。</p><p>Stack Restrictions（堆栈约束）：堆栈的容量有动态和固定两种。当栈帧数量大于堆栈容量时就会抛出StackOverflowError；当堆中没有足够内存来分配新栈帧时则抛出OutOfMemoryError。</p><h2 id="4-frame-堆栈的元素-栈帧"><a class="header-anchor" href="#4-frame-堆栈的元素-栈帧"></a>4、Frame（堆栈的元素——栈帧）</h2><h3 id="4-1-local-varibles-array-局部变量表"><a class="header-anchor" href="#4-1-local-varibles-array-局部变量表"></a>4.1、Local Varibles Array（局部变量表）</h3><p>局部变量表用于存放方法执行过程中this引用、方法入参和局部变量。对于静态方法而言方法参数从局部变量表的第一位开始（下标为0），对于实例方法而言方法参数从局部变量表的第二位开始（下标为1，第一位是this引用）。局部变量表内可包含以下类型数据，boolean/byte/char/long/short/int/float/double/reference/returnAddress。</p><p>局部变量表的每个元素占32bit，每32bit称为1个slot。上述所支持的类型中除了long和double外均占1个slot，而它俩就占2个slot。</p><h3 id="4-2-operand-stack-操作数栈"><a class="header-anchor" href="#4-2-operand-stack-操作数栈"></a>4.2、Operand Stack（操作数栈）</h3><p>在执行方法内部的字节码指令时需要使用操作数栈，大多数JVM的字节码指令是用于操作操作数栈（压栈、弹栈、赋值栈帧、栈帧互换位置或执行方法操作栈帧），实现数据在操作数栈和局部变量表之间频繁移动。示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//java code</span><br><span class="line">int i;</span><br><span class="line"></span><br><span class="line">// bytecode</span><br><span class="line">0: iconst_0 // 将0压栈</span><br><span class="line">1: istore_1 // 弹栈并将值赋值到局部变量表的第二个Slot槽中</span><br></pre></td></tr></table></figure><h3 id="4-3-dynamic-linking-动态链接"><a class="header-anchor" href="#4-3-dynamic-linking-动态链接"></a>4.3、Dynamic Linking（动态链接）</h3><p>每个栈帧均包含一个指向运行时常量池（runtime constant pool）的引用。通过这个运行时常量池来实现动态链接。</p><p>C/C++的代码会被编译成一个一个独立的对象文件，并通过静态链接将对多个对象文件生成一个执行文件或dll类库。在链接阶段所有的符号引用会被直接引用取代，而直接引用则为相对于可执行文件的进程入口地址的相对地址。而Java的链接阶段是在运行时动态发生的。</p><p>当将Java类编译成字节码时，所有对变量和方法的引用将被保存为常量池表中的一条条符号引用表项，这些符号引用为逻辑引用而不是指向物理内存地址的引用。JVM可以选择不同的时刻将符号引用转换为直接引用。一种是当class文件加载并验证通过后，这种称为静态处理（eager or static resolution）；另一种是在使用时才转换为直接引用，这种称为懒处理（lazy or late resolution）。对于字段通过绑定来处理，对于对象或类则通过将符号引用转换直接引用来识别，动态链接后原有的符号引用将被直接引用替换，因此对于同一个符号引用，动态链接的操作仅发生一次。假如直接引用的类还未加载，则会加载该类。而直接引用所包含的地址相对于变量和方法在运行时的地址。</p><h1 id="shared-between-threads"><a class="header-anchor" href="#shared-between-threads"></a>Shared Between Threads</h1><h1 id="四-heap-堆"><a class="header-anchor" href="#四-heap-堆"></a>四、Heap（堆）</h1><p>堆用于在运行时分配对象和数组。由于栈帧的容量是固定的，因此无法将对象和数组等容量可变的数据存放到堆栈中，而是将对象和数组在堆中的地址存放在栈帧中从而操作对象和数组。由于对象和数组是存放在堆，因此需要通过垃圾回收器来回收它们所占的内存空间。垃圾回收机制将堆分成3部分：</p><ol><li>新生代（再细分为初生空间和幸存空间）</li><li>老年代</li><li>永久代（译者语：永久代不在堆上）</li></ol><h1 id="五-memory-management-内存管理"><a class="header-anchor" href="#五-memory-management-内存管理"></a>五、Memory Management（内存管理）</h1><p>对象和数组不能被显式地释放，必须通过垃圾回收器来自动回收。一般的工作步骤如下：</p><ol><li>新创建的对象和数组被存放在新生代;</li><li>次垃圾回收将会对新生代作操作，存活下来的将从初生空间移至幸存空间;</li><li>主垃圾回收（一般会导致应用的其他所有线程挂起），会将新生代的对象爱嗯挪动到老年代;</li><li>每次回收老年代对象时均会回收永久代的对象。当他们满的时候就会触发回收操作。</li></ol><h1 id="六-non-heap-memory-非堆内存"><a class="header-anchor" href="#六-non-heap-memory-非堆内存"></a>六、Non-Heap Memory（非堆内存）</h1><p>非堆内存包含下列这些:</p><ol><li>永久代<ol><li>方法区</li><li>字符串区</li></ol></li><li>代码缓存用于存放被JIT编译器编译为本地代码的方法。</li></ol><h1 id="七-just-in-time-jit-compilation-jit编译"><a class="header-anchor" href="#七-just-in-time-jit-compilation-jit编译"></a>七、Just In Time (JIT) Compilation（JIT编译）</h1><p>Java的字节码是解析执行的，速度比CPU本地代码差远了。为了提高Java程序的执行效率，Oracle的Hotspot虚拟机将需要经常执行的字节码编译成本地代码并存放在代码缓存当中。Hotspot虚拟机会自动权衡解析执行字节码和将字节码编译成本地代码再执行之间的效率，然后选择最优方案。</p><h1 id="八-method-area-方法区"><a class="header-anchor" href="#八-method-area-方法区"></a>八、Method Area（方法区）</h1><p>方法区存放每个类的信息，具体如下：</p><ol><li>类加载器引用</li><li>运行时常量池　　1. 数字常量</li><li>字段引用</li><li>方法引用</li><li>属性</li><li>字段数据，每个字段包含以下信息<ol><li>名称</li><li>类型</li><li>修饰符</li><li>属性</li></ol></li><li>方法数据，每个方法包含以下信息<ol><li>名称</li><li>返回值类型</li><li>入参的数据类型（保持入参的次序）</li><li>修饰符</li><li>属性</li></ol></li><li>方法代码，每个方法包含以下信息<ol><li>字节码</li><li>操作数栈容量</li><li>局部变量表容量</li><li>局部变量表</li><li>异常表，每个异常表项包含以下信息<ol><li>起始地址</li><li>结束地址</li><li>异常处理代码的地址</li><li>异常类在常量池的地址所有线程均访问同一个方法区，因此方法区的数据访问和动态链接操作必须是线程安全才行。假如两个线程试图访问某个未加载的类的字段或方法时，则会先挂起这两个线程，等该类加载完后继续执行。</li></ol></li></ol></li></ol><h1 id="九-class-file-structure-class文件结构"><a class="header-anchor" href="#九-class-file-structure-class文件结构"></a>九、 Class File Structure（Class文件结构）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4            magic;</span><br><span class="line">    u2            minor_version;</span><br><span class="line">    u2            major_version;</span><br><span class="line">    u2            constant_pool_count;</span><br><span class="line">    cp_info        contant_pool[constant_pool_count – 1];</span><br><span class="line">    u2            access_flags;</span><br><span class="line">    u2            this_class;</span><br><span class="line">    u2            super_class;</span><br><span class="line">    u2            interfaces_count;</span><br><span class="line">    u2            interfaces[interfaces_count];</span><br><span class="line">    u2            fields_count;</span><br><span class="line">    field_info        fields[fields_count];</span><br><span class="line">    u2            methods_count;</span><br><span class="line">    method_info        methods[methods_count];</span><br><span class="line">    u2            attributes_count;</span><br><span class="line">    attribute_info    attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>magic</em>、<em>minor_version</em>、<em>major_version</em>：用于声明JDK版本</p><p><em>constant_pool</em>：类似符号表，但包含更多的信息</p><p><em>access_flags</em>：存放该类的描述符列表</p><p><em>this_class</em>：指向constant_pool中CONSTANT_Class_info类型常量的索引，该常量存放的是符号引用到当前类（如org/jamesdbloom/foo/bar）</p><p><em>super_class</em>：指向constant_pool中CONSTANT_Class_info类型常量的索引，该常量存放的是符号引用到超类（如java/lang/Object）</p><p><em>interfaces</em>：一组指向constant_pool中CONSTANT_Class_info类型常量的索引，该类常量存放的是符号引用到接口</p><p><em>fields</em>：字段表，一个表项代表一个字段，表项的子项信息均有constant_pool提供。</p><p><em>methods</em>：方法表，一个表项代表一个方法，表项的子项信息均有constant_pool提供。</p><p><em>attributes</em>：属性表，表项用于类提供额外的信息。java代码中通过注解（约束为RetentionPolicy.CLASS或RetentionPolicy.RUNTIME的annotation）提供</p><p>通过<code>javap</code>命令我们可以查看解析后的字节码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">// java</span><br><span class="line">package org.jvminternals;</span><br><span class="line"></span><br><span class="line">public class SimpleClass &#123;</span><br><span class="line"></span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        System.out.println(&quot;Hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// shell or cmd</span><br><span class="line">javap -v -p -s -sysinfo -constants classes/org/jvminternals/SimpleClass.class</span><br><span class="line"></span><br><span class="line">// Bytecodes</span><br><span class="line">public class org.jvminternals.SimpleClass</span><br><span class="line">  SourceFile: &quot;SimpleClass.java&quot;</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 51</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #6.#17         //  java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #18.#19        //  java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #3 = String             #20            //  &quot;Hello&quot;</span><br><span class="line">   #4 = Methodref          #21.#22        //  java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Class              #23            //  org/jvminternals/SimpleClass</span><br><span class="line">   #6 = Class              #24            //  java/lang/Object</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lorg/jvminternals/SimpleClass;</span><br><span class="line">  #14 = Utf8               sayHello</span><br><span class="line">  #15 = Utf8               SourceFile</span><br><span class="line">  #16 = Utf8               SimpleClass.java</span><br><span class="line">  #17 = NameAndType        #7:#8          //  &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #18 = Class              #25            //  java/lang/System</span><br><span class="line">  #19 = NameAndType        #26:#27        //  out:Ljava/io/PrintStream;</span><br><span class="line">  #20 = Utf8               Hello</span><br><span class="line">  #21 = Class              #28            //  java/io/PrintStream</span><br><span class="line">  #22 = NameAndType        #29:#30        //  println:(Ljava/lang/String;)V</span><br><span class="line">  #23 = Utf8               org/jvminternals/SimpleClass</span><br><span class="line">  #24 = Utf8               java/lang/Object</span><br><span class="line">  #25 = Utf8               java/lang/System</span><br><span class="line">  #26 = Utf8               out</span><br><span class="line">  #27 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #28 = Utf8               java/io/PrintStream</span><br><span class="line">  #29 = Utf8               println</span><br><span class="line">  #30 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  public org.jvminternals.SimpleClass();</span><br><span class="line">    Signature: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">        0: aload_0</span><br><span class="line">        1: invokespecial #1    // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        4: return</span><br><span class="line">    LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">    LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">          0      5      0    this   Lorg/jvminternals/SimpleClass;</span><br><span class="line"></span><br><span class="line">  public void sayHello();</span><br><span class="line">    Signature: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">        0: getstatic      #2    // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        3: ldc            #3    // String &quot;Hello&quot;</span><br><span class="line">        5: invokevirtual  #4    // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        8: return</span><br><span class="line">    LineNumberTable:</span><br><span class="line">        line 6: 0</span><br><span class="line">        line 7: 8</span><br><span class="line">    LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">          0      9      0    this   Lorg/jvminternals/SimpleClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码显示三个主要的区域：常量池、构造函数和sayHello方法。常量池：提供类似于符号表的信息。方法：每个方法均含四个区域  1. 签名和访问标志；  2. 方法体的字节码；  3. 行号表：为调试器提供Java代码与字节码的行号映射关系信息。  4. 局部变量表：罗列当且当前方法的所有局部变量名。</p><p>（译者语：由于后续内容为对字节码指令的讲解，没什么必要翻译了所以…）</p><h1 id="十-classloader-类加载器"><a class="header-anchor" href="#十-classloader-类加载器"></a>十、Classloader（类加载器）</h1><p>JVM启动时通过bootstrap classloader加载初始类。在执行 public static void main(String[]) 方法前，这个类需要经过链接、初始化操作。然后在执行这个方法时就会触发其他类和接口的加载、链接和初始化操作。<strong>加载</strong>，通过特定的名称搜索类或接口文件，并将其内容加载为字节数组。（译者语：这里加载的工作已经完成了，后面内容是加载+链接的内容）然后字节数组被解析为符合Java版本号的类对象（如Object.class），而该类或接口的直接父类和直接父接口也会被加载。</p><p><strong>链接</strong>，由验证Class文件合法性、准备和可选的解析三个步骤组成。</p><p>1. <strong>验证</strong>，就是要根据Java和JVM规范对类或接口字节码的格式和语义进行校验。下面罗列部分校验项：　　　　1.1. 符号表具有一致和合法的格式；　　　　1.2. 不可更改的方法和类没有被重写；　　　　1.3. 方法含有效的访问控制关键字；　　　　1.4. 方法含有效的入参类型和数目；　　　　1.5. 字节码没有对操作数栈进行非法操作；　　　　1.6. 变量先初始化后使用；　　　　1.7. 变量值与变量类型匹配。　　　　在类加载阶段进行验证虽然会减慢加载速度，但可以减少运行时对同一类或接口进行重复验证。　　2. <strong>准备</strong>，为静态字段、静态方法和如方法表等JVM使用的数据分配内存空间，并对静态字段进行初始化。但这个时候该类或接口的构造函数、静态构造函数和方法均没有被执行。　　3. <strong>解析（可选项）</strong>，检查符号引用并加载所引用的类或接口（加载直接父类和直接接口）。当没有执行这一步骤时，则在运行时中调用这个类或接口时在执行。<strong><em>*初始化*</em></strong>，执行类的静态构造函数 <clinit> 。</clinit></p><p><img src="/2017/02/11/JVM-Internals/291732492223926.png" alt="img"></p><p>JVM中有多个不同类型的类加载器。bootstrap classloader是顶层的类加载器，其他类加载器均继承自它。　　1. <strong>Bootstrap Classloader</strong>，由于在JVM加载时初始化，因此Bootstrap Classloader是用C++编写的。用于加载Java的核心API，如rt.jar等位于boot类路径的高信任度的类，而这些类在链接时需要的校验步骤比一般类要少不止一点点。　　2. <strong>Extenson Classloader</strong>，用于加载Java的扩展APIs。　　3. <strong>System Classloader</strong>，默认的应用类加载器，用于从classpath中加载应用的类。　　4. <strong>User Defined Classloaders</strong>，应用内部按一定的需求将对类分组加载或对类进行重新加载。</p><p><img src="/2017/02/11/JVM-Internals/291734151596947.png" alt="img"></p><h1 id="十一-faster-class-loading-更快的类加载"><a class="header-anchor" href="#十一-faster-class-loading-更快的类加载"></a>十一、Faster Class Loading（更快的类加载）</h1><p>从HotSpot5.0开始引入了共享类数据（CDS）特性。在安装JVM时则会将如rt.jar中的类加载到一个内存映射共享文档中。然后各JVM实例启动时直接读取该内存中的类，提高JVM的启动速度。</p><h1 id="十二-where-is-the-method-area-方法区在哪？"><a class="header-anchor" href="#十二-where-is-the-method-area-方法区在哪？"></a>十二、 Where Is The Method Area（方法区在哪？）</h1><p>《Java Virtual Machine Specification Java SE 7 Edition》明确声明：“虽然方法区逻辑上位于堆中，简单的实现方式应该是被垃圾回收。”矛盾的是Oracle JVM的jconsole告知我们方法区和代码缓存是位于非堆内存空间中的。而OpenJDK则将代码缓存设置为虚拟机外的ObjectHeap中。</p><h1 id="十三-classloader-reference-类加载器引用"><a class="header-anchor" href="#十三-classloader-reference-类加载器引用"></a>十三、Classloader Reference（类加载器引用）</h1><p>每个类都持有一个指向加载它的类加载器指针，同样每个类加载都持有一组由它加载的类的指引。</p><h1 id="十四-run-time-constant-pool-运行时常量池"><a class="header-anchor" href="#十四-run-time-constant-pool-运行时常量池"></a>十四、Run Time Constant Pool（运行时常量池）</h1><p>每个类都对应一个运行时常量池（有Class文件中的常量池生成）。运行时常量池与符号表类似但包含更多的信息。字节码指令中需要对数据进行操作，但由于数据太大无法直接存放在字节码指令当中，于是通过将数据存放在常量池，而字节码指令存放数据位于常量池的索引值来实现指令对数据的操作。动态链接也是通过运行时常量池来实现的。  运行时常量池包含以下的类型的数据：</p><ol><li><p>数字字面量；</p></li><li><p>字符串字面量；</p></li><li><p>类引用；</p></li><li><p>字段引用；</p></li><li><p>方法引用。</p><p>举个栗子：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// java</span><br><span class="line">Object foo = new Object();</span><br><span class="line"></span><br><span class="line">// bytecodes</span><br><span class="line">0:     new #2             // Class java/lang/Object</span><br><span class="line">1:    dup</span><br><span class="line">2:    invokespecial #3    // Method java/ lang/Object &quot;&lt;init&gt;&quot;()V</span><br></pre></td></tr></table></figure><p><code>new</code>操作码后的#2操作数就是常量池第2项的索引，该项为类型引用，内含一个缩略UTF8类型的常量来存放类的全限定名（java/lang/Object）。在进行动态符号链接时则通过该名称来查找类对象<code>java.lang.Object</code>。而<code>new</code>操作码会创建一个类的实例、初始化实例的字段，并将该对象压入操作数栈。<code>dup</code>复制栈顶元素并压栈，然后<code>invokespecial</code>则弹出操作数栈顶的一个元素执行对象的构造函数。</p><p>再举个栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// java</span><br><span class="line">package org.jvminternals;</span><br><span class="line"></span><br><span class="line">public class SimpleClass &#123;</span><br><span class="line"></span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        System.out.println(&quot;Hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Bytecodes</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #6.#17         //  java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #18.#19        //  java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #3 = String             #20            //  &quot;Hello&quot;</span><br><span class="line">   #4 = Methodref          #21.#22        //  java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Class              #23            //  org/jvminternals/SimpleClass</span><br><span class="line">   #6 = Class              #24            //  java/lang/Object</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lorg/jvminternals/SimpleClass;</span><br><span class="line">  #14 = Utf8               sayHello</span><br><span class="line">  #15 = Utf8               SourceFile</span><br><span class="line">  #16 = Utf8               SimpleClass.java</span><br><span class="line">  #17 = NameAndType        #7:#8          //  &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #18 = Class              #25            //  java/lang/System</span><br><span class="line">  #19 = NameAndType        #26:#27        //  out:Ljava/io/PrintStream;</span><br><span class="line">  #20 = Utf8               Hello</span><br><span class="line">  #21 = Class              #28            //  java/io/PrintStream</span><br><span class="line">  #22 = NameAndType        #29:#30        //  println:(Ljava/lang/String;)V</span><br><span class="line">  #23 = Utf8               org/jvminternals/SimpleClass</span><br><span class="line">  #24 = Utf8               java/lang/Object</span><br><span class="line">  #25 = Utf8               java/lang/System</span><br><span class="line">  #26 = Utf8               out</span><br><span class="line">  #27 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #28 = Utf8               java/io/PrintStream</span><br><span class="line">  #29 = Utf8               println</span><br><span class="line">  #30 = Utf8               (Ljava/lang/String;)V</span><br></pre></td></tr></table></figure><p>Class的常量池包含以下类型：</p><p>Integer一个4bytes的整型常量Long 　　    一个8bytes的长整型常量Float　　     一个4bytes的浮点型常量Double　　  一个4bytes的双精度浮点型常量String　　  字符串引用，指向一个缩略Utf8常量Utf8 　　    缩略Utf8编码的字符串Class　　   类型引用，指向一个缩略Utf8常量，存放类全限定名（用于动态链接）NameAndType 存放两个引用，一个指向用于存放字段或方法名的缩略Utf8常量，一个指向存放字段数据类型或方法返回值类型和入参的缩略Utf8常量Fieldref,          存放两个引用，一个指向表示所属类或接口的Class常量，一个指向描述字段、方法名称和描述符的NameAndType常量Methodref,InterfaceMethodref</p><h1 id="十五-exception-table-异常表"><a class="header-anchor" href="#十五-exception-table-异常表"></a>十五、Exception Table（异常表）</h1><p>异常表的每一项表示一项异常处理，表项字段如下：起始位置、结束位置、处理代码的起始位置和指向常量池Class常量的位置索引。</p><p>只要Java代码中出现try-catch或try-finally的异常处理时，就会创建异常表，异常表的表项用于存放try语句块在字节码指令集中的范围、捕捉的异常类和相应的字节码处理指令的起始位置。（译者注：try-finally所创建的表项的异常类引用为0）</p><p>当发生异常并没有被捕获处理，则会从线程栈的当前栈帧抛出并触发弹栈操作，再栈顶栈帧接收，直到异常被某个栈帧捕获处理或该线程栈为空并退出线程然后异常有系统异常处理机制捕获。</p><p>finally语句块的代码无论是否抛出异常均会执行。</p><h1 id="十六-symbol-table-符号表"><a class="header-anchor" href="#十六-symbol-table-符号表"></a>十六、Symbol Table（符号表）</h1><p>HotSpot虚拟机在永久代中增加了符号表。该表为哈希表用于将直接引用与运行时常量池的符号引用作映射。</p><p>另外每个表项还有个引用计数器，用来记录有多少个符号引用指向同一个直接引用。假如某个类被卸载了那么类中的所有符号引用将无效，则对应的符号表表项的引用计数器减1，当计数器为0时则将该表项移除。</p><h1 id="十七-interned-strings-string-table-字符串表"><a class="header-anchor" href="#十七-interned-strings-string-table-字符串表"></a>十七、 Interned Strings (String Table)（字符串表）</h1><p>Java语言说明中要求字符串字面量必须唯一，一样的字符串字面量必须为同一个String实例。</p><p>HotSport虚拟机通过字符串表来实现。字符串表位于永久代中，表项为String实例地址与字符串字面量的映射关系信息。加载类时成功执行链接的准备阶段时，Class文件常量池下的CONSTANT_String_info常量的信息均加载到字符串表中。而执行阶段可以通过String#intern()方法将字符串字面量加入到字符串表中。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new String(&quot;jvm&quot;) == &quot;jvm&quot;; // false</span><br><span class="line">(new String(&quot;jvm&quot;)).intern() == &quot;jvm&quot;; // true</span><br></pre></td></tr></table></figure><p>String#intern()，会先去字符串表查找字面量相同的表项，有则返回对应的对象引用，没有则先将新的字符串对象和字面量添加到表中，然后再返回对象引用。</p><h1 id="总结"><a class="header-anchor" href="#总结"></a>总结</h1><p>本文对JVM内存模型做了概要的说明，让初次接触JVM的朋友对它有一个初步的big photo，在此感谢作者的分享。</p><h1 id="转载链接"><a class="header-anchor" href="#转载链接"></a>转载链接</h1><p>尊重原创，转载请注明来自：<a href="http://www.cnblogs.com/fsjohnhuang/p/4260417.html" target="_blank" rel="noopener">http://www.cnblogs.com/fsjohnhuang/p/4260417.html</a>  <sup>_</sup>肥仔John</p><p>原文地址：<a href="http://blog.jamesdbloom.com/JVMInternals.html" target="_blank" rel="noopener">http://blog.jamesdbloom.com/JVMInternals.html</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存模型 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>看起来简单的通知推送服务，真的简单吗</title>
      <link href="/2016/05/31/%E7%9C%8B%E8%B5%B7%E6%9D%A5%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%9A%E7%9F%A5%E6%8E%A8%E9%80%81%E6%9C%8D%E5%8A%A1%EF%BC%8C%E7%9C%9F%E7%9A%84%E7%AE%80%E5%8D%95%E5%90%97/"/>
      <url>/2016/05/31/%E7%9C%8B%E8%B5%B7%E6%9D%A5%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%9A%E7%9F%A5%E6%8E%A8%E9%80%81%E6%9C%8D%E5%8A%A1%EF%BC%8C%E7%9C%9F%E7%9A%84%E7%AE%80%E5%8D%95%E5%90%97/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a class="header-anchor" href="#背景"></a>背景</h1><p>目前OneAlert提供短信、邮件、电话、APP四种通知通道，其中前三种的使用量最高(90%以上的用户)，因此靠谱的第三方推送提供商至关重要。经过对各种三方推送服务的公司调研，目前锁定了阿里大鱼<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>、容联云<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>、云片<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>、云之讯<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>、SendCloud<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>，这5家平台提供商。</p><p>首先我们来分析一下接入三方后的通讯模型</p><p><img src="/2016/05/31/看起来简单的通知推送服务，真的简单吗/%E6%8E%A8%E9%80%81%E6%A8%A1%E5%9E%8B.svg" alt="推送模型"></p><blockquote><p>注：配额这里是指三方服务商的发送限制，比如每小时最多每个电话拨打几次</p></blockquote><a id="more"></a><p>我们作为一个服务提供商，必然要确保用户的告警可以准确、准时、不漏的投递给用户，这个问题看起来一目了然，没什么难度，其实不然，我们分析下以上通信模型中的几种情况：</p><h2 id="s1-发送成功"><a class="header-anchor" href="#s1-发送成功"></a>s1:发送成功</h2><p>最好的情况（这里由于无法真正的监控第三方是否真正投递到了用户，不过根据以往的工单经验，丢失的概率很小）</p><h2 id="s2-超出配额"><a class="header-anchor" href="#s2-超出配额"></a>s2:超出配额</h2><h3 id="换个重发"><a class="header-anchor" href="#换个重发"></a>换个重发</h3><p>超出配额，那就换个重发呗？这是下意识的解决思路，我们看看有什么问题：</p><p><img src="/2016/05/31/看起来简单的通知推送服务，真的简单吗/%E8%B6%85%E5%87%BA%E9%85%8D%E9%A2%9D.svg" alt="超出配额"></p><h3 id="独立状态服务"><a class="header-anchor" href="#独立状态服务"></a>独立状态服务</h3><p>很直观的发现，重试的次数有可能会很多，这非常影响推送实时性。马上，我们又会想到可以对每次超出配额的情况进行缓存，提炼一个状态服务，如下：</p><p><img src="/2016/05/31/看起来简单的通知推送服务，真的简单吗/%E8%B6%85%E5%87%BA%E9%85%8D%E9%A2%9D_%E6%8E%A8%E9%80%81%E6%9C%8D%E5%8A%A1%E5%95%86%E9%85%8D%E9%A2%9D%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1.svg" alt="超出配额_推送服务商配额状态服务"></p><p>问题到此为止，一切美好已经发生… 遗憾的是，该状态服务几乎是不可用的。我们可以进一步思考：</p><p>当第一次配额超出的情况发生时，按照上面的设计，该状态服务会缓存下来；</p><p>当第二次推送来临时，会首先请求状态服务，拿到配额超出的那个服务商，排除掉它，使用其他服务商发送</p><p>当第三次推送来临时，会首先请求状态服务，拿到配额超出的那个服务商，排除掉它，使用其他服务商发送</p><p>…</p><p>当第n次推送…</p><p>此时问题一目了然，某个三方服务商第一次超出配额后就不再被请求了，这显然不是我们要的。如果我们试图及时、恰当的让某超出配额的状态失效掉，问题是我们如何知道什么时间或者哪一次请求时让其失效呢？</p><h3 id="小结"><a class="header-anchor" href="#小结"></a>小结</h3><p>目前看来，针对简单的请求-重试模型是很难解决我们的问题的。</p><h1 id="换个思路"><a class="header-anchor" href="#换个思路"></a>换个思路</h1><p>上面所有的方案每次发送都是无状态的，如果我们对每个时间段每次发送用的哪个服务商记录下来，结合配额限制，这样是不是可以做到避免处罚超出配额的问题呢？</p><p>我们来分析下：</p><p><img src="/2016/05/31/看起来简单的通知推送服务，真的简单吗/%E8%B6%85%E5%87%BA%E9%85%8D%E9%A2%9D_%E8%AE%B0%E5%BD%95%E6%8E%A8%E9%80%81%E7%8A%B6%E6%80%81.svg" alt="超出配额_记录推送状态"></p><p>嗯… 此时貌似已经解决了问题。不过从设计来看，NotifySender职责太多了，既要负责发送消息，又得记录发送状态，不符合单一职责原则。如果将来对三方服务商做增加、下线操作，还要动NotifySender，显然是不合理的。</p><h2 id="小结-v2"><a class="header-anchor" href="#小结-v2"></a>小结</h2><p>通过有状态的发送，解决了配额问题，但NotifySender职责太多，不利于拓展，需要再次设计。</p><h1 id="最后方案"><a class="header-anchor" href="#最后方案"></a>最后方案</h1><p>事实上，我们需要一个这样的服务，它能根据三方服务商目前的配额情况，自动的给我们的消息路由到合适的服务商。</p><blockquote><p>实质上，对于每次发送「计数」这件事，其实可以换一个角度思考，我们只要确保在单位时间内，按照配额作为权重将消息分发给服务商即可，这样也能确保不会触发超出配额异常。</p><p>由于篇幅关系，这里不对轮询算法进行展开讨论，而且本身算法不是重点，此类算法网上一搜一大堆，笔者也不想赘述，重要的是我们对业务场景进行实质分析。</p><p>ok，直接给出结论：加权轮询算法（如果读者有兴趣，可以给我发邮件，我们一起讨论: P）</p></blockquote><p><img src="/2016/05/31/看起来简单的通知推送服务，真的简单吗/%E8%B6%85%E5%87%BA%E9%85%8D%E9%A2%9D_%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2%E6%96%B9%E6%A1%88.svg" alt="超出配额_加权轮询方案"></p><p>对调度服务的补充解释：</p><p>我们选择将服务商信息存放在配置中心里，主要考虑了以下几点：</p><ul><li>如果服务商将来由于各种原因维护，我们只需要从配置中心去掉这个服务商即可，NotifySender不需要做任何改动</li><li>如果服务商将来更改了配额，我们只需要在配置中心重新配置一下这个服务商的配额信息即可，NotifySender也不需要做任何改动</li></ul><h1 id="reference"><a class="header-anchor" href="#reference"></a>Reference</h1><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://dayu.aliyun.com" target="_blank" rel="noopener">https://dayu.aliyun.com</a> 阿里大鱼 <a href="#fnref1" class="footnote-backref">↩</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://www.yuntongxun.com/" target="_blank" rel="noopener">https://www.yuntongxun.com/</a> 容联云 <a href="#fnref2" class="footnote-backref">↩</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://www.yunpian.com" target="_blank" rel="noopener">https://www.yunpian.com</a> 云片 <a href="#fnref3" class="footnote-backref">↩</a></p></li><li id="fn4" class="footnote-item"><p><a href="https://www.ucpaas.com" target="_blank" rel="noopener">https://www.ucpaas.com</a> 云之讯 <a href="#fnref4" class="footnote-backref">↩</a></p></li><li id="fn5" class="footnote-item"><p><a href="https://sendcloud.sohu.com/" target="_blank" rel="noopener">https://sendcloud.sohu.com/</a> SendCloud <a href="#fnref5" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 业务场景 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通知推送 </tag>
            
            <tag> 轮询算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java集合源码剖析目录</title>
      <link href="/2015/06/04/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%9B%AE%E5%BD%95/"/>
      <url>/2015/06/04/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<ol><li><p><a href="http://houqian.xyz/2015/05/14/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8B%E6%A0%B8%E5%BF%83%E6%8E%A5%E5%8F%A3/">Java集合源码剖析之核心接口</a></p></li><li><p><a href="http://houqian.xyz/2015/06/03/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8BArrayList/">Java集合源码剖析之ArrayList</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 源码剖析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java集合 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java集合源码剖析之ArrayList</title>
      <link href="/2015/06/03/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8BArrayList/"/>
      <url>/2015/06/03/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8BArrayList/</url>
      
        <content type="html"><![CDATA[<p>此为 <a href="http://houqian.xyz/2015/06/04/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%9B%AE%E5%BD%95/">Java集合源码剖析</a>系列的一部分</p><h1 id="简介"><a class="header-anchor" href="#简介"></a>简介</h1><p>ArrayList属于线性表的一种，底层由数组实现。相对于数组，它具有动态扩容的能力，也可以称其为动态数组。</p><h1 id="继承体系"><a class="header-anchor" href="#继承体系"></a>继承体系</h1><p><img src="/2015/06/03/Java集合源码剖析之ArrayList/ArrayList%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.svg" alt="ArrayList继承关系"></p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 源码剖析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java集合 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java集合源码剖析之核心接口</title>
      <link href="/2015/05/14/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8B%E6%A0%B8%E5%BF%83%E6%8E%A5%E5%8F%A3/"/>
      <url>/2015/05/14/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8B%E6%A0%B8%E5%BF%83%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p>此为 <a href="http://houqian.xyz/2015/06/04/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%9B%AE%E5%BD%95/">Java集合源码剖析</a>系列的一部分</p><h1 id="背景"><a class="header-anchor" href="#背景"></a>背景</h1><p>最近把Javadoc精读了一遍，发现许多概念和自己印象里的不一致（记忆掺杂了各种想当然的假设，以及容易受到各种其他因素的干扰，因此和事实会产生许多不一致）。还是很有必要将其系统的梳理一下的，魔鬼在细节，虽然有点儿枯燥，但花些功夫矫正偏差是很有必要的。</p><h1 id="引言"><a class="header-anchor" href="#引言"></a>引言</h1><p>Java集合位于java.util包下，主要分为两大类：字典、线性表。其核心接口如下：</p><p><img src="/2015/05/14/Java集合源码剖析之核心接口/Java%E9%9B%86%E5%90%88%E6%A0%B8%E5%BF%83%E6%8E%A5%E5%8F%A3-9580177.svg" alt="Java集合核心接口"></p><a id="more"></a><h1 id="线性表类"><a class="header-anchor" href="#线性表类"></a>线性表类</h1><h2 id="iterable"><a class="header-anchor" href="#iterable"></a>Iterable</h2><h3 id="职责"><a class="header-anchor" href="#职责"></a>职责</h3><h3 id="核心方法"><a class="header-anchor" href="#核心方法"></a>核心方法</h3><ul><li>boolean hasNext()如果有更多的元素，则返回true</li><li>E next()返回迭代中的下一个元素。如果已经没有元素会抛出<code>NoSuchElementException</code></li><li>default remove()从底层集合中移除此迭代器返回的最后一个元素(注意，你要删除哪个元素，要先调用<code>next()</code>方法使指针跳过该元素才可以删除)。此方法不可用连续调用。<ul><li>如果该iterator不允许删除元素，抛出<code>UnsupportedOperationException</code></li><li>如果调用<code>remove()</code>前没有调用<code>next()</code>，或者是<code>next()</code>后调用2次<code>remove()</code>，抛出<code>UnsupportedOperationException</code></li></ul></li><li>default void forEachRemaining(Consumer&lt;? super E&gt; action)对每个元素执行action方法<ul><li>如果action==null,抛出<code>NullPointerException</code></li></ul></li></ul><blockquote><p>笔者发现这种线性描述不利于后期查看，不过这东西见仁见智，因此此处姑且放上这么一段。但是之后的所有情况都以二维表格的形式记录。</p></blockquote><h2 id="collection"><a class="header-anchor" href="#collection"></a>Collection</h2><h3 id="职责-v2"><a class="header-anchor" href="#职责-v2"></a>职责</h3><p>所有的线性表类、接口都继承该接口。有些集合允许重复元素而其他集合则不允许。有些是有序的，有些是无序的。JDK不提供此接口的任何直接实现：它提供了更具体的子接口（如Set和List）的实现。此接口通常用于在需要最大通用性的情况下，传递集合并对其进行操作。</p><p>所有通用Collection实现类（通常通过其子接口间接实现Collection）应提供两个“标准”构造函数：</p><ul><li>无参数构造器，它创建并返回一个空集合</li><li>一个参数类型是Collection的构造器，它接收一个集合，并用这个集合创建一个新的集合（两个集合类型不同，主要是用来进行类型转换 ）</li></ul><p>由每个集合子类来决定自己的同步策略。</p><h3 id="核心方法-v2"><a class="header-anchor" href="#核心方法-v2"></a>核心方法</h3><style>  /*基本样式*/  table {      width: 100%; /*表格宽度*/      /*max-width: 65em; *//*表格最大宽度，避免表格过宽*/      border: 1px solid #dedede; /*表格外边框设置*/      margin: 15px auto; /*外边距*/      border-collapse: collapse; /*使用单一线条的边框*/      empty-cells: show; /*单元格无内容依旧绘制边框*/    overflow:scroll;  }  table th,  table td {    height: 35px; /*统一每一行的默认高度*/    border: 1px solid #dedede; /*内部边框样式*/    padding: 0 10px; /*内边距*/  }   table th {      font-weight: bold; /*加粗*/      text-align: center !important; /*内容居中，加上 !important 避免被 Markdown 样式覆盖*/      background: rgba(158,188,226,0.2); /*背景色*/  }  /*隔行变色*/  table tbody tr:nth-child(2n) {      background: rgba(158,188,226,0.12);   }  /*悬浮变色*/  table tr:hover {      background: #efefef;   }  /*表头不换行*/  table th {      white-space: nowrap; /*表头内容强制在一行显示*/  }  /*首列不换行*/  table td:nth-child(1) {      white-space: nowrap;   }</style><table><thead><tr><th style="text-align:left">返回值类型</th><th style="text-align:left">方法</th><th style="text-align:left">职责描述</th><th style="text-align:left">异常</th></tr></thead><tbody><tr><td style="text-align:left"><code>boolean</code></td><td style="text-align:left"><code>add(E e)</code></td><td style="text-align:left">向集合添加指定的元素，如果该集合因为调用该方法而改变，返回true（如果该集合不允许重复并且已经包含了指定的元素，返回false）</td><td style="text-align:left">UnsupportedOperationException- 如果此集合不支持添加操作 <br>ClassCastException - 如果指定元素的类阻止将其添加到此集合中<br> NullPointerException - 如果指定的元素为null且此collection不允许null元素 <br>IllegalArgumentException - 如果元素的某些属性阻止将其添加到此集合中 <br>IllegalStateException - 如果由于插入限制而无法在此时添加元素</td></tr><tr><td style="text-align:left"><code>boolean</code></td><td style="text-align:left"><code>addAll(Collection&lt;? extends E&gt; c)</code></td><td style="text-align:left">将指定集合中的所有元素添加到此集合中</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>void</code></td><td style="text-align:left"><code>clear()</code></td><td style="text-align:left">从此集合中删除所有元素（可选操作）</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>boolean</code></td><td style="text-align:left"><code>contains(Object o)</code></td><td style="text-align:left">如果该集合包含指定的元素，则返回true</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>boolean</code></td><td style="text-align:left"><code>containsAll(Collection&lt;?&gt; c)</code></td><td style="text-align:left">如果该集合包含入参集合的所有元素，则返回true</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>boolean</code></td><td style="text-align:left"><code>equals(Object o)</code></td><td style="text-align:left">将指定对象与此集合进行比较，相等则返回true，反之，false</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>int</code></td><td style="text-align:left"><code>hashCode()</code></td><td style="text-align:left">返回此集合的哈希码值</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>boolean</code></td><td style="text-align:left"><code>isEmpty()</code></td><td style="text-align:left">如果该集合不包含任何元素，则返回true</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>Iterator&lt;E&gt;</code></td><td style="text-align:left"><code>iterator()</code></td><td style="text-align:left">返回该集合的迭代器。（无法保证返回元素的顺序，除非实现类是有序的）</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>default Stream&lt;E&gt;</code></td><td style="text-align:left"><code>parallelStream()</code></td><td style="text-align:left">返回此集合的并行流</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>boolean</code></td><td style="text-align:left"><code>remove(Object o)</code></td><td style="text-align:left">从此集合中移除指定元素的单个实例（如果存在则删除成功，返回true，反之，false）</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>boolean</code></td><td style="text-align:left"><code>removeAll(Collection&lt;?&gt; c)</code></td><td style="text-align:left">从该集合的元素中删除入参集合的元素</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>default boolean</code></td><td style="text-align:left"><code>removeIf(Predicate&lt;? super E&gt; filter)</code></td><td style="text-align:left">从该集合的元素中删除满足入参Predicate的元素</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>boolean</code></td><td style="text-align:left"><code>retainAll(Collection&lt;?&gt; c)</code></td><td style="text-align:left">仅保留此集合中包含在指定集合中的元素（可选操作）</td><td style="text-align:left">UnsupportedOperationException- 如果此集合不支持retainAll操作 <br>ClassCastException- 如果此集合中的一个或多个元素的类型与指定的集合不兼容（可选）<br>NullPointerException- 如果此集合包含一个或多个null元素，并且指定的集合不允许null元素（可选），或者指定的集合为null</td></tr><tr><td style="text-align:left"><code>int</code></td><td style="text-align:left"><code>size()</code></td><td style="text-align:left">返回此集合中的元素个数（如果集合内元素个数大于Integer.MAX_VALUE，那么只返回Integer.MAX_VALUE）</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>default Spliterator&lt;E&gt;</code></td><td style="text-align:left"><code>spliterator()</code></td><td style="text-align:left">返回此集合的Spliterator（java1.8新增接口，为了对集合进行并行计算，用于对集合进行分区，在stream中使用很多）</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>default Stream&lt;E&gt;</code></td><td style="text-align:left"><code>stream()</code></td><td style="text-align:left">返回该集合的流</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>Object[]</code></td><td style="text-align:left"><code>toArray()</code></td><td style="text-align:left">将该集合转换成Object数组（如果该实现类是有序的，那么返回的数组顺序与之相同；并且返回的数组是新创建的，该集合不会保留数组引用，因此用户可以放心修改数组）</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>&lt;T&gt; T[]</code></td><td style="text-align:left"><code>toArray(T[] a)</code></td><td style="text-align:left">将该集合转换成入参类型的数组（满足toArray()的承诺。对于传入的数组，如果其长度大于该集合的长度，则对多出的部分填充null值）</td><td style="text-align:left"></td></tr></tbody></table><h2 id="list"><a class="header-anchor" href="#list"></a>List</h2><h3 id="职责-v3"><a class="header-anchor" href="#职责-v3"></a>职责</h3><p>有序集合(也称为序列)。这个接口的用户可以精确地控制列表中每个元素插入的位置。用户可以通过其整数索引(列表中的位置)访问元素，并在列表中搜索元素。与集合不同，列表通常允许重复元素。</p><p>List接口提供了一个特殊的迭代器，称为ListIterator，除了迭代器接口提供的常规操作之外，它还允许插入和替换元素，以及双向访问。提供了一个方法来获取从列表中指定位置开始的列表迭代器。</p><p>List接口提供了两个方法来搜索指定的对象。从性能的角度来看，应该谨慎使用这些方法。在许多实现中，它们将执行代价高昂的线性搜索（时间复杂度高）。</p><h3 id="核心方法-v3"><a class="header-anchor" href="#核心方法-v3"></a>核心方法</h3><p>除了包含Collection接口所有方法外，还有以下方法：</p><table><thead><tr><th>返回值类型</th><th>方法</th><th>职责描述</th></tr></thead><tbody><tr><td>boolean</td><td>addAll(int index, Collection&lt;? extends E&gt; c)</td><td>将指定的集合的元素按照原本的顺序插入到指定索引位置。比如list=[1, 2, 3], list2=[5,6,7],list.addAll(1,list2),那么list变成 [1,5,6,7,2,3]</td></tr><tr><td>void</td><td>replaceAll(UnaryOperator<e> operator)</e></td><td>将集合每一个元素替换成operator.apply(元素)的结果</td></tr><tr><td>sort</td><td>sort(Comparator&lt;? super E&gt; c)</td><td>将列表根据制定的比较器进行排序。</td></tr><tr><td>E</td><td>get(int index)</td><td>返回位于该索引的元素</td></tr><tr><td>E</td><td>set(int index, E element)</td><td>将列表index位置的元素替换为element</td></tr><tr><td>E</td><td>add(int index, E element)</td><td>在列表index位置之后插入element，原先位置的元素索引往右移动一位</td></tr><tr><td>E</td><td>remove(int index)</td><td>删除列表index位置的元素，该位置后的元素向左移动一位</td></tr><tr><td>int</td><td>indexOf(Object o)</td><td>返回列表中从左往右首个匹配元素o的索引，如果列表中没有o，返回-1</td></tr><tr><td>int</td><td>lastIndexOf(Object o)</td><td>返回列表中从右往左首个匹配元素o的索引，如果列表中没有o，返回-1</td></tr><tr><td>ListIterato</td><td>listIterator()</td><td>返回该列表的迭代器</td></tr><tr><td>List</td><td>sublist(int fromIndex, int toIndex)</td><td>返回一个列表索引从from到to的视图，对该视图的所有操作本质上都是在操作原列表</td></tr></tbody></table><h2 id="queue"><a class="header-anchor" href="#queue"></a>Queue</h2><h3 id="职责-v4"><a class="header-anchor" href="#职责-v4"></a>职责</h3><h3 id="核心方法-v4"><a class="header-anchor" href="#核心方法-v4"></a>核心方法</h3><h1 id="字典类"><a class="header-anchor" href="#字典类"></a>字典类</h1><h2 id="map"><a class="header-anchor" href="#map"></a>Map</h2><h3 id="职责-v5"><a class="header-anchor" href="#职责-v5"></a>职责</h3><h3 id="核心方法-v5"><a class="header-anchor" href="#核心方法-v5"></a>核心方法</h3><h2 id="sortedmap"><a class="header-anchor" href="#sortedmap"></a>SortedMap</h2><h3 id="职责-v6"><a class="header-anchor" href="#职责-v6"></a>职责</h3><h3 id="核心方法-v6"><a class="header-anchor" href="#核心方法-v6"></a>核心方法</h3><h2 id="navigablemap"><a class="header-anchor" href="#navigablemap"></a>NavigableMap</h2><h3 id="职责-v7"><a class="header-anchor" href="#职责-v7"></a>职责</h3><h3 id="核心方法-v7"><a class="header-anchor" href="#核心方法-v7"></a>核心方法</h3>]]></content>
      
      
      <categories>
          
          <category> 源码剖析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java集合 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
