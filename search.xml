<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Shell编程实战总结]]></title>
      <url>/2017/08/25/shell%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/</url>
      <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 隔一秒检查MySQL在执行的DML语句</span></div><div class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span> </div><div class="line">  sudo mysql --default-character-set=utf8 -h <span class="variable">$&#123;hostname&#125;</span> -P 3306  -u<span class="variable">$&#123;username&#125;</span>  -p<span class="variable">$&#123;password&#125;</span> -e <span class="string">"show processlist"</span> | grep Query; </div><div class="line">sleep 1; </div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 以逗号分隔每一行，取第一列</span></div><div class="line">awk -F, <span class="string">'&#123;print $1&#125;'</span> doufen_uid_name</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 批量行首添加字符串，以后研究下列模式能否实现</span></div><div class="line">vim mode下 </div><div class="line">:%s/^/del user_item__/g</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查看jar包内容</span></div><div class="line">jar -tf xxxx.jar</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 统计一个文件的行数</span></div><div class="line"><span class="comment"># 方法1：先用wc -l算出行数，awk取第一个字段</span></div><div class="line">wc -l filename | awk <span class="string">'&#123;print $1&#125;'</span></div><div class="line"></div><div class="line"><span class="comment"># 方法2：巧用END函数和内置变量NR直接输出行数</span></div><div class="line"><span class="comment"># NR变量可以输出当前行号，END函数是awk读取完文件之后执行的操作，显而易见的在文件的mo行</span></div><div class="line">awk <span class="string">'END&#123;pint NR&#125;'</span> filename</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 如何获取当前脚本的名称？当前路径文件的名称？</span></div><div class="line"><span class="comment"># shell script</span></div><div class="line">basename <span class="variable">$0</span></div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Linux下的进程管理</span></div><div class="line"><span class="comment"># 1. bg,fg,&amp;,ctrl+c, ctrl+z, jobs</span></div><div class="line"><span class="comment"># 查看后台进程任务</span></div><div class="line"><span class="built_in">bg</span></div><div class="line"><span class="comment"># 将一个后台任务唤醒start并切到前台</span></div><div class="line"><span class="built_in">fg</span></div><div class="line"><span class="comment"># 将一个任务转为daemon进程在后台运行</span></div><div class="line">&amp;</div><div class="line"><span class="comment"># 停止当前正在运行的进程</span></div><div class="line">ctrl+c</div><div class="line"><span class="comment"># 将当前进程放到后天并挂起[stop]</span></div><div class="line">ctrl+z</div><div class="line"><span class="comment"># 查看当前用户下的所有后台任务</span></div><div class="line"><span class="built_in">jobs</span></div><div class="line"></div><div class="line"><span class="comment"># 工作流实践</span></div><div class="line"><span class="comment"># 1.vim 打开一个log文件</span></div><div class="line"><span class="comment"># 2.ctrl + z在后台挂起</span></div><div class="line"><span class="comment"># 3.jobs</span></div><div class="line"><span class="comment"># 4.fg + 编号唤醒相应的进程</span></div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 实时的监控网卡流量</span></div><div class="line">iptraf</div></pre></td></tr></table></figure>
<p><img src="/2017/08/25/shell编程实战/iptraf01.png" alt="iptraf01"></p>
<p><img src="/2017/08/25/shell编程实战/iptraf02.png" alt="iptraf02"></p>
<p><a href="http://www.ttlsa.com/linux-command/ss-replace-netstat/" target="_blank" rel="external">网络状态工具SS</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 取出中括号内的内容</span></div><div class="line"><span class="built_in">echo</span> 123[321]123 | cut -d <span class="string">"["</span> -f2 | cut -d <span class="string">"]"</span> -f1</div><div class="line"></div><div class="line">output:</div><div class="line">321</div><div class="line"></div><div class="line"><span class="comment"># cut语法理解：</span></div><div class="line">cut -d 会根据指定的分隔符切分字符串（或者从文件中读取），-f&#123;<span class="variable">$num</span>&#125;的num是按照该分隔符分割后取哪一块内容（也就是分割后是一个字符串数组，你可以根据下标获取期望的子串，只不过该数组下标从）</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 使用VIM去除段落内行尾的空格与tab</span></div><div class="line">:%s<span class="comment">#\s\+$##</span></div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 过滤并高亮</span></div><div class="line">grep --color -C30 <span class="string">'RESPONSE'</span> test.log</div></pre></td></tr></table></figure>
<p><img src="/2017/08/25/shell编程实战/过滤并高亮.png" alt="过滤并高亮"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># osx下利用xargs传参</span></div><div class="line">ls | grep json |grep -v <span class="string">'('</span> |  xargs -I  % cp % <span class="built_in">test</span>/</div><div class="line"><span class="comment"># %%内包起来要执行的命令即可，不需要&#123;&#125;占位符</span></div><div class="line"><span class="comment"># 注意：OSX的xargs与Linux不同</span></div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查看系统中的内存占用 </span></div><div class="line">ps -A --sort -rss -o pid,comm,pmem,rss | less</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查看进程打开的文件句柄数</span></div><div class="line"><span class="keyword">for</span> p <span class="keyword">in</span> $(pidof java); <span class="keyword">do</span> <span class="built_in">echo</span> <span class="string">"PID # <span class="variable">$p</span> has <span class="variable">$(lsof -n -a -p $p|wc -l)</span> fd opened."</span>; <span class="keyword">done</span></div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Linux根据PID查找执行路径及其他详情</span></div><div class="line">ll /proc/PID</div></pre></td></tr></table></figure>
<p><img src="/2017/08/25/shell编程实战/Linux根据PID查找执行路径及其他详情.png" alt="Linux根据PID查找执行路径及其他详情"></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> shell </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
