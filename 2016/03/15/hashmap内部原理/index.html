<!-- build time:Sat Jul 06 2019 22:44:13 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><title>HashMap内部原理 - 且听风吟</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="简介HashMap采用key/value存储结构，每个key对应唯一的value，查询和修改的速度都很快，能达到O(1)的平均时间复杂度。它是非线程安全的，且不保证元素存储的顺序；"><meta name="keywords" content="源码剖析,Java核心,集合"><meta property="og:type" content="article"><meta property="og:title" content="HashMap内部原理"><meta property="og:url" content="http://houqian.xyz/2016/03/15/hashmap内部原理/index.html"><meta property="og:site_name" content="且听风吟"><meta property="og:description" content="简介HashMap采用key/value存储结构，每个key对应唯一的value，查询和修改的速度都很快，能达到O(1)的平均时间复杂度。它是非线程安全的，且不保证元素存储的顺序；"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://houqian.xyz/images/og_image.png"><meta property="og:updated_time" content="2019-07-04T12:31:47.976Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="HashMap内部原理"><meta name="twitter:description" content="简介HashMap采用key/value存储结构，每个key对应唯一的value，查询和修改的速度都很快，能达到O(1)的平均时间复杂度。它是非线程安全的，且不保证元素存储的顺序；"><meta name="twitter:image" content="http://houqian.xyz/images/og_image.png"><link rel="icon" href="/images/favicon.svg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><link rel="stylesheet" href="/css/back-to-top.css"><link rel="stylesheet" href="/css/progressbar.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><link rel="stylesheet" href="/css/style.css"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand is-flex-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/logo.svg" alt="HashMap内部原理" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a> <a class="navbar-item" href="/archives">Archives</a> <a class="navbar-item" href="/categories">Categories</a> <a class="navbar-item" href="/tags">Tags</a> <a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i> </a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i> </a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column is-8-tablet is-8-desktop is-6-widescreen has-order-2 column-main"><div class="card"><div class="card-content article"><div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto"><div class="level-left"><time class="level-item has-text-grey" datetime="2016-03-15T12:18:19.000Z">2016-03-15</time><div class="level-item"><a class="has-link-grey -link" href="/categories/计算机科学与技术/">计算机科学与技术</a></div><span class="level-item has-text-grey">43 分钟 读完 (大约 6417 个字)</span></div></div><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">HashMap内部原理</h1><div class="content"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="/2016/03/15/hashmap内部原理/photo-1522346513757-54c552451fdc.jpeg" alt=""></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>HashMap采用key/value存储结构，每个key对应唯一的value，查询和修改的速度都很快，能达到O(1)的平均时间复杂度。它是非线程安全的，且不保证元素存储的顺序；</p><a id="more"></a><p>实战另见 <a href="http://houqian.xyz/wiki/Java核心/集合/HashMap/">HashMap</a></p><h2 id="继承体系"><a href="#继承体系" class="headerlink" title="继承体系"></a>继承体系</h2><p><img src="/2016/03/15/hashmap内部原理/HashMap.png" alt="img"></p><ul><li>HashMap实现了Cloneable，可以被克隆</li><li>HashMap实现了Serializable，可以被序列化</li><li>HashMap继承自AbstractMap，实现了Map接口，具有Map的所有功能</li></ul><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p><img src="/2016/03/15/hashmap内部原理/HashMap-structure.png" alt="HashMap-structure"></p><p>在Java中，HashMap的实现采用了（数组 + 链表 + 红黑树）的复杂结构，数组的一个元素又称作桶。</p><p>在添加元素时，会根据hash值算出元素在数组中的位置，如果该位置没有元素，则直接把元素放置在此处，如果该位置有元素了，则把元素以链表的形式放置在链表的尾部。</p><p>当一个链表的元素个数达到一定的数量（且数组的长度达到一定的长度）后，则把链表转化为红黑树，从而提高效率。</p><p>数组的查询效率为O(1)，链表的查询效率是O(k)，红黑树的查询效率是O(log k)，k为桶中的元素个数，所以当元素数量非常多的时候，转化为红黑树能极大地提高效率。</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 默认的初始容量为16</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 最大的容量为2的30次方</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 默认的装载因子</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 当一个桶中的元素个数大于等于8时进行树化</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TREEIFY_THRESHOLD = <span class="hljs-number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 当一个桶中的元素个数小于等于6时把树转化为链表</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UNTREEIFY_THRESHOLD = <span class="hljs-number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 当桶的个数达到64的时候才进行树化</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="hljs-number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 数组，又叫作桶（bucket）</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 作为entrySet()的缓存</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 元素的数量</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 修改次数，用于在迭代的时候执行快速失败策略</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 当桶的使用数量达到多少时进行扩容，threshold = capacity * loadFactor</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 装载因子</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><ol><li>容量</li></ol><p>容量为数组的长度，亦即桶的个数，默认为16，最大为2的30次方，当容量达到64时才可以树化。</p><ol start="2"><li>装载因子</li></ol><p>装载因子用来计算容量达到多少时才进行扩容，默认装载因子为0.75。</p><ol start="3"><li>树化</li></ol><p>树化，当容量达到64且链表的长度达到8时进行树化，当链表的长度小于6时反树化。</p><h3 id="Node内部类"><a href="#Node内部类" class="headerlink" title="Node内部类"></a>Node内部类</h3><p>Node是一个典型的单链表节点，其中，hash用来存储key计算得来的hash值。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;</span><br><span class="line">    <span class="hljs-keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TreeNode内部类"><a href="#TreeNode内部类" class="headerlink" title="TreeNode内部类"></a>TreeNode内部类</h3><p>这是一个神奇的类，它继承自LinkedHashMap中的Entry类，关于LInkedHashMap.Entry这个类我们后面再讲。</p><p>TreeNode是一个典型的树型节点，其中，prev是链表中的节点，用于在删除元素的时候可以快速找到它的前置节点。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 位于HashMap中</span></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashMap</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="hljs-comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="hljs-comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="hljs-keyword">boolean</span> red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 位于LinkedHashMap中，典型的双向链表节点</span></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">HashMap</span>.<span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="hljs-keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashMap-构造方法"><a href="#HashMap-构造方法" class="headerlink" title="HashMap()构造方法"></a>HashMap()构造方法</h3><p>空参构造方法，全部使用默认值。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="hljs-comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashMap-int-initialCapacity-构造方法"><a href="#HashMap-int-initialCapacity-构造方法" class="headerlink" title="HashMap(int initialCapacity)构造方法"></a>HashMap(int initialCapacity)构造方法</h3><p>调用HashMap(int initialCapacity, float loadFactor)构造方法，传入默认装载因子。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashMap-int-initialCapacity-构造方法-1"><a href="#HashMap-int-initialCapacity-构造方法-1" class="headerlink" title="HashMap(int initialCapacity)构造方法"></a>HashMap(int initialCapacity)构造方法</h3><p>判断传入的初始容量和装载因子是否合法，并计算扩容门槛，扩容门槛为传入的初始容量往上取最近的2的n次方。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// 检查传入的初始容量是否合法</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="hljs-comment">// 检查装载因子是否合法</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="hljs-keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="hljs-comment">// 计算扩容门槛</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tableSizeFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// 扩容门槛为传入的初始容量往上取最近的2的n次方</span></span><br><span class="line">    <span class="hljs-keyword">int</span> n = cap - <span class="hljs-number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;</span><br><span class="line">    <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put-K-key-V-value-方法"><a href="#put-K-key-V-value-方法" class="headerlink" title="put(K key, V value)方法"></a>put(K key, V value)方法</h3><p>添加元素的入口。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// 调用hash(key)计算出key的hash值</span></span><br><span class="line">    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> h;</span><br><span class="line">    <span class="hljs-comment">// 如果key为null，则hash值为0，否则调用key的hashCode()方法</span></span><br><span class="line">    <span class="hljs-comment">// 并让高16位与整个hash异或，这样做是为了使计算出的hash更分散</span></span><br><span class="line">    <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">               <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K, V&gt;[] tab;</span><br><span class="line">    Node&lt;K, V&gt; p;</span><br><span class="line">    <span class="hljs-keyword">int</span> n, i;</span><br><span class="line">    <span class="hljs-comment">// 如果桶的数量为0，则初始化</span></span><br><span class="line">    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)</span><br><span class="line">        <span class="hljs-comment">// 调用resize()初始化</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="hljs-comment">// (n - 1) &amp; hash 计算元素在哪个桶中</span></span><br><span class="line">    <span class="hljs-comment">// 如果这个桶中还没有元素，则把这个元素放在桶中的第一个位置</span></span><br><span class="line">    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)</span><br><span class="line">        <span class="hljs-comment">// 新建一个节点放在桶中</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);</span><br><span class="line">    <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-comment">// 如果桶中已经有元素存在了</span></span><br><span class="line">        Node&lt;K, V&gt; e;</span><br><span class="line">        K k;</span><br><span class="line">        <span class="hljs-comment">// 如果桶中第一个元素的key与待插入元素的key相同，保存到e中用于后续修改value值</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="hljs-comment">// 如果第一个元素是树节点，则调用树节点的putTreeVal插入元素</span></span><br><span class="line">            e = ((TreeNode&lt;K, V&gt;) p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-comment">// 遍历这个桶对应的链表，binCount用于存储链表中元素的个数</span></span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="hljs-comment">// 如果链表遍历完了都没有找到相同key的元素，说明该key对应的元素不存在，则在链表最后插入一个新节点</span></span><br><span class="line">                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="hljs-keyword">null</span>);</span><br><span class="line">                    <span class="hljs-comment">// 如果插入新节点后链表长度大于8，则判断是否需要树化，因为第一个元素没有加到binCount中，所以这里-1</span></span><br><span class="line">                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="hljs-keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-comment">// 如果待插入的key在链表中找到了，则退出循环</span></span><br><span class="line">                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="hljs-keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">// 如果找到了对应key的元素</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span></span><br><span class="line">            <span class="hljs-comment">// 记录下旧值</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="hljs-comment">// 判断是否需要替换旧值</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)</span><br><span class="line">                <span class="hljs-comment">// 替换旧值为新值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="hljs-comment">// 在节点被访问后做点什么事，在LinkedHashMap中用到</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="hljs-comment">// 返回旧值</span></span><br><span class="line">            <span class="hljs-keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// 到这里了说明没有找到元素</span></span><br><span class="line">    <span class="hljs-comment">// 修改次数加1</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="hljs-comment">// 元素数量加1，判断是否需要扩容</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        <span class="hljs-comment">// 扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    <span class="hljs-comment">// 在节点插入后做点什么事，在LinkedHashMap中用到</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="hljs-comment">// 没找到元素返回null</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>计算key的hash值；</p></li><li><p>如果桶（数组）数量为0，则初始化桶；</p></li><li><p>如果key所在的桶没有元素，则直接插入；</p></li><li><p>如果key所在的桶中的第一个元素的key与待插入的key相同，说明找到了元素，转后续流程（9）处理；</p></li><li><p>如果第一个元素是树节点，则调用树节点的putTreeVal()寻找元素或插入树节点；</p></li><li><p>如果不是以上三种情况，则遍历桶对应的链表查找key是否存在于链表中；</p></li><li><p>如果找到了对应key的元素，则转后续流程（9）处理；</p></li><li><p>如果没找到对应key的元素，则在链表最后插入一个新节点并判断是否需要树化；</p></li><li><p>如果找到了对应key的元素，则判断是否需要替换旧值，并直接返回旧值；</p></li><li><p>如果插入了元素，则数量加1并判断是否需要扩容；</p></li></ol><h3 id="resize-方法"><a href="#resize-方法" class="headerlink" title="resize()方法"></a>resize()方法</h3><p>扩容方法。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">final</span> Node&lt;K, V&gt;[] resize() &#123;</span><br><span class="line">    <span class="hljs-comment">// 旧数组</span></span><br><span class="line">    Node&lt;K, V&gt;[] oldTab = table;</span><br><span class="line">    <span class="hljs-comment">// 旧容量</span></span><br><span class="line">    <span class="hljs-keyword">int</span> oldCap = (oldTab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;</span><br><span class="line">    <span class="hljs-comment">// 旧扩容门槛</span></span><br><span class="line">    <span class="hljs-keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="hljs-keyword">int</span> newCap, newThr = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="hljs-comment">// 如果旧容量达到了最大容量，则不再进行扩容</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="hljs-keyword">return</span> oldTab;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="hljs-comment">// 如果旧容量的两倍小于最大容量并且旧容量大于默认初始容量（16），则容量扩大为两部，扩容门槛也扩大为两倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span></span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span></span><br><span class="line">        <span class="hljs-comment">// 使用非默认构造方法创建的map，第一次插入元素会走到这里</span></span><br><span class="line">        <span class="hljs-comment">// 如果旧容量为0且旧扩容门槛大于0，则把新容量赋值为旧门槛</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="hljs-comment">// 调用默认构造方法创建的map，第一次插入元素会走到这里</span></span><br><span class="line">        <span class="hljs-comment">// 如果旧容量旧扩容门槛都是0，说明还未初始化过，则初始化容量为默认容量，扩容门槛为默认容量*默认装载因子</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="hljs-keyword">int</span>) (DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        <span class="hljs-comment">// 如果新扩容门槛为0，则计算为容量*装载因子，但不能超过最大容量</span></span><br><span class="line">        <span class="hljs-keyword">float</span> ft = (<span class="hljs-keyword">float</span>) newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-keyword">float</span>) MAXIMUM_CAPACITY ?</span><br><span class="line">                (<span class="hljs-keyword">int</span>) ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// 赋值扩容门槛为新门槛</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="hljs-comment">// 新建一个新容量的数组</span></span><br><span class="line">    <span class="hljs-meta">@SuppressWarnings</span>(&#123;<span class="hljs-string">"rawtypes"</span>, <span class="hljs-string">"unchecked"</span>&#125;)</span><br><span class="line">    Node&lt;K, V&gt;[] newTab = (Node&lt;K, V&gt;[]) <span class="hljs-keyword">new</span> Node[newCap];</span><br><span class="line">    <span class="hljs-comment">// 把桶赋值为新数组</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="hljs-comment">// 如果旧数组不为空，则搬移元素</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        <span class="hljs-comment">// 遍历旧数组</span></span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K, V&gt; e;</span><br><span class="line">            <span class="hljs-comment">// 如果桶中第一个元素不为空，赋值给e</span></span><br><span class="line">            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                <span class="hljs-comment">// 清空旧桶，便于GC回收  </span></span><br><span class="line">                oldTab[j] = <span class="hljs-keyword">null</span>;</span><br><span class="line">                <span class="hljs-comment">// 如果这个桶中只有一个元素，则计算它在新桶中的位置并把它搬移到新桶中</span></span><br><span class="line">                <span class="hljs-comment">// 因为每次都扩容两倍，所以这里的第一个元素搬移到新桶的时候新桶肯定还没有元素</span></span><br><span class="line">                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;</span><br><span class="line">                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="hljs-comment">// 如果第一个元素是树节点，则把这颗树打散成两颗树插入到新桶中去</span></span><br><span class="line">                    ((TreeNode&lt;K, V&gt;) e).split(<span class="hljs-keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span></span><br><span class="line">                    <span class="hljs-comment">// 如果这个链表不止一个元素且不是一颗树</span></span><br><span class="line">                    <span class="hljs-comment">// 则分化成两个链表插入到新的桶中去</span></span><br><span class="line">                    <span class="hljs-comment">// 比如，假如原来容量为4，3、7、11、15这四个元素都在三号桶中</span></span><br><span class="line">                    <span class="hljs-comment">// 现在扩容到8，则3和11还是在三号桶，7和15要搬移到七号桶中去</span></span><br><span class="line">                    <span class="hljs-comment">// 也就是分化成了两个链表</span></span><br><span class="line">                    Node&lt;K, V&gt; loHead = <span class="hljs-keyword">null</span>, loTail = <span class="hljs-keyword">null</span>;</span><br><span class="line">                    Node&lt;K, V&gt; hiHead = <span class="hljs-keyword">null</span>, hiTail = <span class="hljs-keyword">null</span>;</span><br><span class="line">                    Node&lt;K, V&gt; next;</span><br><span class="line">                    <span class="hljs-keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="hljs-comment">// (e.hash &amp; oldCap) == 0的元素放在低位链表中</span></span><br><span class="line">                        <span class="hljs-comment">// 比如，3 &amp; 4 == 0</span></span><br><span class="line">                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="hljs-keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                            <span class="hljs-comment">// (e.hash &amp; oldCap) != 0的元素放在高位链表中</span></span><br><span class="line">                            <span class="hljs-comment">// 比如，7 &amp; 4 != 0</span></span><br><span class="line">                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="hljs-keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-keyword">null</span>);</span><br><span class="line">                    <span class="hljs-comment">// 遍历完成分化成两个链表了</span></span><br><span class="line">                    <span class="hljs-comment">// 低位链表在新桶中的位置与旧桶一样（即3和11还在三号桶中）</span></span><br><span class="line">                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="hljs-keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="hljs-comment">// 高位链表在新桶中的位置正好是原来的位置加上旧容量（即7和15搬移到七号桶了）</span></span><br><span class="line">                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="hljs-keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果使用是默认构造方法，则第一次插入元素时初始化为默认值，容量为16，扩容门槛为12；</li><li>如果使用的是非默认构造方法，则第一次插入元素时初始化容量等于扩容门槛，扩容门槛在构造方法里等于传入容量向上最近的2的n次方；</li><li>如果旧容量大于0，则新容量等于旧容量的2倍，但不超过最大容量2的30次方，新扩容门槛为旧扩容门槛的2倍；</li><li>创建一个新容量的桶；</li><li>搬移元素，原链表分化成两个链表，低位链表存储在原来桶的位置，高位链表搬移到原来桶的位置加旧容量的位置；</li></ol><h3 id="TreeNode-putTreeVal-…-方法"><a href="#TreeNode-putTreeVal-…-方法" class="headerlink" title="TreeNode.putTreeVal(…)方法"></a>TreeNode.putTreeVal(…)方法</h3><p>插入元素到红黑树中的方法。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">final</span> TreeNode&lt;K, V&gt; <span class="hljs-title">putTreeVal</span><span class="hljs-params">(HashMap&lt;K, V&gt; map, Node&lt;K, V&gt;[] tab,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">                                <span class="hljs-keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; kc = <span class="hljs-keyword">null</span>;</span><br><span class="line">    <span class="hljs-comment">// 标记是否找到这个key的节点</span></span><br><span class="line">    <span class="hljs-keyword">boolean</span> searched = <span class="hljs-keyword">false</span>;</span><br><span class="line">    <span class="hljs-comment">// 找到树的根节点</span></span><br><span class="line">    TreeNode&lt;K, V&gt; root = (parent != <span class="hljs-keyword">null</span>) ? root() : <span class="hljs-keyword">this</span>;</span><br><span class="line">    <span class="hljs-comment">// 从树的根节点开始遍历</span></span><br><span class="line">    <span class="hljs-keyword">for</span> (TreeNode&lt;K, V&gt; p = root; ; ) &#123;</span><br><span class="line">        <span class="hljs-comment">// dir=direction，标记是在左边还是右边</span></span><br><span class="line">        <span class="hljs-comment">// ph=p.hash，当前节点的hash值</span></span><br><span class="line">        <span class="hljs-keyword">int</span> dir, ph;</span><br><span class="line">        <span class="hljs-comment">// pk=p.key，当前节点的key值</span></span><br><span class="line">        K pk;</span><br><span class="line">        <span class="hljs-keyword">if</span> ((ph = p.hash) &gt; h) &#123;</span><br><span class="line">            <span class="hljs-comment">// 当前hash比目标hash大，说明在左边</span></span><br><span class="line">            dir = -<span class="hljs-number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ph &lt; h)</span><br><span class="line">            <span class="hljs-comment">// 当前hash比目标hash小，说明在右边</span></span><br><span class="line">            dir = <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((pk = p.key) == k || (k != <span class="hljs-keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="hljs-comment">// 两者hash相同且key相等，说明找到了节点，直接返回该节点</span></span><br><span class="line">            <span class="hljs-comment">// 回到putVal()中判断是否需要修改其value值</span></span><br><span class="line">            <span class="hljs-keyword">return</span> p;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((kc == <span class="hljs-keyword">null</span> &amp;&amp;</span><br><span class="line">                <span class="hljs-comment">// 如果k是Comparable的子类则返回其真实的类，否则返回null</span></span><br><span class="line">                (kc = comparableClassFor(k)) == <span class="hljs-keyword">null</span>) ||</span><br><span class="line">                <span class="hljs-comment">// 如果k和pk不是同样的类型则返回0，否则返回两者比较的结果</span></span><br><span class="line">                (dir = compareComparables(kc, k, pk)) == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            <span class="hljs-comment">// 这个条件表示两者hash相同但是其中一个不是Comparable类型或者两者类型不同</span></span><br><span class="line">            <span class="hljs-comment">// 比如key是Object类型，这时可以传String也可以传Integer，两者hash值可能相同</span></span><br><span class="line">            <span class="hljs-comment">// 在红黑树中把同样hash值的元素存储在同一颗子树，这里相当于找到了这颗子树的顶点</span></span><br><span class="line">            <span class="hljs-comment">// 从这个顶点分别遍历其左右子树去寻找有没有跟待插入的key相同的元素</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (!searched) &#123;</span><br><span class="line">                TreeNode&lt;K, V&gt; q, ch;</span><br><span class="line">                searched = <span class="hljs-keyword">true</span>;</span><br><span class="line">                <span class="hljs-comment">// 遍历左右子树找到了直接返回</span></span><br><span class="line">                <span class="hljs-keyword">if</span> (((ch = p.left) != <span class="hljs-keyword">null</span> &amp;&amp;</span><br><span class="line">                        (q = ch.find(h, k, kc)) != <span class="hljs-keyword">null</span>) ||</span><br><span class="line">                        ((ch = p.right) != <span class="hljs-keyword">null</span> &amp;&amp;</span><br><span class="line">                                (q = ch.find(h, k, kc)) != <span class="hljs-keyword">null</span>))</span><br><span class="line">                    <span class="hljs-keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-comment">// 如果两者类型相同，再根据它们的内存地址计算hash值进行比较</span></span><br><span class="line">            dir = tieBreakOrder(k, pk);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode&lt;K, V&gt; xp = p;</span><br><span class="line">        <span class="hljs-keyword">if</span> ((p = (dir &lt;= <span class="hljs-number">0</span>) ? p.left : p.right) == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-comment">// 如果最后确实没找到对应key的元素，则新建一个节点</span></span><br><span class="line">            Node&lt;K, V&gt; xpn = xp.next;</span><br><span class="line">            TreeNode&lt;K, V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">            <span class="hljs-keyword">if</span> (dir &lt;= <span class="hljs-number">0</span>)</span><br><span class="line">                xp.left = x;</span><br><span class="line">            <span class="hljs-keyword">else</span></span><br><span class="line">                xp.right = x;</span><br><span class="line">            xp.next = x;</span><br><span class="line">            x.parent = x.prev = xp;</span><br><span class="line">            <span class="hljs-keyword">if</span> (xpn != <span class="hljs-keyword">null</span>)</span><br><span class="line">                ((TreeNode&lt;K, V&gt;) xpn).prev = x;</span><br><span class="line">            <span class="hljs-comment">// 插入树节点后平衡</span></span><br><span class="line">            <span class="hljs-comment">// 把root节点移动到链表的第一个节点</span></span><br><span class="line">            moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>寻找根节点；</li><li>从根节点开始查找；</li><li>比较hash值及key值，如果都相同，直接返回，在putVal()方法中决定是否要替换value值；</li><li>根据hash值及key值确定在树的左子树还是右子树查找，找到了直接返回；</li><li>如果最后没有找到则在树的相应位置插入元素，并做平衡；</li></ol><h3 id="treeifyBin-方法"><a href="#treeifyBin-方法" class="headerlink" title="treeifyBin()方法"></a>treeifyBin()方法</h3><p>如果插入元素后链表的长度大于等于8则判断是否需要树化。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">treeifyBin</span><span class="hljs-params">(Node&lt;K, V&gt;[] tab, <span class="hljs-keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> n, index;</span><br><span class="line">    Node&lt;K, V&gt; e;</span><br><span class="line">    <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        <span class="hljs-comment">// 如果桶数量小于64，直接扩容而不用树化</span></span><br><span class="line">        <span class="hljs-comment">// 因为扩容之后，链表会分化成两个链表，达到减少元素的作用</span></span><br><span class="line">        <span class="hljs-comment">// 当然也不一定，比如容量为4，里面存的全是除以4余数等于3的元素</span></span><br><span class="line">        <span class="hljs-comment">// 这样即使扩容也无法减少链表的长度</span></span><br><span class="line">        resize();</span><br><span class="line">    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K, V&gt; hd = <span class="hljs-keyword">null</span>, tl = <span class="hljs-keyword">null</span>;</span><br><span class="line">        <span class="hljs-comment">// 把所有节点换成树节点</span></span><br><span class="line">        <span class="hljs-keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K, V&gt; p = replacementTreeNode(e, <span class="hljs-keyword">null</span>);</span><br><span class="line">            <span class="hljs-keyword">if</span> (tl == <span class="hljs-keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);</span><br><span class="line">        <span class="hljs-comment">// 如果进入过上面的循环，则从头节点开始树化</span></span><br><span class="line">        <span class="hljs-keyword">if</span> ((tab[index] = hd) != <span class="hljs-keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TreeNode-treeify-方法"><a href="#TreeNode-treeify-方法" class="headerlink" title="TreeNode.treeify()方法"></a>TreeNode.treeify()方法</h3><p>真正树化的方法。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">treeify</span><span class="hljs-params">(Node&lt;K, V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K, V&gt; root = <span class="hljs-keyword">null</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (TreeNode&lt;K, V&gt; x = <span class="hljs-keyword">this</span>, next; x != <span class="hljs-keyword">null</span>; x = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K, V&gt;) x.next;</span><br><span class="line">        x.left = x.right = <span class="hljs-keyword">null</span>;</span><br><span class="line">        <span class="hljs-comment">// 第一个元素作为根节点且为黑节点，其它元素依次插入到树中再做平衡</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            x.parent = <span class="hljs-keyword">null</span>;</span><br><span class="line">            x.red = <span class="hljs-keyword">false</span>;</span><br><span class="line">            root = x;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            K k = x.key;</span><br><span class="line">            <span class="hljs-keyword">int</span> h = x.hash;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="hljs-keyword">null</span>;</span><br><span class="line">            <span class="hljs-comment">// 从根节点查找元素插入的位置</span></span><br><span class="line">            <span class="hljs-keyword">for</span> (TreeNode&lt;K, V&gt; p = root; ; ) &#123;</span><br><span class="line">                <span class="hljs-keyword">int</span> dir, ph;</span><br><span class="line">                K pk = p.key;</span><br><span class="line">                <span class="hljs-keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -<span class="hljs-number">1</span>;</span><br><span class="line">                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="hljs-number">1</span>;</span><br><span class="line">                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((kc == <span class="hljs-keyword">null</span> &amp;&amp;</span><br><span class="line">                        (kc = comparableClassFor(k)) == <span class="hljs-keyword">null</span>) ||</span><br><span class="line">                        (dir = compareComparables(kc, k, pk)) == <span class="hljs-number">0</span>)</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                <span class="hljs-comment">// 如果最后没找到元素，则插入</span></span><br><span class="line">                TreeNode&lt;K, V&gt; xp = p;</span><br><span class="line">                <span class="hljs-keyword">if</span> ((p = (dir &lt;= <span class="hljs-number">0</span>) ? p.left : p.right) == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="hljs-keyword">if</span> (dir &lt;= <span class="hljs-number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="hljs-keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    <span class="hljs-comment">// 插入后平衡，默认插入的是红节点，在balanceInsertion()方法里</span></span><br><span class="line">                    root = balanceInsertion(root, x);</span><br><span class="line">                    <span class="hljs-keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// 把根节点移动到链表的头节点，因为经过平衡之后原来的第一个元素不一定是根节点了</span></span><br><span class="line">    moveRootToFront(tab, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>从链表的第一个元素开始遍历；</p></li><li><p>将第一个元素作为根节点；</p></li><li><p>其它元素依次插入到红黑树中，再做平衡；</p></li><li><p>将根节点移到链表第一元素的位置（因为平衡的时候根节点会改变）；</p></li></ol><h3 id="get-Object-key-方法"><a href="#get-Object-key-方法" class="headerlink" title="get(Object key)方法"></a>get(Object key)方法</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K, V&gt; e;</span><br><span class="line">    <span class="hljs-keyword">return</span> (e = getNode(hash(key), key)) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K, V&gt; <span class="hljs-title">getNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K, V&gt;[] tab;</span><br><span class="line">    Node&lt;K, V&gt; first, e;</span><br><span class="line">    <span class="hljs-keyword">int</span> n;</span><br><span class="line">    K k;</span><br><span class="line">    <span class="hljs-comment">// 如果桶的数量大于0并且待查找的key所在的桶的第一个元素不为空</span></span><br><span class="line">    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;</span><br><span class="line">            (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        <span class="hljs-comment">// 检查第一个元素是不是要查的元素，如果是直接返回</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="hljs-keyword">return</span> first;</span><br><span class="line">        <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-comment">// 如果第一个元素是树节点，则按树的方式查找</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="hljs-keyword">return</span> ((TreeNode&lt;K, V&gt;) first).getTreeNode(hash, key);</span><br><span class="line"></span><br><span class="line">            <span class="hljs-comment">// 否则就遍历整个链表查找该元素</span></span><br><span class="line">            <span class="hljs-keyword">do</span> &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="hljs-keyword">return</span> e;</span><br><span class="line">            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>计算key的hash值；</p></li><li><p>找到key所在的桶及其第一个元素；</p></li><li><p>如果第一个元素的key等于待查找的key，直接返回；</p></li><li><p>如果第一个元素是树节点就按树的方式来查找，否则按链表方式查找；</p></li></ol><h3 id="TreeNode-getTreeNode-int-h-Object-k-方法"><a href="#TreeNode-getTreeNode-int-h-Object-k-方法" class="headerlink" title="TreeNode.getTreeNode(int h, Object k)方法"></a>TreeNode.getTreeNode(int h, Object k)方法</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">final</span> TreeNode&lt;K, V&gt; <span class="hljs-title">getTreeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// 从树的根节点开始查找</span></span><br><span class="line">    <span class="hljs-keyword">return</span> ((parent != <span class="hljs-keyword">null</span>) ? root() : <span class="hljs-keyword">this</span>).find(h, k, <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">final</span> TreeNode&lt;K, V&gt; <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K, V&gt; p = <span class="hljs-keyword">this</span>;</span><br><span class="line">    <span class="hljs-keyword">do</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> ph, dir;</span><br><span class="line">        K pk;</span><br><span class="line">        TreeNode&lt;K, V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">        <span class="hljs-keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            <span class="hljs-comment">// 左子树</span></span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ph &lt; h)</span><br><span class="line">            <span class="hljs-comment">// 右子树</span></span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((pk = p.key) == k || (k != <span class="hljs-keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="hljs-comment">// 找到了直接返回</span></span><br><span class="line">            <span class="hljs-keyword">return</span> p;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pl == <span class="hljs-keyword">null</span>)</span><br><span class="line">            <span class="hljs-comment">// hash相同但key不同，左子树为空查右子树</span></span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pr == <span class="hljs-keyword">null</span>)</span><br><span class="line">            <span class="hljs-comment">// 右子树为空查左子树</span></span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((kc != <span class="hljs-keyword">null</span> ||</span><br><span class="line">                (kc = comparableClassFor(k)) != <span class="hljs-keyword">null</span>) &amp;&amp;</span><br><span class="line">                (dir = compareComparables(kc, k, pk)) != <span class="hljs-number">0</span>)</span><br><span class="line">            <span class="hljs-comment">// 通过compare方法比较key值的大小决定使用左子树还是右子树</span></span><br><span class="line">            p = (dir &lt; <span class="hljs-number">0</span>) ? pl : pr;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="hljs-keyword">null</span>)</span><br><span class="line">            <span class="hljs-comment">// 如果以上条件都不通过，则尝试在右子树查找</span></span><br><span class="line">            <span class="hljs-keyword">return</span> q;</span><br><span class="line">        <span class="hljs-keyword">else</span></span><br><span class="line">            <span class="hljs-comment">// 都没找到就在左子树查找</span></span><br><span class="line">            p = pl;</span><br><span class="line">    &#125; <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经典二叉查找树的查找过程，先根据hash值比较，再根据key值比较决定是查左子树还是右子树。</p><h3 id="remove-Object-key-方法"><a href="#remove-Object-key-方法" class="headerlink" title="remove(Object key)方法"></a>remove(Object key)方法</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">remove</span><span class="hljs-params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K, V&gt; e;</span><br><span class="line">    <span class="hljs-keyword">return</span> (e = removeNode(hash(key), key, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) == <span class="hljs-keyword">null</span> ?</span><br><span class="line">            <span class="hljs-keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K, V&gt; <span class="hljs-title">removeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">                            <span class="hljs-keyword">boolean</span> matchValue, <span class="hljs-keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K, V&gt;[] tab;</span><br><span class="line">    Node&lt;K, V&gt; p;</span><br><span class="line">    <span class="hljs-keyword">int</span> n, index;</span><br><span class="line">    <span class="hljs-comment">// 如果桶的数量大于0且待删除的元素所在的桶的第一个元素不为空</span></span><br><span class="line">    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;</span><br><span class="line">            (p = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K, V&gt; node = <span class="hljs-keyword">null</span>, e;</span><br><span class="line">        K k;</span><br><span class="line">        V v;</span><br><span class="line">        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="hljs-comment">// 如果第一个元素正好就是要找的元素，赋值给node变量后续删除使用</span></span><br><span class="line">            node = p;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = p.next) != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="hljs-comment">// 如果第一个元素是树节点，则以树的方式查找节点</span></span><br><span class="line">                node = ((TreeNode&lt;K, V&gt;) p).getTreeNode(hash, key);</span><br><span class="line">            <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                <span class="hljs-comment">// 否则遍历整个链表查找元素</span></span><br><span class="line">                <span class="hljs-keyword">do</span> &#123;</span><br><span class="line">                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key ||</span><br><span class="line">                                    (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="hljs-keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">// 如果找到了元素，则看参数是否需要匹配value值，如果不需要匹配直接删除，如果需要匹配则看value值是否与传入的value相等</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                (value != <span class="hljs-keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="hljs-comment">// 如果是树节点，调用树的删除方法（以node调用的，是删除自己）</span></span><br><span class="line">                ((TreeNode&lt;K, V&gt;) node).removeTreeNode(<span class="hljs-keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node == p)</span><br><span class="line">                <span class="hljs-comment">// 如果待删除的元素是第一个元素，则把第二个元素移到第一的位置</span></span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="hljs-keyword">else</span></span><br><span class="line">                <span class="hljs-comment">// 否则删除node节点</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            <span class="hljs-comment">// 删除节点后置处理</span></span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="hljs-keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>先查找元素所在的节点；</p></li><li><p>如果找到的节点是树节点，则按树的移除节点处理；</p></li><li><p>如果找到的节点是桶中的第一个节点，则把第二个节点移到第一的位置；</p></li><li><p>否则按链表删除节点处理；</p></li><li><p>修改size，调用移除节点后置处理等；</p></li></ol><h3 id="TreeNode-removeTreeNode-…-方法"><a href="#TreeNode-removeTreeNode-…-方法" class="headerlink" title="TreeNode.removeTreeNode(…)方法"></a>TreeNode.removeTreeNode(…)方法</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeTreeNode</span><span class="hljs-params">(HashMap&lt;K, V&gt; map, Node&lt;K, V&gt;[] tab,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> n;</span><br><span class="line">    <span class="hljs-comment">// 如果桶的数量为0直接返回</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)</span><br><span class="line">        <span class="hljs-keyword">return</span>;</span><br><span class="line">    <span class="hljs-comment">// 节点在桶中的索引</span></span><br><span class="line">    <span class="hljs-keyword">int</span> index = (n - <span class="hljs-number">1</span>) &amp; hash;</span><br><span class="line">    <span class="hljs-comment">// 第一个节点，根节点，根左子节点</span></span><br><span class="line">    TreeNode&lt;K, V&gt; first = (TreeNode&lt;K, V&gt;) tab[index], root = first, rl;</span><br><span class="line">    <span class="hljs-comment">// 后继节点，前置节点</span></span><br><span class="line">    TreeNode&lt;K, V&gt; succ = (TreeNode&lt;K, V&gt;) next, pred = prev;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (pred == <span class="hljs-keyword">null</span>)</span><br><span class="line">        <span class="hljs-comment">// 如果前置节点为空，说明当前节点是根节点，则把后继节点赋值到第一个节点的位置，相当于删除了当前节点</span></span><br><span class="line">        tab[index] = first = succ;</span><br><span class="line">    <span class="hljs-keyword">else</span></span><br><span class="line">        <span class="hljs-comment">// 否则把前置节点的下个节点设置为当前节点的后继节点，相当于删除了当前节点</span></span><br><span class="line">        pred.next = succ;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 如果后继节点不为空，则让后继节点的前置节点指向当前节点的前置节点，相当于删除了当前节点</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (succ != <span class="hljs-keyword">null</span>)</span><br><span class="line">        succ.prev = pred;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 如果第一个节点为空，说明没有后继节点了，直接返回</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (first == <span class="hljs-keyword">null</span>)</span><br><span class="line">        <span class="hljs-keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 如果根节点的父节点不为空，则重新查找父节点</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (root.parent != <span class="hljs-keyword">null</span>)</span><br><span class="line">        root = root.root();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 如果根节点为空，则需要反树化（将树转化为链表）</span></span><br><span class="line">    <span class="hljs-comment">// 如果需要移动节点且树的高度比较小，则需要反树化</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span></span><br><span class="line">            || (movable</span><br><span class="line">            &amp;&amp; (root.right == <span class="hljs-keyword">null</span></span><br><span class="line">            || (rl = root.left) == <span class="hljs-keyword">null</span></span><br><span class="line">            || rl.left == <span class="hljs-keyword">null</span>))) &#123;</span><br><span class="line">        tab[index] = first.untreeify(map);  <span class="hljs-comment">// too small</span></span><br><span class="line">        <span class="hljs-keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 分割线，以上都是删除链表中的节点，下面才是直接删除红黑树的节点（因为TreeNode本身即是链表节点又是树节点）</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 删除红黑树节点的大致过程是寻找右子树中最小的节点放到删除节点的位置，然后做平衡，此处不过多注释</span></span><br><span class="line">    TreeNode&lt;K, V&gt; p = <span class="hljs-keyword">this</span>, pl = left, pr = right, replacement;</span><br><span class="line">    <span class="hljs-keyword">if</span> (pl != <span class="hljs-keyword">null</span> &amp;&amp; pr != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K, V&gt; s = pr, sl;</span><br><span class="line">        <span class="hljs-keyword">while</span> ((sl = s.left) != <span class="hljs-keyword">null</span>) <span class="hljs-comment">// find successor</span></span><br><span class="line">            s = sl;</span><br><span class="line">        <span class="hljs-keyword">boolean</span> c = s.red;</span><br><span class="line">        s.red = p.red;</span><br><span class="line">        p.red = c; <span class="hljs-comment">// swap colors</span></span><br><span class="line">        TreeNode&lt;K, V&gt; sr = s.right;</span><br><span class="line">        TreeNode&lt;K, V&gt; pp = p.parent;</span><br><span class="line">        <span class="hljs-keyword">if</span> (s == pr) &#123; <span class="hljs-comment">// p was s's direct parent</span></span><br><span class="line">            p.parent = s;</span><br><span class="line">            s.right = p;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            TreeNode&lt;K, V&gt; sp = s.parent;</span><br><span class="line">            <span class="hljs-keyword">if</span> ((p.parent = sp) != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> (s == sp.left)</span><br><span class="line">                    sp.left = p;</span><br><span class="line">                <span class="hljs-keyword">else</span></span><br><span class="line">                    sp.right = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">if</span> ((s.right = pr) != <span class="hljs-keyword">null</span>)</span><br><span class="line">                pr.parent = s;</span><br><span class="line">        &#125;</span><br><span class="line">        p.left = <span class="hljs-keyword">null</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span> ((p.right = sr) != <span class="hljs-keyword">null</span>)</span><br><span class="line">            sr.parent = p;</span><br><span class="line">        <span class="hljs-keyword">if</span> ((s.left = pl) != <span class="hljs-keyword">null</span>)</span><br><span class="line">            pl.parent = s;</span><br><span class="line">        <span class="hljs-keyword">if</span> ((s.parent = pp) == <span class="hljs-keyword">null</span>)</span><br><span class="line">            root = s;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == pp.left)</span><br><span class="line">            pp.left = s;</span><br><span class="line">        <span class="hljs-keyword">else</span></span><br><span class="line">            pp.right = s;</span><br><span class="line">        <span class="hljs-keyword">if</span> (sr != <span class="hljs-keyword">null</span>)</span><br><span class="line">            replacement = sr;</span><br><span class="line">        <span class="hljs-keyword">else</span></span><br><span class="line">            replacement = p;</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pl != <span class="hljs-keyword">null</span>)</span><br><span class="line">        replacement = pl;</span><br><span class="line">    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pr != <span class="hljs-keyword">null</span>)</span><br><span class="line">        replacement = pr;</span><br><span class="line">    <span class="hljs-keyword">else</span></span><br><span class="line">        replacement = p;</span><br><span class="line">    <span class="hljs-keyword">if</span> (replacement != p) &#123;</span><br><span class="line">        TreeNode&lt;K, V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">        <span class="hljs-keyword">if</span> (pp == <span class="hljs-keyword">null</span>)</span><br><span class="line">            root = replacement;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == pp.left)</span><br><span class="line">            pp.left = replacement;</span><br><span class="line">        <span class="hljs-keyword">else</span></span><br><span class="line">            pp.right = replacement;</span><br><span class="line">        p.left = p.right = p.parent = <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode&lt;K, V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (replacement == p) &#123;  <span class="hljs-comment">// detach</span></span><br><span class="line">        TreeNode&lt;K, V&gt; pp = p.parent;</span><br><span class="line">        p.parent = <span class="hljs-keyword">null</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span> (pp != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (p == pp.left)</span><br><span class="line">                pp.left = <span class="hljs-keyword">null</span>;</span><br><span class="line">            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == pp.right)</span><br><span class="line">                pp.right = <span class="hljs-keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (movable)</span><br><span class="line">        moveRootToFront(tab, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>TreeNode本身既是链表节点也是红黑树节点；</p></li><li><p>先删除链表节点；</p></li><li><p>再删除红黑树节点并做平衡；</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>HashMap是一种散列表，采用（数组 + 链表 + 红黑树）的存储结构；</p></li><li><p>HashMap的默认初始容量为16（1&lt;&lt;4），默认装载因子为0.75f，容量总是2的n次方；</p></li><li><p>HashMap扩容时每次容量变为原来的两倍；</p></li><li><p>当桶的数量小于64时不会进行树化，只会扩容；</p></li><li><p>当桶的数量大于64且单个桶中元素的数量大于8时，进行树化；</p></li><li><p>当单个桶中元素数量小于6时，进行反树化；</p></li><li><p>HashMap是非线程安全的容器；</p></li><li><p>HashMap查找添加元素的时间复杂度都为O(1)；</p></li></ol><h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p><em>红黑树知多少？</em></p><p>红黑树具有以下5种性质：</p><ol><li><p>节点是红色或黑色。</p></li><li><p>根节点是黑色。</p></li><li><p>每个叶节点（NIL节点，空节点）是黑色的。</p></li><li><p>每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</p></li><li><p>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</p></li></ol><p>红黑树的时间复杂度为O(log n)，与树的高度成正比。</p><p>红黑树每次的插入、删除操作都需要做平衡，平衡时有可能会改变根节点的位置，颜色转换，左旋，右旋等。</p></div><div class="level is-size-7 is-uppercase"><div class="level-start"><div class="level-item"><span class="is-size-6 has-text-grey has-mr-7">#</span> <a class="has-link-grey -link" href="/tags/Java核心/">Java核心</a>, <a class="has-link-grey -link" href="/tags/源码剖析/">源码剖析</a>, <a class="has-link-grey -link" href="/tags/集合/">集合</a></div></div></div></div></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><div class="notification is-danger">You forgot to set the <code>qrcode</code> for Alipay. Please set it in <code>_config.yml</code>.</div><div class="notification is-danger">You forgot to set the <code>qrcode</code> for Wechat. Please set it in <code>_config.yml</code>.</div><div class="notification is-danger">You forgot to set the <code>business</code> and <code>currency_code</code> for Paypal. Please set it in <code>_config.yml</code>.</div><div class="notification is-danger">You forgot to set the <code>url</code> Patreon. Please set it in <code>_config.yml</code>.</div></div></div></div><div class="card card-transparent"><div class="level post-navigation is-flex-wrap is-mobile"><div class="level-start"><a class="level level-item has-link-grey article-nav-prev" href="/2016/05/31/看起来简单的通知推送服务，真的简单吗/"><i class="level-item fas fa-chevron-left"></i> <span class="level-item">看起来简单的通知推送服务，真的简单吗</span></a></div><div class="level-end"><a class="level level-item has-link-grey article-nav-next" href="/2016/03/04/ArrayList内部原理/"><span class="level-item">ArrayList内部原理</span> <i class="level-item fas fa-chevron-right"></i></a></div></div></div></div><div class="column is-4-tablet is-4-desktop is-3-widescreen has-order-1 column-left"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered" style="flex-shrink:1"><div><img class="image is-128x128 has-mb-6" src="/images/avatar.png" alt="Your name"><p class="is-size-4 is-block">Your name</p><p class="is-size-6 is-block">Your title</p><p class="is-size-6 is-flex is-flex-center has-text-grey"><i class="fas fa-map-marker-alt has-mr-7"></i> <span>Your location</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><p class="title has-text-weight-normal">28</p></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><p class="title has-text-weight-normal">1</p></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><p class="title has-text-weight-normal">27</p></div></div></nav><div class="level"><a class="level-item button is-link is-rounded" href="https://github.com/ppoffice" target="_blank">关注我</a></div><div class="level is-mobile"><a class="level-item button is-white is-marginless" target="_blank" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i> </a><a class="level-item button is-white is-marginless" target="_blank" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i> </a><a class="level-item button is-white is-marginless" target="_blank" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i> </a><a class="level-item button is-white is-marginless" target="_blank" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i> </a><a class="level-item button is-white is-marginless" target="_blank" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex" href="#简介"><span class="has-mr-6">1</span> <span>简介</span></a></li><li><a class="is-flex" href="#继承体系"><span class="has-mr-6">2</span> <span>继承体系</span></a></li><li><a class="is-flex" href="#存储结构"><span class="has-mr-6">3</span> <span>存储结构</span></a></li><li><a class="is-flex" href="#源码解析"><span class="has-mr-6">4</span> <span>源码解析</span></a><ul class="menu-list"><li><a class="is-flex" href="#属性"><span class="has-mr-6">4.1</span> <span>属性</span></a></li><li><a class="is-flex" href="#Node内部类"><span class="has-mr-6">4.2</span> <span>Node内部类</span></a></li><li><a class="is-flex" href="#TreeNode内部类"><span class="has-mr-6">4.3</span> <span>TreeNode内部类</span></a></li><li><a class="is-flex" href="#HashMap-构造方法"><span class="has-mr-6">4.4</span> <span>HashMap()构造方法</span></a></li><li><a class="is-flex" href="#HashMap-int-initialCapacity-构造方法"><span class="has-mr-6">4.5</span> <span>HashMap(int initialCapacity)构造方法</span></a></li><li><a class="is-flex" href="#HashMap-int-initialCapacity-构造方法-1"><span class="has-mr-6">4.6</span> <span>HashMap(int initialCapacity)构造方法</span></a></li><li><a class="is-flex" href="#put-K-key-V-value-方法"><span class="has-mr-6">4.7</span> <span>put(K key, V value)方法</span></a></li><li><a class="is-flex" href="#resize-方法"><span class="has-mr-6">4.8</span> <span>resize()方法</span></a></li><li><a class="is-flex" href="#TreeNode-putTreeVal-…-方法"><span class="has-mr-6">4.9</span> <span>TreeNode.putTreeVal(…)方法</span></a></li><li><a class="is-flex" href="#treeifyBin-方法"><span class="has-mr-6">4.10</span> <span>treeifyBin()方法</span></a></li><li><a class="is-flex" href="#TreeNode-treeify-方法"><span class="has-mr-6">4.11</span> <span>TreeNode.treeify()方法</span></a></li><li><a class="is-flex" href="#get-Object-key-方法"><span class="has-mr-6">4.12</span> <span>get(Object key)方法</span></a></li><li><a class="is-flex" href="#TreeNode-getTreeNode-int-h-Object-k-方法"><span class="has-mr-6">4.13</span> <span>TreeNode.getTreeNode(int h, Object k)方法</span></a></li><li><a class="is-flex" href="#remove-Object-key-方法"><span class="has-mr-6">4.14</span> <span>remove(Object key)方法</span></a></li><li><a class="is-flex" href="#TreeNode-removeTreeNode-…-方法"><span class="has-mr-6">4.15</span> <span>TreeNode.removeTreeNode(…)方法</span></a></li></ul></li><li><a class="is-flex" href="#总结"><span class="has-mr-6">5</span> <span>总结</span></a></li><li><a class="is-flex" href="#彩蛋"><span class="has-mr-6">6</span> <span>彩蛋</span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank"><span class="level-left"><span class="level-item">Hexo</span> </span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://github.com/ppoffice" target="_blank"><span class="level-left"><span class="level-item">PPOffice</span> </span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-marginless" href="/categories/计算机科学与技术/"><span class="level-start"><span class="level-item">计算机科学与技术</span> </span><span class="level-end"><span class="level-item tag">28</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">标签云</h3><a href="/tags/APM/" style="font-size:10px">APM</a> <a href="/tags/AQS/" style="font-size:10px">AQS</a> <a href="/tags/Docker/" style="font-size:12px">Docker</a> <a href="/tags/JMM/" style="font-size:10px">JMM</a> <a href="/tags/JVM/" style="font-size:12px">JVM</a> <a href="/tags/Java性能监控/" style="font-size:10px">Java性能监控</a> <a href="/tags/Java核心/" style="font-size:18px">Java核心</a> <a href="/tags/Kafka/" style="font-size:10px">Kafka</a> <a href="/tags/Linux/" style="font-size:10px">Linux</a> <a href="/tags/Shell/" style="font-size:10px">Shell</a> <a href="/tags/deploy/" style="font-size:12px">deploy</a> <a href="/tags/业务场景/" style="font-size:10px">业务场景</a> <a href="/tags/中间件/" style="font-size:10px">中间件</a> <a href="/tags/内存模型/" style="font-size:12px">内存模型</a> <a href="/tags/容器/" style="font-size:12px">容器</a> <a href="/tags/并发/" style="font-size:10px">并发</a> <a href="/tags/心得/" style="font-size:10px">心得</a> <a href="/tags/机器学习/" style="font-size:16px">机器学习</a> <a href="/tags/架构模式/" style="font-size:10px">架构模式</a> <a href="/tags/消息队列/" style="font-size:10px">消息队列</a> <a href="/tags/源码剖析/" style="font-size:20px">源码剖析</a> <a href="/tags/论文/" style="font-size:10px">论文</a> <a href="/tags/设计/" style="font-size:10px">设计</a> <a href="/tags/轮询算法/" style="font-size:10px">轮询算法</a> <a href="/tags/通知推送/" style="font-size:10px">通知推送</a> <a href="/tags/部署/" style="font-size:14px">部署</a> <a href="/tags/集合/" style="font-size:18px">集合</a></div></div><div class="column-right-shadow is-hidden-widescreen"><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><a href="/2019/06/01/一张图澄清架构设计模式/" class="media-left"><p class="image is-64x64"><img class="thumbnail" src="/images/thumbnail.svg" alt="一张图澄清架构设计模式"></p></a><div class="media-content"><div class="content"><div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-06-01T14:29:20.000Z">2019-06-01</time></div><a href="/2019/06/01/一张图澄清架构设计模式/" class="has-link-black-ter is-size-6">一张图澄清架构设计模式</a><p class="is-size-7 is-uppercase"><a class="has-link-grey -link" href="/categories/计算机科学与技术/">计算机科学与技术</a></p></div></div></article><article class="media"><a href="/2018/10/21/聊聊Kafka/" class="media-left"><p class="image is-64x64"><img class="thumbnail" src="/images/thumbnail.svg" alt="聊聊Kafka"></p></a><div class="media-content"><div class="content"><div><time class="has-text-grey is-size-7 is-uppercase" datetime="2018-10-21T11:13:31.000Z">2018-10-21</time></div><a href="/2018/10/21/聊聊Kafka/" class="has-link-black-ter is-size-6">聊聊Kafka</a><p class="is-size-7 is-uppercase"><a class="has-link-grey -link" href="/categories/计算机科学与技术/">计算机科学与技术</a></p></div></div></article><article class="media"><a href="/2018/08/30/调用模型/" class="media-left"><p class="image is-64x64"><img class="thumbnail" src="/images/thumbnail.svg" alt="调用模型"></p></a><div class="media-content"><div class="content"><div><time class="has-text-grey is-size-7 is-uppercase" datetime="2018-08-30T11:02:19.000Z">2018-08-30</time></div><a href="/2018/08/30/调用模型/" class="has-link-black-ter is-size-6">调用模型</a><p class="is-size-7 is-uppercase"><a class="has-link-grey -link" href="/categories/计算机科学与技术/">计算机科学与技术</a></p></div></div></article><article class="media"><a href="/2018/08/30/加载模型文件/" class="media-left"><p class="image is-64x64"><img class="thumbnail" src="/images/thumbnail.svg" alt="加载模型文件"></p></a><div class="media-content"><div class="content"><div><time class="has-text-grey is-size-7 is-uppercase" datetime="2018-08-30T10:11:21.000Z">2018-08-30</time></div><a href="/2018/08/30/加载模型文件/" class="has-link-black-ter is-size-6">加载模型文件</a><p class="is-size-7 is-uppercase"><a class="has-link-grey -link" href="/categories/计算机科学与技术/">计算机科学与技术</a></p></div></div></article><article class="media"><a href="/2018/08/30/sparkml导出jpmml/" class="media-left"><p class="image is-64x64"><img class="thumbnail" src="/images/thumbnail.svg" alt="SparkML 导出 JPMML"></p></a><div class="media-content"><div class="content"><div><time class="has-text-grey is-size-7 is-uppercase" datetime="2018-08-30T08:07:13.000Z">2018-08-30</time></div><a href="/2018/08/30/sparkml导出jpmml/" class="has-link-black-ter is-size-6">SparkML 导出 JPMML</a><p class="is-size-7 is-uppercase"><a class="has-link-grey -link" href="/categories/计算机科学与技术/">计算机科学与技术</a></p></div></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-marginless" href="/archives/2019/06/"><span class="level-start"><span class="level-item">六月 2019</span> </span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-marginless" href="/archives/2018/10/"><span class="level-start"><span class="level-item">十月 2018</span> </span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-marginless" href="/archives/2018/08/"><span class="level-start"><span class="level-item">八月 2018</span> </span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-marginless" href="/archives/2017/11/"><span class="level-start"><span class="level-item">十一月 2017</span> </span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-marginless" href="/archives/2017/08/"><span class="level-start"><span class="level-item">八月 2017</span> </span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-marginless" href="/archives/2017/03/"><span class="level-start"><span class="level-item">三月 2017</span> </span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-marginless" href="/archives/2017/02/"><span class="level-start"><span class="level-item">二月 2017</span> </span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-marginless" href="/archives/2016/09/"><span class="level-start"><span class="level-item">九月 2016</span> </span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-marginless" href="/archives/2016/08/"><span class="level-start"><span class="level-item">八月 2016</span> </span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-marginless" href="/archives/2016/07/"><span class="level-start"><span class="level-item">七月 2016</span> </span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-marginless" href="/archives/2016/05/"><span class="level-start"><span class="level-item">五月 2016</span> </span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-marginless" href="/archives/2016/03/"><span class="level-start"><span class="level-item">三月 2016</span> </span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/APM/"><span class="tag">APM</span> <span class="tag is-grey">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AQS/"><span class="tag">AQS</span> <span class="tag is-grey">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span> <span class="tag is-grey">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JMM/"><span class="tag">JMM</span> <span class="tag is-grey">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JVM/"><span class="tag">JVM</span> <span class="tag is-grey">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java性能监控/"><span class="tag">Java性能监控</span> <span class="tag is-grey">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java核心/"><span class="tag">Java核心</span> <span class="tag is-grey">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Kafka/"><span class="tag">Kafka</span> <span class="tag is-grey">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span> <span class="tag is-grey">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Shell/"><span class="tag">Shell</span> <span class="tag is-grey">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/deploy/"><span class="tag">deploy</span> <span class="tag is-grey">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/业务场景/"><span class="tag">业务场景</span> <span class="tag is-grey">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/中间件/"><span class="tag">中间件</span> <span class="tag is-grey">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/内存模型/"><span class="tag">内存模型</span> <span class="tag is-grey">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/容器/"><span class="tag">容器</span> <span class="tag is-grey">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/并发/"><span class="tag">并发</span> <span class="tag is-grey">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/心得/"><span class="tag">心得</span> <span class="tag is-grey">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/机器学习/"><span class="tag">机器学习</span> <span class="tag is-grey">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/架构模式/"><span class="tag">架构模式</span> <span class="tag is-grey">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/消息队列/"><span class="tag">消息队列</span> <span class="tag is-grey">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/源码剖析/"><span class="tag">源码剖析</span> <span class="tag is-grey">13</span></a></div><div class="control"><a class="tags has-addons" href="/tags/论文/"><span class="tag">论文</span> <span class="tag is-grey">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/设计/"><span class="tag">设计</span> <span class="tag is-grey">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/轮询算法/"><span class="tag">轮询算法</span> <span class="tag is-grey">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/通知推送/"><span class="tag">通知推送</span> <span class="tag is-grey">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/部署/"><span class="tag">部署</span> <span class="tag is-grey">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/集合/"><span class="tag">集合</span> <span class="tag is-grey">12</span></a></div></div></div></div></div></div></div><div class="column is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only has-order-3 column-right"><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><a href="/2019/06/01/一张图澄清架构设计模式/" class="media-left"><p class="image is-64x64"><img class="thumbnail" src="/images/thumbnail.svg" alt="一张图澄清架构设计模式"></p></a><div class="media-content"><div class="content"><div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-06-01T14:29:20.000Z">2019-06-01</time></div><a href="/2019/06/01/一张图澄清架构设计模式/" class="has-link-black-ter is-size-6">一张图澄清架构设计模式</a><p class="is-size-7 is-uppercase"><a class="has-link-grey -link" href="/categories/计算机科学与技术/">计算机科学与技术</a></p></div></div></article><article class="media"><a href="/2018/10/21/聊聊Kafka/" class="media-left"><p class="image is-64x64"><img class="thumbnail" src="/images/thumbnail.svg" alt="聊聊Kafka"></p></a><div class="media-content"><div class="content"><div><time class="has-text-grey is-size-7 is-uppercase" datetime="2018-10-21T11:13:31.000Z">2018-10-21</time></div><a href="/2018/10/21/聊聊Kafka/" class="has-link-black-ter is-size-6">聊聊Kafka</a><p class="is-size-7 is-uppercase"><a class="has-link-grey -link" href="/categories/计算机科学与技术/">计算机科学与技术</a></p></div></div></article><article class="media"><a href="/2018/08/30/调用模型/" class="media-left"><p class="image is-64x64"><img class="thumbnail" src="/images/thumbnail.svg" alt="调用模型"></p></a><div class="media-content"><div class="content"><div><time class="has-text-grey is-size-7 is-uppercase" datetime="2018-08-30T11:02:19.000Z">2018-08-30</time></div><a href="/2018/08/30/调用模型/" class="has-link-black-ter is-size-6">调用模型</a><p class="is-size-7 is-uppercase"><a class="has-link-grey -link" href="/categories/计算机科学与技术/">计算机科学与技术</a></p></div></div></article><article class="media"><a href="/2018/08/30/加载模型文件/" class="media-left"><p class="image is-64x64"><img class="thumbnail" src="/images/thumbnail.svg" alt="加载模型文件"></p></a><div class="media-content"><div class="content"><div><time class="has-text-grey is-size-7 is-uppercase" datetime="2018-08-30T10:11:21.000Z">2018-08-30</time></div><a href="/2018/08/30/加载模型文件/" class="has-link-black-ter is-size-6">加载模型文件</a><p class="is-size-7 is-uppercase"><a class="has-link-grey -link" href="/categories/计算机科学与技术/">计算机科学与技术</a></p></div></div></article><article class="media"><a href="/2018/08/30/sparkml导出jpmml/" class="media-left"><p class="image is-64x64"><img class="thumbnail" src="/images/thumbnail.svg" alt="SparkML 导出 JPMML"></p></a><div class="media-content"><div class="content"><div><time class="has-text-grey is-size-7 is-uppercase" datetime="2018-08-30T08:07:13.000Z">2018-08-30</time></div><a href="/2018/08/30/sparkml导出jpmml/" class="has-link-black-ter is-size-6">SparkML 导出 JPMML</a><p class="is-size-7 is-uppercase"><a class="has-link-grey -link" href="/categories/计算机科学与技术/">计算机科学与技术</a></p></div></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-marginless" href="/archives/2019/06/"><span class="level-start"><span class="level-item">六月 2019</span> </span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-marginless" href="/archives/2018/10/"><span class="level-start"><span class="level-item">十月 2018</span> </span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-marginless" href="/archives/2018/08/"><span class="level-start"><span class="level-item">八月 2018</span> </span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-marginless" href="/archives/2017/11/"><span class="level-start"><span class="level-item">十一月 2017</span> </span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-marginless" href="/archives/2017/08/"><span class="level-start"><span class="level-item">八月 2017</span> </span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-marginless" href="/archives/2017/03/"><span class="level-start"><span class="level-item">三月 2017</span> </span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-marginless" href="/archives/2017/02/"><span class="level-start"><span class="level-item">二月 2017</span> </span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-marginless" href="/archives/2016/09/"><span class="level-start"><span class="level-item">九月 2016</span> </span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-marginless" href="/archives/2016/08/"><span class="level-start"><span class="level-item">八月 2016</span> </span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-marginless" href="/archives/2016/07/"><span class="level-start"><span class="level-item">七月 2016</span> </span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-marginless" href="/archives/2016/05/"><span class="level-start"><span class="level-item">五月 2016</span> </span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-marginless" href="/archives/2016/03/"><span class="level-start"><span class="level-item">三月 2016</span> </span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/APM/"><span class="tag">APM</span> <span class="tag is-grey">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AQS/"><span class="tag">AQS</span> <span class="tag is-grey">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span> <span class="tag is-grey">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JMM/"><span class="tag">JMM</span> <span class="tag is-grey">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JVM/"><span class="tag">JVM</span> <span class="tag is-grey">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java性能监控/"><span class="tag">Java性能监控</span> <span class="tag is-grey">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java核心/"><span class="tag">Java核心</span> <span class="tag is-grey">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Kafka/"><span class="tag">Kafka</span> <span class="tag is-grey">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span> <span class="tag is-grey">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Shell/"><span class="tag">Shell</span> <span class="tag is-grey">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/deploy/"><span class="tag">deploy</span> <span class="tag is-grey">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/业务场景/"><span class="tag">业务场景</span> <span class="tag is-grey">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/中间件/"><span class="tag">中间件</span> <span class="tag is-grey">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/内存模型/"><span class="tag">内存模型</span> <span class="tag is-grey">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/容器/"><span class="tag">容器</span> <span class="tag is-grey">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/并发/"><span class="tag">并发</span> <span class="tag is-grey">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/心得/"><span class="tag">心得</span> <span class="tag is-grey">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/机器学习/"><span class="tag">机器学习</span> <span class="tag is-grey">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/架构模式/"><span class="tag">架构模式</span> <span class="tag is-grey">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/消息队列/"><span class="tag">消息队列</span> <span class="tag is-grey">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/源码剖析/"><span class="tag">源码剖析</span> <span class="tag is-grey">13</span></a></div><div class="control"><a class="tags has-addons" href="/tags/论文/"><span class="tag">论文</span> <span class="tag is-grey">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/设计/"><span class="tag">设计</span> <span class="tag is-grey">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/轮询算法/"><span class="tag">轮询算法</span> <span class="tag is-grey">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/通知推送/"><span class="tag">通知推送</span> <span class="tag is-grey">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/部署/"><span class="tag">部署</span> <span class="tag is-grey">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/集合/"><span class="tag">集合</span> <span class="tag is-grey">12</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start has-text-centered-mobile"><a class="footer-logo is-block has-mb-6" href="/"><img src="/images/logo.svg" alt="HashMap内部原理" height="28"></a><p class="is-size-7">&copy; 2019 侯乾&nbsp; Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a></p></div><div class="level-end"><div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle"><p class="control"><a class="button is-white is-large" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-white is-large" target="_blank" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-white is-large" target="_blank" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN")</script><script src="/js/animation.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script src="/js/gallery.js" defer></script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now</a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>document.addEventListener("DOMContentLoaded",function(){outdatedBrowser({bgColor:"#f25648",color:"#ffffff",lowerThan:"flex"})})</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><script>document.addEventListener("DOMContentLoaded",function(){MathJax.Hub.Config({"HTML-CSS":{matchFontHeight:!1},SVG:{matchFontHeight:!1},CommonHTML:{matchFontHeight:!1},tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]]}})})</script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back-to-top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/clipboard.js" defer></script><script src="/js/main.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input type="text" class="searchbox-input ins-search-input" placeholder="想要查找什么..."> <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>!function(T){var N={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(无标题)"},CONTENT_URL:"/content.json"};T.INSIGHT_CONFIG=N}(window)</script><script src="/js/insight.js" defer></script><link rel="stylesheet" href="/css/search.css"><link rel="stylesheet" href="/css/insight.css"><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body></html><!-- rebuild by neat -->