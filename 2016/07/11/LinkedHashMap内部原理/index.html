<!-- build time:Fri Jul 12 2019 17:14:55 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="简介LinkedHashMap内部维护了一个双向链表，能保证元素按插入的顺序访问，也能以访问顺序访问，可以用来实现LRU缓存策略。LinkedHashMap可以看成是 LinkedList + HashMap。实战另见 LinkedHashMap"><meta name="keywords" content="源码剖析,Java核心,集合"><meta property="og:type" content="article"><meta property="og:title" content="LinkedHashMap内部原理"><meta property="og:url" content="http://houqian.xyz/2016/07/11/LinkedHashMap内部原理/index.html"><meta property="og:site_name" content="且听风吟"><meta property="og:description" content="简介LinkedHashMap内部维护了一个双向链表，能保证元素按插入的顺序访问，也能以访问顺序访问，可以用来实现LRU缓存策略。LinkedHashMap可以看成是 LinkedList + HashMap。实战另见 LinkedHashMap"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://houqian.xyz/2016/07/11/LinkedHashMap内部原理/photo-1501862348429-dc69b017f297.jpeg"><meta property="og:image" content="http://houqian.xyz/2016/07/11/LinkedHashMap内部原理/LinkedHashMap.png"><meta property="og:image" content="http://houqian.xyz/2016/07/11/LinkedHashMap内部原理/LinkedHashMap-structure.png"><meta property="og:updated_time" content="2019-07-04T11:58:06.441Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="LinkedHashMap内部原理"><meta name="twitter:description" content="简介LinkedHashMap内部维护了一个双向链表，能保证元素按插入的顺序访问，也能以访问顺序访问，可以用来实现LRU缓存策略。LinkedHashMap可以看成是 LinkedList + HashMap。实战另见 LinkedHashMap"><meta name="twitter:image" content="http://houqian.xyz/2016/07/11/LinkedHashMap内部原理/photo-1501862348429-dc69b017f297.jpeg"><link rel="shortcut icon" href="/images/favicon.ico"><link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><title>LinkedHashMap内部原理</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/rtl.css"></head><body class="max-width mx-auto px3 ltr"><div id="header-post"><a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick='$("html, body").animate({scrollTop:0},"fast")' style="display:none"><i class="fas fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">首页</a></li><li><a href="/about/">关于</a></li><li><a href="/archives/">归档</a></li><li><a href="/tags/">tags</a></li><li><a href="https://github.com/houqian">github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="/2016/07/15/PriorityQueue内部原理/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle()' onmouseout='$("#i-prev").toggle()'></i></a></li><li><a class="icon" href="/2016/07/08/TreeMap内部原理(四)/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle()' onmouseout='$("#i-next").toggle()'></i></a></li><li><a class="icon" href="#" onclick='$("html, body").animate({scrollTop:0},"fast")'><i class="fas fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle()' onmouseout='$("#i-top").toggle()'></i></a></li><li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle()' onmouseout='$("#i-share").toggle()' onclick='return $("#share").toggle(),!1'></i></a></li></ul><span id="i-prev" class="info" style="display:none">上一篇</span> <span id="i-next" class="info" style="display:none">下一篇</span> <span id="i-top" class="info" style="display:none">返回顶部</span> <span id="i-share" class="info" style="display:none">分享文章</span></span><br><div id="share" style="display:none"><ul><li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://houqian.xyz/2016/07/11/LinkedHashMap内部原理/"><i class="fab fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=http://houqian.xyz/2016/07/11/LinkedHashMap内部原理/&text=LinkedHashMap内部原理"><i class="fab fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://houqian.xyz/2016/07/11/LinkedHashMap内部原理/&title=LinkedHashMap内部原理"><i class="fab fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://houqian.xyz/2016/07/11/LinkedHashMap内部原理/&is_video=false&description=LinkedHashMap内部原理"><i class="fab fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=LinkedHashMap内部原理&body=Check out this article: http://houqian.xyz/2016/07/11/LinkedHashMap内部原理/"><i class="fas fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=http://houqian.xyz/2016/07/11/LinkedHashMap内部原理/&title=LinkedHashMap内部原理"><i class="fab fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=http://houqian.xyz/2016/07/11/LinkedHashMap内部原理/&title=LinkedHashMap内部原理"><i class="fab fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://houqian.xyz/2016/07/11/LinkedHashMap内部原理/&title=LinkedHashMap内部原理"><i class="fab fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=http://houqian.xyz/2016/07/11/LinkedHashMap内部原理/&title=LinkedHashMap内部原理"><i class="fab fa-digg" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.tumblr.com/share/link?url=http://houqian.xyz/2016/07/11/LinkedHashMap内部原理/&name=LinkedHashMap内部原理&description=&lt;!-- build time:Fri Jul 12 2019 17:14:52 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;img src=&#34;/2016/07/11/LinkedHashMap内部原理/photo-1501862348429-dc69b017f297.jpeg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&lt;h2 id=&#34;简介&#34;&gt;&lt;a href=&#34;#简介&#34; class=&#34;headerlink&#34; title=&#34;简介&#34;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;LinkedHashMap内部维护了一个双向链表，能保证元素按插入的顺序访问，也能以访问顺序访问，可以用来实现LRU缓存策略。&lt;/p&gt;&lt;p&gt;LinkedHashMap可以看成是 LinkedList + HashMap。&lt;/p&gt;&lt;p&gt;实战另见 &lt;a href=&#34;http://houqian.xyz/wiki/Java核心/集合/LinkedHashMap/&#34;&gt;LinkedHashMap&lt;/a&gt;&lt;/p&gt;"><i class="fab fa-tumblr" aria-hidden="true"></i></a></li></ul></div><div id="toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继承体系"><span class="toc-number">2.</span> <span class="toc-text">继承体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#存储结构"><span class="toc-number">3.</span> <span class="toc-text">存储结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#源码解析"><span class="toc-number">4.</span> <span class="toc-text">源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#属性"><span class="toc-number">4.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内部类"><span class="toc-number">4.2.</span> <span class="toc-text">内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造方法"><span class="toc-number">4.3.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#afterNodeInsertion-boolean-evict-方法"><span class="toc-number">4.4.</span> <span class="toc-text">afterNodeInsertion(boolean evict)方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#afterNodeAccess-Node-lt-K-V-gt-e-方法"><span class="toc-number">4.5.</span> <span class="toc-text">afterNodeAccess(Node&lt;K,V&gt; e)方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#afterNodeRemoval-Node-lt-K-V-gt-e-方法"><span class="toc-number">4.6.</span> <span class="toc-text">afterNodeRemoval(Node&lt;K,V&gt; e)方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get-Object-key-方法"><span class="toc-number">4.7.</span> <span class="toc-text">get(Object key)方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#彩蛋"><span class="toc-number">6.</span> <span class="toc-text">彩蛋</span></a></li></ol></div></span></div><div class="content index py4"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">LinkedHashMap内部原理</h1><div class="meta"><span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">且听风吟</span></span><div class="postdate"><time datetime="2016-07-11T12:01:11.000Z" itemprop="datePublished">2016-07-11</time></div><div class="article-category"><i class="fas fa-archive"></i> <a class="category-link" href="/categories/计算机科学与技术/">计算机科学与技术</a></div><div class="article-tag"><i class="fas fa-tag"></i> <a class="tag-link" href="/tags/Java核心/">Java核心</a>, <a class="tag-link" href="/tags/源码剖析/">源码剖析</a>, <a class="tag-link" href="/tags/集合/">集合</a></div></div></header><div class="content" itemprop="articleBody"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="/2016/07/11/LinkedHashMap内部原理/photo-1501862348429-dc69b017f297.jpeg" alt=""></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>LinkedHashMap内部维护了一个双向链表，能保证元素按插入的顺序访问，也能以访问顺序访问，可以用来实现LRU缓存策略。</p><p>LinkedHashMap可以看成是 LinkedList + HashMap。</p><p>实战另见 <a href="http://houqian.xyz/wiki/Java核心/集合/LinkedHashMap/">LinkedHashMap</a></p><a id="more"></a><h2 id="继承体系"><a href="#继承体系" class="headerlink" title="继承体系"></a>继承体系</h2><p><img src="/2016/07/11/LinkedHashMap内部原理/LinkedHashMap.png" alt="LinkedHashMap"></p><p>LinkedHashMap继承HashMap，拥有HashMap的所有特性，并且额外增加的按一定顺序访问的特性。</p><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p><img src="/2016/07/11/LinkedHashMap内部原理/LinkedHashMap-structure.png" alt="LinkedHashMap-structure"></p><p>我们知道HashMap使用（数组 + 单链表 + 红黑树）的存储结构，那LinkedHashMap是怎么存储的呢？</p><p>通过上面的继承体系，我们知道它继承了Map，所以它的内部也有这三种结构，但是它还额外添加了一种“双向链表”的结构存储所有元素的顺序。</p><p>添加删除元素的时候需要同时维护在HashMap中的存储，也要维护在LinkedList中的存储，所以性能上来说会比HashMap稍慢。</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 双向链表头节点 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 双向链表尾节点 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 是否按访问顺序排序 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure><ol><li><p>head<br>双向链表的头节点，旧数据存在头节点。</p></li><li><p>tail<br>双向链表的尾节点，新数据存在尾节点。</p></li><li><p>accessOrder<br>是否需要按访问顺序排序，如果为false则按插入顺序存储元素，如果是true则按访问顺序存储元素。</p></li></ol><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位于LinkedHashMap中</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位于HashMap中</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K, V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存储节点，继承自HashMap的Node类，next用于单链表存储于桶中，before和after用于双向链表存储所有元素。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity);</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">float</span> loadFactor,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前四个构造方法accessOrder都等于false，说明双向链表是按插入顺序存储元素。</p><p>最后一个构造方法accessOrder从构造方法参数传入，如果传入true，则就实现了按访问顺序存储元素，这也是实现LRU缓存策略的关键。</p><h3 id="afterNodeInsertion-boolean-evict-方法"><a href="#afterNodeInsertion-boolean-evict-方法" class="headerlink" title="afterNodeInsertion(boolean evict)方法"></a>afterNodeInsertion(boolean evict)方法</h3><p>在节点插入之后做些什么，在HashMap中的putVal()方法中被调用，可以看到HashMap中这个方法的实现为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>evict，驱逐的意思。</p><ol><li>如果evict为true，且头节点不为空，且确定移除最老的元素，那么就调用HashMap.removeNode()把头节点移除（这里的头节点是双向链表的头节点，而不是某个桶中的第一个元素）；</li><li>HashMap.removeNode()从HashMap中把这个节点移除之后，会调用afterNodeRemoval()方法；</li><li>afterNodeRemoval()方法在LinkedHashMap中也有实现，用来在移除元素后修改双向链表，见下文；</li><li>默认removeEldestEntry()方法返回false，也就是不删除元素。</li></ol><h3 id="afterNodeAccess-Node-lt-K-V-gt-e-方法"><a href="#afterNodeAccess-Node-lt-K-V-gt-e-方法" class="headerlink" title="afterNodeAccess(Node&lt;K,V&gt; e)方法"></a>afterNodeAccess(Node&lt;K,V&gt; e)方法</h3><p>在节点访问之后被调用，主要在put()已经存在的元素或get()时被调用，如果accessOrder为true，调用这个方法把访问到的节点移动到双向链表的末尾。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="comment">// 如果accessOrder为true，并且访问的节点不是尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">                (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        <span class="comment">// 把p节点从双向链表中移除</span></span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 把p节点放到双向链表的末尾</span></span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尾节点等于p</span></span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果accessOrder为true，并且访问的节点不是尾节点；</li><li>从双向链表中移除访问的节点；</li><li>把访问的节点加到双向链表的末尾；（末尾为最新访问的元素）</li></ol><h3 id="afterNodeRemoval-Node-lt-K-V-gt-e-方法"><a href="#afterNodeRemoval-Node-lt-K-V-gt-e-方法" class="headerlink" title="afterNodeRemoval(Node&lt;K,V&gt; e)方法"></a>afterNodeRemoval(Node&lt;K,V&gt; e)方法</h3><p>在节点被删除之后调用的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    <span class="comment">// 把节点p从双向链表中删除。</span></span><br><span class="line">    p.before = p.after = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经典的把节点从双向链表中删除的方法。</p><h3 id="get-Object-key-方法"><a href="#get-Object-key-方法" class="headerlink" title="get(Object key)方法"></a>get(Object key)方法</h3><p>获取元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果查找到了元素，且accessOrder为true，则调用afterNodeAccess()方法把访问的节点移到双向链表的末尾。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>LinkedHashMap继承自HashMap，具有HashMap的所有特性；</li><li>LinkedHashMap内部维护了一个双向链表存储所有的元素；</li><li>如果accessOrder为false，则可以按插入元素的顺序遍历元素；</li><li>如果accessOrder为true，则可以按访问元素的顺序遍历元素；</li><li>LinkedHashMap的实现非常精妙，很多方法都是在HashMap中留的钩子（Hook），直接实现这些Hook就可以实现对应的功能了，并不需要再重写put()等方法；</li><li>默认的LinkedHashMap并不会移除旧元素，如果需要移除旧元素，则需要重写removeEldestEntry()方法设定移除策略；</li><li>LinkedHashMap可以用来实现LRU缓存淘汰策略；</li></ol><h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p><em>LinkedHashMap如何实现LRU缓存淘汰策略呢？</em></p><p>首先，我们先来看看LRU是个什么鬼。LRU，Least Recently Used，最近最少使用，也就是优先淘汰最近最少使用的元素。</p><p>如果使用LinkedHashMap，我们把accessOrder设置为true是不是就差不多能实现这个策略了呢？答案是肯定的。请看下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.coolcoding.code;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: tangtong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019/3/18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个只有5个元素的缓存</span></span><br><span class="line">        LRU&lt;Integer, Integer&gt; lru = <span class="keyword">new</span> LRU&lt;&gt;(<span class="number">5</span>, <span class="number">0.75f</span>);</span><br><span class="line">        lru.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        lru.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        lru.put(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">        lru.put(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">        lru.put(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">        lru.put(<span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line">        lru.put(<span class="number">7</span>, <span class="number">7</span>);</span><br><span class="line">    </span><br><span class="line">        System.out.println(lru.get(<span class="number">4</span>));</span><br><span class="line">    </span><br><span class="line">        lru.put(<span class="number">6</span>, <span class="number">666</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 输出: &#123;3=3, 5=5, 7=7, 4=4, 6=666&#125;</span></span><br><span class="line">        <span class="comment">// 可以看到最旧的元素被删除了</span></span><br><span class="line">        <span class="comment">// 且最近访问的4被移到了后面</span></span><br><span class="line">        System.out.println(lru);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRU</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存缓存的容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRU</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(capacity, loadFactor, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 重写removeEldestEntry()方法设置何时移除旧元素</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> eldest</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当元素个数大于了缓存的容量, 就移除元素</span></span><br><span class="line">        <span class="keyword">return</span> size() &gt; <span class="keyword">this</span>.capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article><div id="footer-post-container"><div id="footer-post"><div id="nav-footer" style="display:none"><ul><li><a href="/">首页</a></li><li><a href="/about/">关于</a></li><li><a href="/archives/">归档</a></li><li><a href="/tags/">tags</a></li><li><a href="https://github.com/houqian">github</a></li></ul></div><div id="toc-footer" style="display:none"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继承体系"><span class="toc-number">2.</span> <span class="toc-text">继承体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#存储结构"><span class="toc-number">3.</span> <span class="toc-text">存储结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#源码解析"><span class="toc-number">4.</span> <span class="toc-text">源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#属性"><span class="toc-number">4.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内部类"><span class="toc-number">4.2.</span> <span class="toc-text">内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造方法"><span class="toc-number">4.3.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#afterNodeInsertion-boolean-evict-方法"><span class="toc-number">4.4.</span> <span class="toc-text">afterNodeInsertion(boolean evict)方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#afterNodeAccess-Node-lt-K-V-gt-e-方法"><span class="toc-number">4.5.</span> <span class="toc-text">afterNodeAccess(Node&lt;K,V&gt; e)方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#afterNodeRemoval-Node-lt-K-V-gt-e-方法"><span class="toc-number">4.6.</span> <span class="toc-text">afterNodeRemoval(Node&lt;K,V&gt; e)方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get-Object-key-方法"><span class="toc-number">4.7.</span> <span class="toc-text">get(Object key)方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#彩蛋"><span class="toc-number">6.</span> <span class="toc-text">彩蛋</span></a></li></ol></div><div id="share-footer" style="display:none"><ul><li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://houqian.xyz/2016/07/11/LinkedHashMap内部原理/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=http://houqian.xyz/2016/07/11/LinkedHashMap内部原理/&text=LinkedHashMap内部原理"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://houqian.xyz/2016/07/11/LinkedHashMap内部原理/&title=LinkedHashMap内部原理"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://houqian.xyz/2016/07/11/LinkedHashMap内部原理/&is_video=false&description=LinkedHashMap内部原理"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=LinkedHashMap内部原理&body=Check out this article: http://houqian.xyz/2016/07/11/LinkedHashMap内部原理/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=http://houqian.xyz/2016/07/11/LinkedHashMap内部原理/&title=LinkedHashMap内部原理"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=http://houqian.xyz/2016/07/11/LinkedHashMap内部原理/&title=LinkedHashMap内部原理"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://houqian.xyz/2016/07/11/LinkedHashMap内部原理/&title=LinkedHashMap内部原理"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=http://houqian.xyz/2016/07/11/LinkedHashMap内部原理/&title=LinkedHashMap内部原理"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.tumblr.com/share/link?url=http://houqian.xyz/2016/07/11/LinkedHashMap内部原理/&name=LinkedHashMap内部原理&description=&lt;!-- build time:Fri Jul 12 2019 17:14:52 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;img src=&#34;/2016/07/11/LinkedHashMap内部原理/photo-1501862348429-dc69b017f297.jpeg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&lt;h2 id=&#34;简介&#34;&gt;&lt;a href=&#34;#简介&#34; class=&#34;headerlink&#34; title=&#34;简介&#34;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;LinkedHashMap内部维护了一个双向链表，能保证元素按插入的顺序访问，也能以访问顺序访问，可以用来实现LRU缓存策略。&lt;/p&gt;&lt;p&gt;LinkedHashMap可以看成是 LinkedList + HashMap。&lt;/p&gt;&lt;p&gt;实战另见 &lt;a href=&#34;http://houqian.xyz/wiki/Java核心/集合/LinkedHashMap/&#34;&gt;LinkedHashMap&lt;/a&gt;&lt;/p&gt;"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li></ul></div><div id="actions-footer"><a id="menu" class="icon" href="#" onclick='return $("#nav-footer").toggle(),!1'><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a> <a id="toc" class="icon" href="#" onclick='return $("#toc-footer").toggle(),!1'><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a> <a id="share" class="icon" href="#" onclick='return $("#share-footer").toggle(),!1'><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a> <a id="top" style="display:none" class="icon" href="#" onclick='$("html, body").animate({scrollTop:0},"fast")'><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a></div></div></div><footer id="footer"><div class="footer-left">Copyright &copy; 2019 侯乾</div><div class="footer-right"><nav><ul><li><a href="/">首页</a></li><li><a href="/about/">关于</a></li><li><a href="/archives/">归档</a></li><li><a href="/tags/">tags</a></li><li><a href="https://github.com/houqian">github</a></li></ul></nav></div></footer></div><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css"><script src="/lib/jquery/jquery.min.js"></script><script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script><script src="/js/main.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/hijiki.model.json"},display:{position:"right",width:150,height:300},mobile:{show:!0},react:{opacity:.7},log:!1})</script></body></html><!-- rebuild by neat -->