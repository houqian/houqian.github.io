<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>使用vim的宏录制功能格式化注释文档 | 且听风吟</title>
  <meta name="author" content="侯乾">
  
  <meta name="description" content="起因经常看各类 javadoc 发现有一类 doc 并没有被做成标准的 doc 格式，直接复制出来想翻译一下，需要做一些预处理，比如删除注释、合并断行，前者各种编辑器的列模式搞定，后者就坑爹了，之前是手工一行一行的删除换行符，然后加空格的，非常坑爹。对于这类重复性操作，使用 vim 的宏录制就再好不过了。">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="使用vim的宏录制功能格式化注释文档">
  <meta property="og:site_name" content="且听风吟">

  
    <meta property="og:image" content="">
  

  
  
    <link href="/favicon.png" rel="icon">
  

  <!-- CSS -->
  <link rel="stylesheet" href="/css/themes/cerulean.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight-default.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/comment.css" media="screen" type="text/css">
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.9/es5-shim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.7/es5-sham.min.js"></script>
  <![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>
  
  <!-- analytics -->
  



<link rel="alternate" href="/atom.xml" title="且听风吟" type="application/atom+xml">
</head>

<body>
  <nav id="main-nav" class="navbar navbar-inverse navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
	<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
       <a class="navbar-brand" href="/">且听风吟</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>归档
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>分类
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>标签
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="91年人，喜欢声乐，想养一只猫">
			  <i class="fa fa-user"></i>关于
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
    <div class="content">
      


	
		<div class="page-header page-header-inverse ">		
			<h1 class="title title-inverse "> 使用vim的宏录制功能格式化注释文档</h1>
		</div>		
	






<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>经常看各类 javadoc 发现有一类 doc 并没有被做成标准的 doc 格式，直接复制出来想翻译一下，需要做一些预处理，比如删除注释、合并断行，前者各种编辑器的列模式搞定，后者就坑爹了，之前是手工一行一行的删除换行符，然后加空格的，非常坑爹。对于这类重复性操作，使用 vim 的宏录制就再好不过了。</p>
<a id="more"></a>

<h2 id="vim-的宏录制"><a href="#vim-的宏录制" class="headerlink" title="vim 的宏录制"></a>vim 的宏录制</h2><p>宏录制是指将一个操作序列保存后重复回放的功能。分为启动宏录制、进行宏录制、结束宏录制、使用宏录制四个部分。</p>
<table>
<thead>
<tr>
<th>启动宏录制</th>
<th>进行宏录制</th>
<th>结束宏录制</th>
<th>使用宏录制</th>
</tr>
</thead>
<tbody><tr>
<td>normal 模式下，q+储存器名，比如按 qa</td>
<td>正常操作即可，需要注意可重复性</td>
<td>按 q</td>
<td>@+存储器名，比如@a，如果想重复多次，可以 count+@+存储器名，比如 100@a,就会将操作序列 a 重复 100 次</td>
</tr>
</tbody></table>
<h3 id="示例：预处理-CompletableFuture-的设计文档"><a href="#示例：预处理-CompletableFuture-的设计文档" class="headerlink" title="示例：预处理 CompletableFuture 的设计文档"></a>示例：预处理 CompletableFuture 的设计文档</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Overview:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A CompletableFuture may have dependent completion actions,</span></span><br><span class="line"><span class="comment"> * collected in a linked stack. It atomically completes by CASing</span></span><br><span class="line"><span class="comment"> * a result field, and then pops off and runs those actions. This</span></span><br><span class="line"><span class="comment"> * applies across normal vs exceptional outcomes, sync vs async</span></span><br><span class="line"><span class="comment"> * actions, binary triggers, and various forms of completions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Non-nullness of field result (set via CAS) indicates done.  An</span></span><br><span class="line"><span class="comment"> * AltResult is used to box null as a result, as well as to hold</span></span><br><span class="line"><span class="comment"> * exceptions.  Using a single field makes completion simple to</span></span><br><span class="line"><span class="comment"> * detect and trigger.  Encoding and decoding is straightforward</span></span><br><span class="line"><span class="comment"> * but adds to the sprawl of trapping and associating exceptions</span></span><br><span class="line"><span class="comment"> * with targets.  Minor simplifications rely on (static) NIL (to</span></span><br><span class="line"><span class="comment"> * box null results) being the only AltResult with a null</span></span><br><span class="line"><span class="comment"> * exception field, so we don't usually need explicit comparisons.</span></span><br><span class="line"><span class="comment"> * Even though some of the generics casts are unchecked (see</span></span><br><span class="line"><span class="comment"> * SuppressWarnings annotations), they are placed to be</span></span><br><span class="line"><span class="comment"> * appropriate even if checked.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Dependent actions are represented by Completion objects linked</span></span><br><span class="line"><span class="comment"> * as Treiber stacks headed by field "stack". There are Completion</span></span><br><span class="line"><span class="comment"> * classes for each kind of action, grouped into single-input</span></span><br><span class="line"><span class="comment"> * (UniCompletion), two-input (BiCompletion), projected</span></span><br><span class="line"><span class="comment"> * (BiCompletions using either (not both) of two inputs), shared</span></span><br><span class="line"><span class="comment"> * (CoCompletion, used by the second of two sources), zero-input</span></span><br><span class="line"><span class="comment"> * source actions, and Signallers that unblock waiters. Class</span></span><br><span class="line"><span class="comment"> * Completion extends ForkJoinTask to enable async execution</span></span><br><span class="line"><span class="comment"> * (adding no space overhead because we exploit its "tag" methods</span></span><br><span class="line"><span class="comment"> * to maintain claims). It is also declared as Runnable to allow</span></span><br><span class="line"><span class="comment"> * usage with arbitrary executors.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Support for each kind of CompletionStage relies on a separate</span></span><br><span class="line"><span class="comment"> * class, along with two CompletableFuture methods:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * * A Completion class with name X corresponding to function,</span></span><br><span class="line"><span class="comment"> *   prefaced with "Uni", "Bi", or "Or". Each class contains</span></span><br><span class="line"><span class="comment"> *   fields for source(s), actions, and dependent. They are</span></span><br><span class="line"><span class="comment"> *   boringly similar, differing from others only with respect to</span></span><br><span class="line"><span class="comment"> *   underlying functional forms. We do this so that users don't</span></span><br><span class="line"><span class="comment"> *   encounter layers of adaptors in common usages. We also</span></span><br><span class="line"><span class="comment"> *   include "Relay" classes/methods that don't correspond to user</span></span><br><span class="line"><span class="comment"> *   methods; they copy results from one stage to another.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * * Boolean CompletableFuture method x(...) (for example</span></span><br><span class="line"><span class="comment"> *   uniApply) takes all of the arguments needed to check that an</span></span><br><span class="line"><span class="comment"> *   action is triggerable, and then either runs the action or</span></span><br><span class="line"><span class="comment"> *   arranges its async execution by executing its Completion</span></span><br><span class="line"><span class="comment"> *   argument, if present. The method returns true if known to be</span></span><br><span class="line"><span class="comment"> *   complete.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * * Completion method tryFire(int mode) invokes the associated x</span></span><br><span class="line"><span class="comment"> *   method with its held arguments, and on success cleans up.</span></span><br><span class="line"><span class="comment"> *   The mode argument allows tryFire to be called twice (SYNC,</span></span><br><span class="line"><span class="comment"> *   then ASYNC); the first to screen and trap exceptions while</span></span><br><span class="line"><span class="comment"> *   arranging to execute, and the second when called from a</span></span><br><span class="line"><span class="comment"> *   task. (A few classes are not used async so take slightly</span></span><br><span class="line"><span class="comment"> *   different forms.)  The claim() callback suppresses function</span></span><br><span class="line"><span class="comment"> *   invocation if already claimed by another thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * * CompletableFuture method xStage(...) is called from a public</span></span><br><span class="line"><span class="comment"> *   stage method of CompletableFuture x. It screens user</span></span><br><span class="line"><span class="comment"> *   arguments and invokes and/or creates the stage object.  If</span></span><br><span class="line"><span class="comment"> *   not async and x is already complete, the action is run</span></span><br><span class="line"><span class="comment"> *   immediately.  Otherwise a Completion c is created, pushed to</span></span><br><span class="line"><span class="comment"> *   x's stack (unless done), and started or triggered via</span></span><br><span class="line"><span class="comment"> *   c.tryFire.  This also covers races possible if x completes</span></span><br><span class="line"><span class="comment"> *   while pushing.  Classes with two inputs (for example BiApply)</span></span><br><span class="line"><span class="comment"> *   deal with races across both while pushing actions.  The</span></span><br><span class="line"><span class="comment"> *   second completion is a CoCompletion pointing to the first,</span></span><br><span class="line"><span class="comment"> *   shared so that at most one performs the action.  The</span></span><br><span class="line"><span class="comment"> *   multiple-arity methods allOf and anyOf do this pairwise to</span></span><br><span class="line"><span class="comment"> *   form trees of completions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that the generic type parameters of methods vary according</span></span><br><span class="line"><span class="comment"> * to whether "this" is a source, dependent, or completion.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Method postComplete is called upon completion unless the target</span></span><br><span class="line"><span class="comment"> * is guaranteed not to be observable (i.e., not yet returned or</span></span><br><span class="line"><span class="comment"> * linked). Multiple threads can call postComplete, which</span></span><br><span class="line"><span class="comment"> * atomically pops each dependent action, and tries to trigger it</span></span><br><span class="line"><span class="comment"> * via method tryFire, in NESTED mode.  Triggering can propagate</span></span><br><span class="line"><span class="comment"> * recursively, so NESTED mode returns its completed dependent (if</span></span><br><span class="line"><span class="comment"> * one exists) for further processing by its caller (see method</span></span><br><span class="line"><span class="comment"> * postFire).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Blocking methods get() and join() rely on Signaller Completions</span></span><br><span class="line"><span class="comment"> * that wake up waiting threads.  The mechanics are similar to</span></span><br><span class="line"><span class="comment"> * Treiber stack wait-nodes used in FutureTask, Phaser, and</span></span><br><span class="line"><span class="comment"> * SynchronousQueue. See their internal documentation for</span></span><br><span class="line"><span class="comment"> * algorithmic details.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Without precautions, CompletableFutures would be prone to</span></span><br><span class="line"><span class="comment"> * garbage accumulation as chains of Completions build up, each</span></span><br><span class="line"><span class="comment"> * pointing back to its sources. So we null out fields as soon as</span></span><br><span class="line"><span class="comment"> * possible (see especially method Completion.detach). The</span></span><br><span class="line"><span class="comment"> * screening checks needed anyway harmlessly ignore null arguments</span></span><br><span class="line"><span class="comment"> * that may have been obtained during races with threads nulling</span></span><br><span class="line"><span class="comment"> * out fields.  We also try to unlink fired Completions from</span></span><br><span class="line"><span class="comment"> * stacks that might never be popped (see method postFire).</span></span><br><span class="line"><span class="comment"> * Completion fields need not be declared as final or volatile</span></span><br><span class="line"><span class="comment"> * because they are only visible to other threads upon safe</span></span><br><span class="line"><span class="comment"> * publication.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>原文档如上所示，为了翻译软件友好，我们需要去除注释/**/，将断行还原成一行。</p>
<h3 id="去除注释"><a href="#去除注释" class="headerlink" title="去除注释"></a>去除注释</h3><p>control + v 进入列模式，shift + G选至最后一行，方向键调节，d 删除（如果还发现有少量注释，如法炮制一并删除即可）</p>
<p><img src="/2019/07/18/使用vim的宏录制功能格式化注释文档/%E6%B8%85%E9%99%A4%E6%B3%A8%E9%87%8A.gif" alt="清除注释"></p>
<h3 id="断行还原成一行"><a href="#断行还原成一行" class="headerlink" title="断行还原成一行"></a>断行还原成一行</h3><p>normal 模式qa, 定位到第二行，i 键进入插入模式，$定位到行首，backspace 删除，此时光标在首行末尾，空格一次（添加空格，防止连词），esc 键退出插入模式，q 键结束录制。此时操作序列已经录制完了，<del>待处理一共 105 行，那么执行 104 次重复即可，所以输入 104@a，</del>  因为有空行的存在，为了不破坏段的效果，这里需要计算好每段的行数-1 次重复，然后迅速定位到下一段（即 段行数-1@a），如法炮制即可。</p>
<p><img src="/2019/07/18/使用vim的宏录制功能格式化注释文档/%E6%96%AD%E8%A1%8C%E8%BF%98%E5%8E%9F%E6%88%90%E4%B8%80%E8%A1%8C.gif" alt="断行还原成一行"></p>
<h3 id="效果如下"><a href="#效果如下" class="headerlink" title="效果如下"></a>效果如下</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Overview:</span><br><span class="line"></span><br><span class="line">A CompletableFuture may have dependent completion actions, collected in a linked stack. It atomically completes by CASing a result field, and then pops off and runs those actions. This applies across normal vs exceptional outcomes, sync vs async actions, binary triggers, and various forms of completions.</span><br><span class="line">  </span><br><span class="line">Non-<span class="function">nullness of field <span class="title">result</span> <span class="params">(set via CAS)</span> indicates done. An AltResult is used to box <span class="keyword">null</span> as a result, as well as to hold exceptions. Using a single field makes completion simple to detect and trigger. Encoding and decoding is straightforward but adds to the sprawl of trapping and associating exceptions with targets. Minor simplifications rely <span class="title">on</span> <span class="params">(<span class="keyword">static</span>)</span> <span class="title">NIL</span> <span class="params">(to box <span class="keyword">null</span> results)</span> being the only AltResult with a <span class="keyword">null</span> exception field, so we don't usually need explicit comparisons. Even though some of the generics casts are <span class="title">unchecked</span> <span class="params">(see SuppressWarnings annotations)</span>, they are placed to be appropriate even <span class="keyword">if</span> checked.</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">Dependent actions are represented by Completion objects linked as Treiber stacks headed by field "stack". There are Completion classes <span class="keyword">for</span> each kind of action, grouped into single-<span class="title">input</span> <span class="params">(UniCompletion)</span>, two-<span class="title">input</span> <span class="params">(BiCompletion)</span>, <span class="title">projected</span> <span class="params">(BiCompletions using either (not both)</span> of two inputs), <span class="title">shared</span> <span class="params">(CoCompletion, used by the second of two sources)</span>, zero-input source actions, and Signallers that unblock waiters. Class Completion extends ForkJoinTask to enable async <span class="title">execution</span> <span class="params">(adding no space overhead because we exploit its <span class="string">"tag"</span> methods to maintain claims)</span>. It is also declared as Runnable to allow usage with arbitrary executors.</span></span><br><span class="line"><span class="function">Support <span class="keyword">for</span> each kind of CompletionStage relies on a separate class, along with two CompletableFuture methods:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">* A Completion class with name X corresponding to function, prefaced with "Uni", "Bi", or "Or". Each class contains fields <span class="keyword">for</span> <span class="title">source</span><span class="params">(s)</span>, actions, and dependent. They are boringly similar, differing from others only with respect to underlying functional forms. We <span class="keyword">do</span> <span class="keyword">this</span> so that users don't encounter layers of adaptors in common usages. We also include "Relay" classes/methods that don't correspond to user methods</span>; they copy results from one stage to another.</span><br><span class="line">  </span><br><span class="line">* <span class="function">Boolean CompletableFuture method <span class="title">x</span><span class="params">(...)</span> <span class="params">(<span class="keyword">for</span> example uniApply)</span> takes all of the arguments needed to check that an action is triggerable, and then either runs the action or arranges its async execution by executing its Completion argument, <span class="keyword">if</span> present. The method returns <span class="keyword">true</span> <span class="keyword">if</span> known to be complete.</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">* Completion method <span class="title">tryFire</span><span class="params">(<span class="keyword">int</span> mode)</span> invokes the associated x method with its held arguments, and on success cleans up. The mode argument allows tryFire to be called <span class="title">twice</span> <span class="params">(SYNC, then ASYNC)</span></span>; the first to screen and trap exceptions <span class="keyword">while</span> arranging to execute, and the second when called from a task. (A few classes are not used async so take slightly different forms.) <span class="function">The <span class="title">claim</span><span class="params">()</span> callback suppresses function invocation <span class="keyword">if</span> already claimed by another thread.</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">* CompletableFuture method <span class="title">xStage</span><span class="params">(...)</span> is called from a <span class="keyword">public</span> stage method of CompletableFuture x. It screens user arguments and invokes and/or creates the stage object. If not async and x is already complete, the action is run immediately. Otherwise a Completion c is created, pushed to x's <span class="title">stack</span> <span class="params">(unless done)</span>, and started or triggered via c.tryFire. This also covers races possible <span class="keyword">if</span> x completes <span class="keyword">while</span> pushing. Classes with two <span class="title">inputs</span> <span class="params">(<span class="keyword">for</span> example BiApply)</span> deal with races across both <span class="keyword">while</span> pushing actions. The second completion is a CoCompletion pointing to the first, shared so that at most one performs the action. The multiple-arity methods allOf and anyOf <span class="keyword">do</span> <span class="keyword">this</span> pairwise to form trees of completions.</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">Note that the generic type parameters of methods vary according to whether "<span class="keyword">this</span>" is a source, dependent, or completion.</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">Method postComplete is called upon completion unless the target is guaranteed not to be <span class="title">observable</span> <span class="params">(i.e., not yet returned or linked)</span>. Multiple threads can call postComplete, which atomically pops each dependent action, and tries to trigger it via method tryFire, in NESTED mode. Triggering can propagate recursively, so NESTED mode returns its completed <span class="title">dependent</span> <span class="params">(<span class="keyword">if</span> one exists)</span> <span class="keyword">for</span> further processing by its <span class="title">caller</span> <span class="params">(see method postFire)</span>.</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">Blocking methods <span class="title">get</span><span class="params">()</span> and <span class="title">join</span><span class="params">()</span> rely on Signaller Completions that wake up waiting threads. The mechanics are similar to Treiber stack wait-nodes used in FutureTask, Phaser, and SynchronousQueue. See their internal documentation <span class="keyword">for</span> algorithmic details.</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">Without precautions, CompletableFutures would be prone to garbage accumulation as chains of Completions build up, each pointing back to its sources. So we <span class="keyword">null</span> out fields as soon as <span class="title">possible</span> <span class="params">(see especially method Completion.detach)</span>. The screening checks needed anyway harmlessly ignore <span class="keyword">null</span> arguments that may have been obtained during races with threads nulling out fields. We also <span class="keyword">try</span> to unlink fired Completions from stacks that might never be <span class="title">popped</span> <span class="params">(see method postFire)</span>. Completion fields need not be declared as <span class="keyword">final</span> or <span class="keyword">volatile</span> because they are only visible to other threads upon safe publication</span></span><br></pre></td></tr></table></figure>

<p><strong>一个更骚的操作</strong></p>
<p>仔细观察发现，原文档和标准的 javadoc 非常相似，仅仅是开头少了一个*，如果在空行加上分段标签</p><p>，那岂不是直接可以使用 idea 渲染成标准 javadoc 了，美滋滋：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Overview:</span></span><br><span class="line"><span class="comment"> *&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * A CompletableFuture may have dependent completion actions,</span></span><br><span class="line"><span class="comment"> * collected in a linked stack. It atomically completes by CASing</span></span><br><span class="line"><span class="comment"> * a result field, and then pops off and runs those actions. This</span></span><br><span class="line"><span class="comment"> * applies across normal vs exceptional outcomes, sync vs async</span></span><br><span class="line"><span class="comment"> * actions, binary triggers, and various forms of completions.</span></span><br><span class="line"><span class="comment"> *&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Non-nullness of field result (set via CAS) indicates done.  An</span></span><br><span class="line"><span class="comment"> * AltResult is used to box null as a result, as well as to hold</span></span><br><span class="line"><span class="comment"> * exceptions.  Using a single field makes completion simple to</span></span><br><span class="line"><span class="comment"> * detect and trigger.  Encoding and decoding is straightforward</span></span><br><span class="line"><span class="comment"> * but adds to the sprawl of trapping and associating exceptions</span></span><br><span class="line"><span class="comment"> * with targets.  Minor simplifications rely on (static) NIL (to</span></span><br><span class="line"><span class="comment"> * box null results) being the only AltResult with a null</span></span><br><span class="line"><span class="comment"> * exception field, so we don't usually need explicit comparisons.</span></span><br><span class="line"><span class="comment"> * Even though some of the generics casts are unchecked (see</span></span><br><span class="line"><span class="comment"> * SuppressWarnings annotations), they are placed to be</span></span><br><span class="line"><span class="comment"> * appropriate even if checked.</span></span><br><span class="line"><span class="comment"> *&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Dependent actions are represented by Completion objects linked</span></span><br><span class="line"><span class="comment"> * as Treiber stacks headed by field "stack". There are Completion</span></span><br><span class="line"><span class="comment"> * classes for each kind of action, grouped into single-input</span></span><br><span class="line"><span class="comment"> * (UniCompletion), two-input (BiCompletion), projected</span></span><br><span class="line"><span class="comment"> * (BiCompletions using either (not both) of two inputs), shared</span></span><br><span class="line"><span class="comment"> * (CoCompletion, used by the second of two sources), zero-input</span></span><br><span class="line"><span class="comment"> * source actions, and Signallers that unblock waiters. Class</span></span><br><span class="line"><span class="comment"> * Completion extends ForkJoinTask to enable async execution</span></span><br><span class="line"><span class="comment"> * (adding no space overhead because we exploit its "tag" methods</span></span><br><span class="line"><span class="comment"> * to maintain claims). It is also declared as Runnable to allow</span></span><br><span class="line"><span class="comment"> * usage with arbitrary executors.</span></span><br><span class="line"><span class="comment"> *&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Support for each kind of CompletionStage relies on a separate</span></span><br><span class="line"><span class="comment"> * class, along with two CompletableFuture methods:</span></span><br><span class="line"><span class="comment"> *&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * * A Completion class with name X corresponding to function,</span></span><br><span class="line"><span class="comment"> *   prefaced with "Uni", "Bi", or "Or". Each class contains</span></span><br><span class="line"><span class="comment"> *   fields for source(s), actions, and dependent. They are</span></span><br><span class="line"><span class="comment"> *   boringly similar, differing from others only with respect to</span></span><br><span class="line"><span class="comment"> *   underlying functional forms. We do this so that users don't</span></span><br><span class="line"><span class="comment"> *   encounter layers of adaptors in common usages. We also</span></span><br><span class="line"><span class="comment"> *   include "Relay" classes/methods that don't correspond to user</span></span><br><span class="line"><span class="comment"> *   methods; they copy results from one stage to another.</span></span><br><span class="line"><span class="comment"> *&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * * Boolean CompletableFuture method x(...) (for example</span></span><br><span class="line"><span class="comment"> *   uniApply) takes all of the arguments needed to check that an</span></span><br><span class="line"><span class="comment"> *   action is triggerable, and then either runs the action or</span></span><br><span class="line"><span class="comment"> *   arranges its async execution by executing its Completion</span></span><br><span class="line"><span class="comment"> *   argument, if present. The method returns true if known to be</span></span><br><span class="line"><span class="comment"> *   complete.</span></span><br><span class="line"><span class="comment"> *&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * * Completion method tryFire(int mode) invokes the associated x</span></span><br><span class="line"><span class="comment"> *   method with its held arguments, and on success cleans up.</span></span><br><span class="line"><span class="comment"> *   The mode argument allows tryFire to be called twice (SYNC,</span></span><br><span class="line"><span class="comment"> *   then ASYNC); the first to screen and trap exceptions while</span></span><br><span class="line"><span class="comment"> *   arranging to execute, and the second when called from a</span></span><br><span class="line"><span class="comment"> *   task. (A few classes are not used async so take slightly</span></span><br><span class="line"><span class="comment"> *   different forms.)  The claim() callback suppresses function</span></span><br><span class="line"><span class="comment"> *   invocation if already claimed by another thread.</span></span><br><span class="line"><span class="comment"> *&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * * CompletableFuture method xStage(...) is called from a public</span></span><br><span class="line"><span class="comment"> *   stage method of CompletableFuture x. It screens user</span></span><br><span class="line"><span class="comment"> *   arguments and invokes and/or creates the stage object.  If</span></span><br><span class="line"><span class="comment"> *   not async and x is already complete, the action is run</span></span><br><span class="line"><span class="comment"> *   immediately.  Otherwise a Completion c is created, pushed to</span></span><br><span class="line"><span class="comment"> *   x's stack (unless done), and started or triggered via</span></span><br><span class="line"><span class="comment"> *   c.tryFire.  This also covers races possible if x completes</span></span><br><span class="line"><span class="comment"> *   while pushing.  Classes with two inputs (for example BiApply)</span></span><br><span class="line"><span class="comment"> *   deal with races across both while pushing actions.  The</span></span><br><span class="line"><span class="comment"> *   second completion is a CoCompletion pointing to the first,</span></span><br><span class="line"><span class="comment"> *   shared so that at most one performs the action.  The</span></span><br><span class="line"><span class="comment"> *   multiple-arity methods allOf and anyOf do this pairwise to</span></span><br><span class="line"><span class="comment"> *   form trees of completions.</span></span><br><span class="line"><span class="comment"> *&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Note that the generic type parameters of methods vary according</span></span><br><span class="line"><span class="comment"> * to whether "this" is a source, dependent, or completion.</span></span><br><span class="line"><span class="comment"> *&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Method postComplete is called upon completion unless the target</span></span><br><span class="line"><span class="comment"> * is guaranteed not to be observable (i.e., not yet returned or</span></span><br><span class="line"><span class="comment"> * linked). Multiple threads can call postComplete, which</span></span><br><span class="line"><span class="comment"> * atomically pops each dependent action, and tries to trigger it</span></span><br><span class="line"><span class="comment"> * via method tryFire, in NESTED mode.  Triggering can propagate</span></span><br><span class="line"><span class="comment"> * recursively, so NESTED mode returns its completed dependent (if</span></span><br><span class="line"><span class="comment"> * one exists) for further processing by its caller (see method</span></span><br><span class="line"><span class="comment"> * postFire).</span></span><br><span class="line"><span class="comment"> *&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Blocking methods get() and join() rely on Signaller Completions</span></span><br><span class="line"><span class="comment"> * that wake up waiting threads.  The mechanics are similar to</span></span><br><span class="line"><span class="comment"> * Treiber stack wait-nodes used in FutureTask, Phaser, and</span></span><br><span class="line"><span class="comment"> * SynchronousQueue. See their internal documentation for</span></span><br><span class="line"><span class="comment"> * algorithmic details.</span></span><br><span class="line"><span class="comment"> *&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Without precautions, CompletableFutures would be prone to</span></span><br><span class="line"><span class="comment"> * garbage accumulation as chains of Completions build up, each</span></span><br><span class="line"><span class="comment"> * pointing back to its sources. So we null out fields as soon as</span></span><br><span class="line"><span class="comment"> * possible (see especially method Completion.detach). The</span></span><br><span class="line"><span class="comment"> * screening checks needed anyway harmlessly ignore null arguments</span></span><br><span class="line"><span class="comment"> * that may have been obtained during races with threads nulling</span></span><br><span class="line"><span class="comment"> * out fields.  We also try to unlink fired Completions from</span></span><br><span class="line"><span class="comment"> * stacks that might never be popped (see method postFire).</span></span><br><span class="line"><span class="comment"> * Completion fields need not be declared as final or volatile</span></span><br><span class="line"><span class="comment"> * because they are only visible to other threads upon safe</span></span><br><span class="line"><span class="comment"> * publication.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后按control + j查看文档，哈哈：</p>
<p><img src="/2019/07/18/使用vim的宏录制功能格式化注释文档/%E6%B8%B2%E6%9F%93%E5%90%8E%E7%9A%84%E6%95%88%E6%9E%9C.png" alt="渲染后的效果"></p>
<h3 id="一个更骚的操作PLUS"><a href="#一个更骚的操作PLUS" class="headerlink" title="一个更骚的操作PLUS"></a>一个更骚的操作PLUS</h3><p>直接开头加上一个*，然后option + command + l 格式化文档，你会发现 idea 自动给你添加 p 标签，太爽了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>vim 操作更加灵活，适应不同的格式化文本需求，不过针对笔者的 case，最简单的方法是：idea 里，新建一个方法，把要格式化的注释拷贝过去，首行添加一个*，格式化文档即可。</p>
	  
	</div>

	<!-- recommended posts -->
	

	<div>
  	<center>
	<div class="pagination">
<ul class="pagination">
	 
				
    	<li class="prev"><a href="/2019/12/05/Spring-Cloud-Netflix技术栈系列文章/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i>Prev</a></li>
  		

        <li><a href="/archives"><i class="fa fa-archive"></i>Archive</a></li>

		
		   <li class="next"><a href="/2019/06/01/一张图澄清架构设计模式/" class="alignright next">Next<i class="fa fa-arrow-circle-o-right"></i></a></li>         
        
	
</ul>
</div>

    </center>
	</div>

    <!-- share -->
    
        
    <div class="bdsharebuttonbox">
        <a href="#" class="bds_more" data-cmd="more"></a>
        <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
        <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
        <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
        <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
        <a href="#" class="bds_linkedin" data-cmd="linkedin" title="分享到linkedin"></a>
        <a href="#" class="bds_evernotecn" data-cmd="evernotecn" title="分享到印象笔记"></a>
        <a href="#" class="bds_youdao" data-cmd="youdao" title="分享到有道云笔记"></a>
        <a href="#" class="bds_copy" data-cmd="copy" title="分享到复制网址"></a>
    </div>
    <script>
        window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"1","bdSize":"24"},"share":{}};
        with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
    </script>


        

    
	
	<!-- comment -->
	
<section id="comment">
  <h2 class="title">Comments</h2>
  
</section>


	</div> <!-- col-md-9/col-md-12 -->
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta">
	<!-- hexo-wordcount 字数统计 -->
	<div class="meta-widget">
		<i class="fa fa-bar-chart"></i>
		<span class="post-count">3.1k</span>&nbsp;字
	</div>
	<!-- hexo-wordcount 阅读时长预计 -->
	<div class="meta-widget">
		<i class="fa fa-clock-o"></i>
		<span class="post-count">&nbsp;17</span>&nbsp;分钟
	</div>

	<!-- date -->
	
	<div class="meta-widget">
		<i class="fa fa-calendar-o"></i>
		<span>&nbsp;2019-07-18</span>
	</div>
	

	<!-- categories -->
	
	<div class="meta-widget">
		<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>
		<ul id="categorys" class="tag_box list-unstyled collapse in">
			  
  <li>
    <li><a href="/categories/计算机科学与技术/">计算机科学与技术<span>51</span></a></li>
  </li>

		</ul>
	</div>
	

	<!-- tags -->
	
	<div class="meta-widget">
		<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>
		<ul id="tags" class="tag_box list-unstyled collapse in">
			  
  <li><a href="/tags/源码剖析/">源码剖析<span>33</span></a></li> <li><a href="/tags/心得/">心得<span>2</span></a></li>
		</ul>
	</div>
	

	<!-- toc -->
	<div class="meta-widget">
		
		<a data-toggle="collapse" data-target="#toc"><i class="fa fa-bars"></i></a>
		<div id="toc" class="toc collapse in">
			<ol class="toc-article"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#起因"><span class="toc-article-text">起因</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#vim-的宏录制"><span class="toc-article-text">vim 的宏录制</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#示例：预处理-CompletableFuture-的设计文档"><span class="toc-article-text">示例：预处理 CompletableFuture 的设计文档</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#去除注释"><span class="toc-article-text">去除注释</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#断行还原成一行"><span class="toc-article-text">断行还原成一行</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#效果如下"><span class="toc-article-text">效果如下</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#一个更骚的操作PLUS"><span class="toc-article-text">一个更骚的操作PLUS</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#总结"><span class="toc-article-text">总结</span></a></li></ol>
		</div>
		
	</div>

	<hr>

</div><!-- col-md-3 -->
	</div>
		

</div><!-- row -->



    </div>
  </div>
  <div class="container-narrow">
    <footer> <p>
  &copy; 2021 侯乾
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.    
</p> </footer>
  </div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>


<!-- syntax highlighting -->


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"react":{"opacity":0.7},"log":false});</script></body>
</html>