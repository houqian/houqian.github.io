<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>且听风吟</title>
  
  <subtitle>647 号小宇宙</subtitle>
  <link href="http://houqian.github.io/atom.xml" rel="self"/>
  
  <link href="http://houqian.github.io/"/>
  <updated>2021-06-09T07:46:37.562Z</updated>
  <id>http://houqian.github.io/</id>
  
  <author>
    <name>侯乾</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>声明式接口调用：Feign总结</title>
    <link href="http://houqian.github.io/2020/06/25/%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%EF%BC%9AFeign%E6%80%BB%E7%BB%93/"/>
    <id>http://houqian.github.io/2020/06/25/%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%EF%BC%9AFeign%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-25T12:06:12.000Z</published>
    <updated>2021-06-09T07:46:37.562Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Feign的运行时"><a href="#Feign的运行时" class="headerlink" title="Feign的运行时"></a>Feign的运行时</h1><a id="more"></a><img src="/blog/2020/06/25/声明式接口调用：Feign总结/Feign-Feign总结-1623223643812.png" alt="Feign-Feign总结" style="zoom: 67%;"><h1 id="Feign的超时与重试"><a href="#Feign的超时与重试" class="headerlink" title="Feign的超时与重试"></a>Feign的超时与重试</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line"><span class="attr">  ConnectTimeout:</span> <span class="number">1000</span></span><br><span class="line"><span class="attr">  ReadTimeout:</span> <span class="number">1000</span></span><br><span class="line"><span class="attr">  OkToRetryOnAllOperations:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  MaxAutoRetries:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  MaxAutoRetriesNextServer:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><ul><li><p>ConnectTimeout<br>建立Socket连接的超时时间。<br>这个参数是在Feign使用自己的Client发送HTTP请求时使用，本质是<code>HttpURLConnection#setConnectTimeout</code><br>意思是发送请求前，建立socket连接得在这个时间内完成，如果超出时间，就会报<code>java.net.SocketTimeoutException</code></p></li><li><p>ReadTimeout<br>从Socket读取数据的超时时间，显然这指的是读取响应内容的时间</p></li><li><p>OkToRetryOnAllOperations<br>调用远程服务发生任何超时异常，程序返回报错（比如500）等都会进行重试</p></li><li><p>MaxAutoRetries<br>同一台机器被重试的次数</p></li><li><p>MaxAutoRetriesNextServer</p><p>最多重试几台服务器</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Feign的运行时&quot;&gt;&lt;a href=&quot;#Feign的运行时&quot; class=&quot;headerlink&quot; title=&quot;Feign的运行时&quot;&gt;&lt;/a&gt;Feign的运行时&lt;/h1&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Feign" scheme="http://houqian.github.io/tags/Feign/"/>
    
  </entry>
  
  <entry>
    <title>声明式接口调用：Feign源码剖析（5）Feign整合Ribbon的连接超时与重试机制</title>
    <link href="http://houqian.github.io/2020/06/18/%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%EF%BC%9AFeign%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%885%EF%BC%89Feign%E6%95%B4%E5%90%88Ribbon%E7%9A%84%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6%E4%B8%8E%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6/"/>
    <id>http://houqian.github.io/2020/06/18/%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%EF%BC%9AFeign%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%885%EF%BC%89Feign%E6%95%B4%E5%90%88Ribbon%E7%9A%84%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6%E4%B8%8E%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6/</id>
    <published>2020-06-18T12:00:01.000Z</published>
    <updated>2021-06-09T07:46:29.756Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><ul><li>服务提供者ServiceA，5个实例，端口8081~8085</li><li>服务消费者ServiceB，1个实例，端口9000</li><li>注册中心，eureka-server，2个实例</li><li>SpringCloud版本，Hoxton.RELEASE</li><li>SpringBoot版本，2.2.1.RELEASE</li><li>SpringCloudStarterOpenFeign版本，2.2.0.RELEASE</li></ul><a id="more"></a><p>对ServiceA的greeting接口稍加改造，用以模拟接口超时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">greeting</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    Integer port = environment.getProperty(<span class="string">"local.server.port"</span>, Integer.class);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.info(<span class="string">"[&#123;&#125;]进入漫长的等待..."</span>, port);</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello,"</span> + name + <span class="string">", came from "</span> + port;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于服务消费者ServiceB的配置如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line"><span class="attr">  ConnectTimeout:</span> <span class="number">1000</span></span><br><span class="line"><span class="attr">  ReadTimeout:</span> <span class="number">1000</span></span><br><span class="line"><span class="attr">  OkToRetryOnAllOperations:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  MaxAutoRetries:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  MaxAutoRetriesNextServer:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>服务消费者B的日志如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">-14:02:48.489 -DEBUG 13376 --- [nio-9000-exec-6] c.n.loadbalancer.ZoneAwareLoadBalancer   : Zone aware logic disabled or there is only one zone</span><br><span class="line">-14:02:48.489 -DEBUG 13376 --- [nio-9000-exec-6] c.n.loadbalancer.LoadBalancerContext     : serviceA using LB returned Server: localhost:8081 for request http:///sayHello/sam</span><br><span class="line">-14:02:49.497 -DEBUG 13376 --- [nio-9000-exec-6] c.n.l.reactive.LoadBalancerCommand       : Got error java.net.SocketTimeoutException: Read timed out when executed on server localhost:8081</span><br><span class="line">-14:02:50.512 -DEBUG 13376 --- [nio-9000-exec-6] c.n.l.reactive.LoadBalancerCommand       : Got error java.net.SocketTimeoutException: Read timed out when executed on server localhost:8081</span><br><span class="line">-14:02:50.512 -DEBUG 13376 --- [nio-9000-exec-6] c.n.loadbalancer.ZoneAwareLoadBalancer   : Zone aware logic disabled or there is only one zone</span><br><span class="line">-14:02:50.512 -DEBUG 13376 --- [nio-9000-exec-6] c.n.loadbalancer.LoadBalancerContext     : serviceA using LB returned Server: localhost:8082 for request http:///sayHello/sam</span><br><span class="line">-14:02:51.523 -DEBUG 13376 --- [nio-9000-exec-6] c.n.l.reactive.LoadBalancerCommand       : Got error java.net.SocketTimeoutException: Read timed out when executed on server localhost:8082</span><br><span class="line">-14:02:52.534 -DEBUG 13376 --- [nio-9000-exec-6] c.n.l.reactive.LoadBalancerCommand       : Got error java.net.SocketTimeoutException: Read timed out when executed on server localhost:8082</span><br><span class="line">-14:02:52.535 -DEBUG 13376 --- [nio-9000-exec-6] c.n.loadbalancer.ZoneAwareLoadBalancer   : Zone aware logic disabled or there is only one zone</span><br><span class="line">-14:02:52.535 -DEBUG 13376 --- [nio-9000-exec-6] c.n.loadbalancer.LoadBalancerContext     : serviceA using LB returned Server: localhost:8084 for request http:///sayHello/sam</span><br><span class="line">-14:02:53.544 -DEBUG 13376 --- [nio-9000-exec-6] c.n.l.reactive.LoadBalancerCommand       : Got error java.net.SocketTimeoutException: Read timed out when executed on server localhost:8084</span><br><span class="line">-14:02:54.557 -DEBUG 13376 --- [nio-9000-exec-6] c.n.l.reactive.LoadBalancerCommand       : Got error java.net.SocketTimeoutException: Read timed out when executed on server localhost:8084</span><br><span class="line">-14:02:54.557 -DEBUG 13376 --- [nio-9000-exec-6] c.n.loadbalancer.ZoneAwareLoadBalancer   : Zone aware logic disabled or there is only one zone</span><br><span class="line">-14:02:54.557 -DEBUG 13376 --- [nio-9000-exec-6] c.n.loadbalancer.LoadBalancerContext     : serviceA using LB returned Server: localhost:8083 for request http:///sayHello/sam</span><br><span class="line">-14:02:55.570 -DEBUG 13376 --- [nio-9000-exec-6] c.n.l.reactive.LoadBalancerCommand       : Got error java.net.SocketTimeoutException: Read timed out when executed on server localhost:8083</span><br><span class="line">-14:02:56.574 -DEBUG 13376 --- [nio-9000-exec-6] c.n.l.reactive.LoadBalancerCommand       : Got error java.net.SocketTimeoutException: Read timed out when executed on server localhost:8083</span><br><span class="line">-14:02:56.576 -ERROR 13376 --- [nio-9000-exec-6] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is feign.RetryableException: Read timed out executing GET http://serviceA/sayHello/sam] with root cause</span><br><span class="line">-</span><br><span class="line">java.net.SocketTimeoutException: Read timed out</span><br><span class="line">  at java.net.SocketInputStream.socketRead0(Native Method) ~[na:1.8.0_291]</span><br><span class="line">  at java.net.SocketInputStream.socketRead(SocketInputStream.java:116) ~[na:1.8.0_291]</span><br><span class="line">  at java.net.SocketInputStream.read(SocketInputStream.java:171) ~[na:1.8.0_291]</span><br><span class="line">  at java.net.SocketInputStream.read(SocketInputStream.java:141) ~[na:1.8.0_291]</span><br><span class="line">  at java.io.BufferedInputStream.fill(BufferedInputStream.java:246) ~[na:1.8.0_291]</span><br><span class="line">  at java.io.BufferedInputStream.read1(BufferedInputStream.java:286) ~[na:1.8.0_291]</span><br><span class="line">  at java.io.BufferedInputStream.read(BufferedInputStream.java:345) ~[na:1.8.0_291]</span><br><span class="line">  at sun.net.www.http.HttpClient.parseHTTPHeader(HttpClient.java:735) ~[na:1.8.0_291]</span><br><span class="line">  at sun.net.www.http.HttpClient.parseHTTP(HttpClient.java:678) ~[na:1.8.0_291]</span><br><span class="line">  at sun.net.www.protocol.http.HttpURLConnection.getInputStream0(HttpURLConnection.java:1593) ~[na:1.8.0_291]</span><br><span class="line">  at sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1498) ~[na:1.8.0_291]</span><br><span class="line">  at java.net.HttpURLConnection.getResponseCode(HttpURLConnection.java:480) ~[na:1.8.0_291]</span><br><span class="line">  at feign.Client$Default.convertResponse(Client.java:82) ~[feign-core-10.4.0.jar:na]</span><br><span class="line">  at feign.Client$Default.execute(Client.java:78) ~[feign-core-10.4.0.jar:na]</span><br><span class="line">  at org.springframework.cloud.openfeign.ribbon.FeignLoadBalancer.execute(FeignLoadBalancer.java:93) ~[spring-cloud-openfeign-core-2.2.0.RELEASE.jar:2.2.0.RELEASE]</span><br><span class="line">  at org.springframework.cloud.openfeign.ribbon.FeignLoadBalancer.execute(FeignLoadBalancer.java:56) ~[spring-cloud-openfeign-core-2.2.0.RELEASE.jar:2.2.0.RELEASE]</span><br><span class="line">  at com.netflix.client.AbstractLoadBalancerAwareClient$1.call(AbstractLoadBalancerAwareClient.java:104) ~[ribbon-loadbalancer-2.3.0.jar:2.3.0]</span><br><span class="line">  at com.netflix.loadbalancer.reactive.LoadBalancerCommand$3$1.call(LoadBalancerCommand.java:303) ~[ribbon-loadbalancer-2.3.0.jar:2.3.0]</span><br><span class="line">  at com.netflix.loadbalancer.reactive.LoadBalancerCommand$3$1.call(LoadBalancerCommand.java:287) ~[ribbon-loadbalancer-2.3.0.jar:2.3.0]</span><br><span class="line">  at rx.internal.util.ScalarSynchronousObservable$3.call(ScalarSynchronousObservable.java:231) ~[rxjava-1.3.8.jar:1.3.8]</span><br><span class="line">  at rx.internal.util.ScalarSynchronousObservable$3.call(ScalarSynchronousObservable.java:228) ~[rxjava-1.3.8.jar:1.3.8]</span><br><span class="line">  at rx.Observable.unsafeSubscribe(Observable.java:10327) ~[rxjava-1.3.8.jar:1.3.8]</span><br><span class="line">  at rx.internal.operators.OperatorRetryWithPredicate$SourceSubscriber$1.call(OperatorRetryWithPredicate.java:127) ~[rxjava-1.3.8.jar:1.3.8]</span><br><span class="line">  at rx.internal.schedulers.TrampolineScheduler$InnerCurrentThreadScheduler.enqueue(TrampolineScheduler.java:73) ~[rxjava-1.3.8.jar:1.3.8]</span><br><span class="line">  at rx.internal.schedulers.TrampolineScheduler$InnerCurrentThreadScheduler.schedule(TrampolineScheduler.java:52) ~[rxjava-1.3.8.jar:1.3.8]</span><br><span class="line">  at rx.internal.operators.OperatorRetryWithPredicate$SourceSubscriber.onNext(OperatorRetryWithPredicate.java:79) ~[rxjava-1.3.8.jar:1.3.8]</span><br><span class="line">  at rx.internal.operators.OperatorRetryWithPredicate$SourceSubscriber.onNext(OperatorRetryWithPredicate.java:45) ~[rxjava-1.3.8.jar:1.3.8]</span><br><span class="line">  at rx.internal.util.ScalarSynchronousObservable$WeakSingleProducer.request(ScalarSynchronousObservable.java:276) ~[rxjava-1.3.8.jar:1.3.8]</span><br><span class="line">  at rx.Subscriber.setProducer(Subscriber.java:209) ~[rxjava-1.3.8.jar:1.3.8]</span><br><span class="line">  at rx.internal.util.ScalarSynchronousObservable$JustOnSubscribe.call(ScalarSynchronousObservable.java:138) ~[rxjava-1.3.8.jar:1.3.8]</span><br><span class="line">  at rx.internal.util.ScalarSynchronousObservable$JustOnSubscribe.call(ScalarSynchronousObservable.java:129) ~[rxjava-1.3.8.jar:1.3.8]</span><br><span class="line">  at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48) ~[rxjava-1.3.8.jar:1.3.8]</span><br><span class="line">  at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30) ~[rxjava-1.3.8.jar:1.3.8]</span><br><span class="line">  at rx.Observable.unsafeSubscribe(Observable.java:10327) ~[rxjava-1.3.8.jar:1.3.8]</span><br><span class="line">  at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.drain(OnSubscribeConcatMap.java:286) ~[rxjava-1.3.8.jar:1.3.8]</span><br><span class="line">  at rx.internal.operators.OnSubscribeConcatMap$ConcatMapSubscriber.onNext(OnSubscribeConcatMap.java:144) ~[rxjava-1.3.8.jar:1.3.8]</span><br><span class="line">  at com.netflix.loadbalancer.reactive.LoadBalancerCommand$1.call(LoadBalancerCommand.java:185) ~[ribbon-loadbalancer-2.3.0.jar:2.3.0]</span><br><span class="line">  at com.netflix.loadbalancer.reactive.LoadBalancerCommand$1.call(LoadBalancerCommand.java:180) ~[ribbon-loadbalancer-2.3.0.jar:2.3.0]</span><br><span class="line">  at rx.Observable.unsafeSubscribe(Observable.java:10327) ~[rxjava-1.3.8.jar:1.3.8]</span><br><span class="line">  at rx.internal.operators.OnSubscribeConcatMap.call(OnSubscribeConcatMap.java:94) ~[rxjava-1.3.8.jar:1.3.8]</span><br><span class="line">  at rx.internal.operators.OnSubscribeConcatMap.call(OnSubscribeConcatMap.java:42) ~[rxjava-1.3.8.jar:1.3.8]</span><br><span class="line">  at rx.Observable.unsafeSubscribe(Observable.java:10327) ~[rxjava-1.3.8.jar:1.3.8]</span><br><span class="line">  at rx.internal.operators.OperatorRetryWithPredicate$SourceSubscriber$1.call(OperatorRetryWithPredicate.java:127) ~[rxjava-1.3.8.jar:1.3.8]</span><br><span class="line">  at rx.internal.schedulers.TrampolineScheduler$InnerCurrentThreadScheduler.enqueue(TrampolineScheduler.java:73) ~[rxjava-1.3.8.jar:1.3.8]</span><br><span class="line">  at rx.internal.schedulers.TrampolineScheduler$InnerCurrentThreadScheduler.schedule(TrampolineScheduler.java:52) ~[rxjava-1.3.8.jar:1.3.8]</span><br><span class="line">  at rx.internal.operators.OperatorRetryWithPredicate$SourceSubscriber.onNext(OperatorRetryWithPredicate.java:79) ~[rxjava-1.3.8.jar:1.3.8]</span><br><span class="line">  at rx.internal.operators.OperatorRetryWithPredicate$SourceSubscriber.onNext(OperatorRetryWithPredicate.java:45) ~[rxjava-1.3.8.jar:1.3.8]</span><br><span class="line">  at rx.internal.util.ScalarSynchronousObservable$WeakSingleProducer.request(ScalarSynchronousObservable.java:276) ~[rxjava-1.3.8.jar:1.3.8]</span><br><span class="line">  at rx.Subscriber.setProducer(Subscriber.java:209) ~[rxjava-1.3.8.jar:1.3.8]</span><br><span class="line">  at rx.internal.util.ScalarSynchronousObservable$JustOnSubscribe.call(ScalarSynchronousObservable.java:138) ~[rxjava-1.3.8.jar:1.3.8]</span><br><span class="line">  at rx.internal.util.ScalarSynchronousObservable$JustOnSubscribe.call(ScalarSynchronousObservable.java:129) ~[rxjava-1.3.8.jar:1.3.8]</span><br><span class="line">  at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48) ~[rxjava-1.3.8.jar:1.3.8]</span><br><span class="line">  at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30) ~[rxjava-1.3.8.jar:1.3.8]</span><br><span class="line">  at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48) ~[rxjava-1.3.8.jar:1.3.8]</span><br><span class="line">  at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30) ~[rxjava-1.3.8.jar:1.3.8]</span><br><span class="line">  at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48) ~[rxjava-1.3.8.jar:1.3.8]</span><br><span class="line">  at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30) ~[rxjava-1.3.8.jar:1.3.8]</span><br><span class="line">  at rx.Observable.subscribe(Observable.java:10423) ~[rxjava-1.3.8.jar:1.3.8]</span><br><span class="line">  at rx.Observable.subscribe(Observable.java:10390) ~[rxjava-1.3.8.jar:1.3.8]</span><br><span class="line">  at rx.observables.BlockingObservable.blockForSingle(BlockingObservable.java:443) ~[rxjava-1.3.8.jar:1.3.8]</span><br><span class="line">  at rx.observables.BlockingObservable.single(BlockingObservable.java:340) ~[rxjava-1.3.8.jar:1.3.8]</span><br><span class="line">  at com.netflix.client.AbstractLoadBalancerAwareClient.executeWithLoadBalancer(AbstractLoadBalancerAwareClient.java:112) ~[ribbon-loadbalancer-2.3.0.jar:2.3.0]</span><br><span class="line">  at org.springframework.cloud.openfeign.ribbon.LoadBalancerFeignClient.execute(LoadBalancerFeignClient.java:83) ~[spring-cloud-openfeign-core-2.2.0.RELEASE.jar:2.2.0.RELEASE]</span><br><span class="line">  at feign.SynchronousMethodHandler.executeAndDecode(SynchronousMethodHandler.java:110) ~[feign-core-10.4.0.jar:na]</span><br><span class="line">  at feign.SynchronousMethodHandler.invoke(SynchronousMethodHandler.java:80) ~[feign-core-10.4.0.jar:na]</span><br><span class="line">  at feign.ReflectiveFeign$FeignInvocationHandler.invoke(ReflectiveFeign.java:103) ~[feign-core-10.4.0.jar:na]</span><br><span class="line">  at com.sun.proxy.$Proxy113.sayHello(Unknown Source) ~[na:na]</span><br><span class="line">  at cc.houqian.eurekalearn.serviceb.ServiceBController.greeting(ServiceBController.java:25) ~[classes/:na]</span><br><span class="line">  at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_291]</span><br><span class="line">  at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_291]</span><br><span class="line">  at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_291]</span><br><span class="line">  at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_291]</span><br><span class="line">  at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190) ~[spring-web-5.2.1.RELEASE.jar:5.2.1.RELEASE]</span><br><span class="line">  at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) ~[spring-web-5.2.1.RELEASE.jar:5.2.1.RELEASE]</span><br><span class="line">  at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:106) ~[spring-webmvc-5.2.1.RELEASE.jar:5.2.1.RELEASE]</span><br><span class="line">  at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:888) ~[spring-webmvc-5.2.1.RELEASE.jar:5.2.1.RELEASE]</span><br><span class="line">  at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:793) ~[spring-webmvc-5.2.1.RELEASE.jar:5.2.1.RELEASE]</span><br><span class="line">  at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-5.2.1.RELEASE.jar:5.2.1.RELEASE]</span><br><span class="line">  at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040) ~[spring-webmvc-5.2.1.RELEASE.jar:5.2.1.RELEASE]</span><br><span class="line">  at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) ~[spring-webmvc-5.2.1.RELEASE.jar:5.2.1.RELEASE]</span><br><span class="line">  at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) ~[spring-webmvc-5.2.1.RELEASE.jar:5.2.1.RELEASE]</span><br><span class="line">  at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) ~[spring-webmvc-5.2.1.RELEASE.jar:5.2.1.RELEASE]</span><br><span class="line">  at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) ~[tomcat-embed-core-9.0.27.jar:9.0.27]</span><br><span class="line">  at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) ~[spring-webmvc-5.2.1.RELEASE.jar:5.2.1.RELEASE]</span><br><span class="line">  at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) ~[tomcat-embed-core-9.0.27.jar:9.0.27]</span><br><span class="line">  at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.27.jar:9.0.27]</span><br><span class="line">  at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.27.jar:9.0.27]</span><br><span class="line">  at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.27.jar:9.0.27]</span><br><span class="line">  at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.27.jar:9.0.27]</span><br><span class="line">  at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.27.jar:9.0.27]</span><br><span class="line">  at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-5.2.1.RELEASE.jar:5.2.1.RELEASE]</span><br><span class="line">  at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.1.RELEASE.jar:5.2.1.RELEASE]</span><br><span class="line">  at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.27.jar:9.0.27]</span><br><span class="line">  at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.27.jar:9.0.27]</span><br><span class="line">  at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) ~[spring-web-5.2.1.RELEASE.jar:5.2.1.RELEASE]</span><br><span class="line">  at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.1.RELEASE.jar:5.2.1.RELEASE]</span><br><span class="line">  at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.27.jar:9.0.27]</span><br><span class="line">  at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.27.jar:9.0.27]</span><br><span class="line">  at org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter.doFilterInternal(WebMvcMetricsFilter.java:108) ~[spring-boot-actuator-2.2.1.RELEASE.jar:2.2.1.RELEASE]</span><br><span class="line">  at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.1.RELEASE.jar:5.2.1.RELEASE]</span><br><span class="line">  at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.27.jar:9.0.27]</span><br><span class="line">  at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.27.jar:9.0.27]</span><br><span class="line">  at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) ~[spring-web-5.2.1.RELEASE.jar:5.2.1.RELEASE]</span><br><span class="line">  at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.1.RELEASE.jar:5.2.1.RELEASE]</span><br><span class="line">  at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.27.jar:9.0.27]</span><br><span class="line">  at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.27.jar:9.0.27]</span><br><span class="line">  at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) ~[tomcat-embed-core-9.0.27.jar:9.0.27]</span><br><span class="line">  at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.27.jar:9.0.27]</span><br><span class="line">  at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:526) [tomcat-embed-core-9.0.27.jar:9.0.27]</span><br><span class="line">  at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.27.jar:9.0.27]</span><br><span class="line">  at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.27.jar:9.0.27]</span><br><span class="line">  at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.27.jar:9.0.27]</span><br><span class="line">  at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.27.jar:9.0.27]</span><br><span class="line">  at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:408) [tomcat-embed-core-9.0.27.jar:9.0.27]</span><br><span class="line">  at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) [tomcat-embed-core-9.0.27.jar:9.0.27]</span><br><span class="line">  at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:861) [tomcat-embed-core-9.0.27.jar:9.0.27]</span><br><span class="line">  at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1579) [tomcat-embed-core-9.0.27.jar:9.0.27]</span><br><span class="line">  at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.27.jar:9.0.27]</span><br><span class="line">  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_291]</span><br><span class="line">  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_291]</span><br><span class="line">  at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.27.jar:9.0.27]</span><br><span class="line">  at java.lang.Thread.run(Thread.java:748) [na:1.8.0_291]</span><br></pre></td></tr></table></figure><ul><li><p>负载均衡器ZoneAwareLoadBalancer总共选举了4次Server</p><table><thead><tr><th>第几次</th><th>服务消费者ServiceB日志</th></tr></thead><tbody><tr><td>第一次</td><td>serviceA using LB returned Server: localhost:<strong>8081</strong> for request http:///sayHello/sam</td></tr><tr><td>第二次</td><td>serviceA using LB returned Server: localhost:<strong>8082</strong> for request http:///sayHello/sam</td></tr><tr><td>第三次</td><td>serviceA using LB returned Server: localhost:<strong>8084</strong> for request http:///sayHello/sam</td></tr><tr><td>第四次</td><td>serviceA using LB returned Server: localhost:<strong>8083</strong> for request http:///sayHello/sam</td></tr></tbody></table><p>可见符合我们的预期，首次访问8081，请求+重试失败后，访问另外三个实例</p></li><li><p>从服务提供者端验证请求了多少次<br>8081被请求2次，首次是正常请求，失败，第二次是重试，同样失败</p><p><img src="/blog/2020/06/18/声明式接口调用：Feign源码剖析（5）Feign整合Ribbon的连接超时与重试机制/Ribbon%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6-%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%858081.png" alt="Ribbon重试机制-服务提供者8081"></p><p>8081被请求2次，首次是正常请求，失败，第二次是重试，同样失败</p><p><img src="/blog/2020/06/18/声明式接口调用：Feign源码剖析（5）Feign整合Ribbon的连接超时与重试机制/Ribbon%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6-%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%858082.png" alt="Ribbon重试机制-服务提供者8082"></p><p>8083被请求2次，首次是正常请求，失败，第二次是重试，同样失败<br><img src="/blog/2020/06/18/声明式接口调用：Feign源码剖析（5）Feign整合Ribbon的连接超时与重试机制/Ribbon%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6-%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%858083.png" alt="Ribbon重试机制-服务提供者8083"><br>8084被请求2次，首次是正常请求，失败，第二次是重试，同样失败<img src="/blog/2020/06/18/声明式接口调用：Feign源码剖析（5）Feign整合Ribbon的连接超时与重试机制/Ribbon%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6-%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%858084.png" alt="Ribbon重试机制-服务提供者8084"></p><p>8085没有被请求到<br><img src="/blog/2020/06/18/声明式接口调用：Feign源码剖析（5）Feign整合Ribbon的连接超时与重试机制/Ribbon%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6-%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%858085.png" alt="Ribbon重试机制-服务提供者8085"></p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>生产环境配置模版如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line"><span class="attr">  ConnectTimeout:</span> <span class="number">1000</span></span><br><span class="line"><span class="attr">  ReadTimeout:</span> <span class="number">1000</span></span><br><span class="line"><span class="attr">  OkToRetryOnAllOperations:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  MaxAutoRetries:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  MaxAutoRetriesNextServer:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><ul><li><p>ConnectTimeout<br>建立Socket连接的超时时间。<br>这个参数是在Feign使用自己的Client发送HTTP请求时使用，本质是<code>HttpURLConnection#setConnectTimeout</code><br>意思是发送请求前，建立socket连接得在这个时间内完成，如果超出时间，就会报<code>java.net.SocketTimeoutException</code></p></li><li><p>ReadTimeout<br>从Socket读取数据的超时时间，显然这指的是读取响应内容的时间</p></li><li><p>OkToRetryOnAllOperations<br>调用远程服务发生任何超时异常，程序返回报错（比如500）等都会进行重试</p></li><li><p>MaxAutoRetries<br>同一台机器被重试的次数</p></li><li><p>MaxAutoRetriesNextServer</p><p>最多重试几台服务器</p></li></ul><blockquote><p>Retryer保持默认即可，即NEVER_RETRY，用现有的重试机制已经满足需求了</p></blockquote><p><img src="/blog/2020/06/18/声明式接口调用：Feign源码剖析（5）Feign整合Ribbon的连接超时与重试机制/Feign-Feign-Ribbon%E8%B6%85%E6%97%B6%E4%B8%8E%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6.png" alt="Feign-Feign-Ribbon超时与重试机制"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;实验&quot;&gt;&lt;a href=&quot;#实验&quot; class=&quot;headerlink&quot; title=&quot;实验&quot;&gt;&lt;/a&gt;实验&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;服务提供者ServiceA，5个实例，端口8081~8085&lt;/li&gt;
&lt;li&gt;服务消费者ServiceB，1个实例，端口9000&lt;/li&gt;
&lt;li&gt;注册中心，eureka-server，2个实例&lt;/li&gt;
&lt;li&gt;SpringCloud版本，Hoxton.RELEASE&lt;/li&gt;
&lt;li&gt;SpringBoot版本，2.2.1.RELEASE&lt;/li&gt;
&lt;li&gt;SpringCloudStarterOpenFeign版本，2.2.0.RELEASE&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Feign" scheme="http://houqian.github.io/tags/Feign/"/>
    
  </entry>
  
  <entry>
    <title>声明式接口调用：Feign源码剖析（4）Feign与Eureka、Ribbon整合原理</title>
    <link href="http://houqian.github.io/2020/06/05/%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%EF%BC%9AFeign%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%884%EF%BC%89Feign%E4%B8%8EEureka%E3%80%81Ribbon%E6%95%B4%E5%90%88%E5%8E%9F%E7%90%86/"/>
    <id>http://houqian.github.io/2020/06/05/%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%EF%BC%9AFeign%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%884%EF%BC%89Feign%E4%B8%8EEureka%E3%80%81Ribbon%E6%95%B4%E5%90%88%E5%8E%9F%E7%90%86/</id>
    <published>2020-06-05T12:12:18.000Z</published>
    <updated>2021-06-09T07:46:22.548Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>其实我们上文已经剖析到了Feign整合Ribbon后是依赖Ribbon的<code>ZoneAwareLoadBalancer</code>从ServerList中选出一个Server后，再替换服务名为IP+Port，然后调用Feign底层的HTTP客户端发起最后的真实的请求。</p><a id="more"></a><p>如果站在Feign、Ribbon、Eureka的视角，来一个鸟瞰图大体是如下这样</p><p><img src="/blog/2020/06/05/声明式接口调用：Feign源码剖析（4）Feign与Eureka、Ribbon整合原理/Feign-Feign%E6%95%B4%E5%90%88Eureka%E5%92%8CRibbon.png" alt="Feign-Feign整合Eureka和Ribbon"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;其实我们上文已经剖析到了Feign整合Ribbon后是依赖Ribbon的&lt;code&gt;ZoneAwareLoadBalancer&lt;/code&gt;从ServerList中选出一个Server后，再替换服务名为IP+Port，然后调用Feign底层的HTTP客户端发起最后的真实的请求。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Feign" scheme="http://houqian.github.io/tags/Feign/"/>
    
  </entry>
  
  <entry>
    <title>声明式接口调用：Feign源码剖析（3）Feign是如何处理请求的</title>
    <link href="http://houqian.github.io/2020/05/28/%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%EF%BC%9AFeign%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%883%EF%BC%89Feign%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84/"/>
    <id>http://houqian.github.io/2020/05/28/%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%EF%BC%9AFeign%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%883%EF%BC%89Feign%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84/</id>
    <published>2020-05-28T12:01:38.000Z</published>
    <updated>2021-06-09T07:46:16.063Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>上文已经完整的分析了FeignClient被创建的过程，每个服务消费者被注入的ServiceAClient，其实都是他的动态代理实例，对ServiceAClient的任何方法调用，都会被委托给动态代理实例来完成，也就是<code>SynchronousMethodHandler#invoke</code>方法。本文就分析一下该方法的执行原理</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynchronousMethodHandler</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line">    public Object invoke(Object[] argv) throws Throwable &#123;</span><br><span class="line">      <span class="comment">// 根据你传入的方法入参还原出一个RequestTemplate</span></span><br><span class="line">      RequestTemplate template = buildTemplateFromArgs.create(argv);</span><br><span class="line">      Options options = findOptions(argv);</span><br><span class="line">      <span class="comment">// 这个Retryer目前是Retryer.NERVER_RETRY</span></span><br><span class="line">      Retryer retryer = <span class="keyword">this</span>.retryer.clone();</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> executeAndDecode(template, options);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RetryableException e) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            retryer.continueOrPropagate(e);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (RetryableException th) &#123;</span><br><span class="line">            Throwable cause = th.getCause();</span><br><span class="line">            <span class="keyword">if</span> (propagationPolicy == UNWRAP &amp;&amp; cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">throw</span> cause;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">throw</span> th;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">            logger.logRetry(metadata.configKey(), logLevel);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>根据你传入的方法入参还原出一个RequestTemplate</li><li>这个Retryer目前是Retryer.NERVER_RETRY</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynchronousMethodHandler</span> </span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    <span class="title">Object</span> <span class="title">executeAndDecode</span>(<span class="title">RequestTemplate</span> <span class="title">template</span>, <span class="title">Options</span> <span class="title">options</span>) <span class="title">throws</span> <span class="title">Throwable</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 执行一系列的RequestInterceptor，如果有自定义的拦截器，会在此时执行</span></span><br><span class="line">      Request request = targetRequest(template);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">        logger.logRequest(metadata.configKey(), logLevel, request);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Response response;</span><br><span class="line">      <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这个client其实就是LoadBalancerFeignClient  </span></span><br><span class="line">        response = client.execute(request, options);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">          logger.logIOException(metadata.configKey(), logLevel, e, elapsedTime(start));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> errorExecuting(request, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>执行一系列的RequestTemplate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Request <span class="title">targetRequest</span><span class="params">(RequestTemplate template)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (RequestInterceptor interceptor : requestInterceptors) &#123;</span><br><span class="line">    interceptor.apply(template);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target.apply(template);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用<code>LoadBalancerFeignClient#execute()</code>处理请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoadBalancerFeignClient</span> <span class="keyword">implements</span> <span class="title">Client</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">Response</span> <span class="title">execute</span>(<span class="title">Request</span> <span class="title">request</span>, <span class="title">Request</span>.<span class="title">Options</span> <span class="title">options</span>) <span class="title">throws</span> <span class="title">IOException</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 解析URI </span></span><br><span class="line">          URI asUri = URI.create(request.url());</span><br><span class="line">          String clientName = asUri.getHost();</span><br><span class="line">          URI uriWithoutHost = cleanUrl(request.url(), clientName);</span><br><span class="line">          FeignLoadBalancer.RibbonRequest ribbonRequest = <span class="keyword">new</span> FeignLoadBalancer.RibbonRequest(</span><br><span class="line">                <span class="keyword">this</span>.delegate, request, uriWithoutHost);</span><br><span class="line">          <span class="comment">// 获取客户端配置</span></span><br><span class="line">          IClientConfig requestConfig = getClientConfig(options, clientName);</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// CachingSpringLoadBalancerFactory#create(clientName)创建一个FeignLoadBalancer，这个工厂是带缓存的</span></span><br><span class="line">          <span class="comment">// 如果缓存没有，会委托SpringClientFactory#getInstance()创建一个 FeignLoadBalancer</span></span><br><span class="line">          <span class="comment">// 最后执行FeignLoadBalancer的executeWithLoadBalancer执行请求 </span></span><br><span class="line">          <span class="keyword">return</span> lbClient(clientName)</span><br><span class="line">                .executeWithLoadBalancer(ribbonRequest, requestConfig).toResponse();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">          IOException io = findIOException(e);</span><br><span class="line">          <span class="keyword">if</span> (io != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">throw</span> io;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>解析URI </li><li>获取客户端配置</li><li>获取一个<code>FeignLoadBalancer</code></li><li>委托<code>FeignLoadBalancer</code>的<code>executeWithLoadBalancer</code>执行请求（其实最后是委托给父类<code>AbstractLoadBalancerAwareClient</code>）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractLoadBalancerAwareClient</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">T</span> <span class="title">executeWithLoadBalancer</span>(<span class="title">final</span> <span class="title">S</span> <span class="title">request</span>, <span class="title">final</span> <span class="title">IClientConfig</span> <span class="title">requestConfig</span>) <span class="title">throws</span> <span class="title">ClientException</span> </span>&#123;</span><br><span class="line">        LoadBalancerCommand&lt;T&gt; command = buildLoadBalancerCommand(request, requestConfig);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> command.submit(</span><br><span class="line">            <span class="keyword">new</span> ServerOperation&lt;T&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Observable&lt;T&gt; <span class="title">call</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">                    URI finalUri = reconstructURIWithServer(server, request.getUri());</span><br><span class="line">                    S requestForServer = (S) request.replaceUri(finalUri);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> Observable.just(AbstractLoadBalancerAwareClient.<span class="keyword">this</span>.execute(requestForServer, requestConfig));</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">return</span> Observable.error(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .toBlocking()</span><br><span class="line">            .single();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>这feel又是国外喜闻乐见的reactor编程，我们看看这个command.submit做了些什么吧</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoadBalancerCommand</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; <span class="title">submit</span>(<span class="title">final</span> <span class="title">ServerOperation</span>&lt;<span class="title">T</span>&gt; <span class="title">operation</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ExecutionInfoContext context = <span class="keyword">new</span> ExecutionInfoContext();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (listenerInvoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            listenerInvoker.onExecutionStart();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AbortExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> Observable.error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 这是重试相关的逻辑，可以先不管他</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> maxRetrysSame = retryHandler.getMaxRetriesOnSameServer();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> maxRetrysNext = retryHandler.getMaxRetriesOnNextServer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the load balancer</span></span><br><span class="line">    Observable&lt;T&gt; o = </span><br><span class="line">            <span class="comment">// selectServer()，选择一个server</span></span><br><span class="line">            (server == <span class="keyword">null</span> ? selectServer() : Observable.just(server))</span><br><span class="line">            .concatMap(<span class="keyword">new</span> Func1&lt;Server, Observable&lt;T&gt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="comment">// Called for each server being selected</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Observable&lt;T&gt; <span class="title">call</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">                    context.setServer(server);</span><br><span class="line">                    <span class="keyword">final</span> ServerStats stats = loadBalancerContext.getServerStats(server);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// Called for each attempt and retry</span></span><br><span class="line">                    Observable&lt;T&gt; o = Observable</span><br><span class="line">                            .just(server)</span><br><span class="line">                            .concatMap(<span class="keyword">new</span> Func1&lt;Server, Observable&lt;T&gt;&gt;() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> Observable&lt;T&gt; <span class="title">call</span><span class="params">(<span class="keyword">final</span> Server server)</span> </span>&#123;</span><br><span class="line">                                    context.incAttemptCount();</span><br><span class="line">                                    loadBalancerContext.noteOpenConnection(stats);</span><br><span class="line">                                    </span><br><span class="line">                                    <span class="keyword">if</span> (listenerInvoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                        <span class="keyword">try</span> &#123;</span><br><span class="line">                                            listenerInvoker.onStartWithServer(context.toExecutionInfo());</span><br><span class="line">                                        &#125; <span class="keyword">catch</span> (AbortExecutionException e) &#123;</span><br><span class="line">                                            <span class="keyword">return</span> Observable.error(e);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    </span><br><span class="line">                                    <span class="keyword">final</span> Stopwatch tracer = loadBalancerContext.getExecuteTracer().start();</span><br><span class="line">                                    </span><br><span class="line">                                    <span class="keyword">return</span> operation.call(server).doOnEach(<span class="keyword">new</span> Observer&lt;T&gt;() &#123;</span><br><span class="line">                                        <span class="keyword">private</span> T entity;</span><br><span class="line">                                        <span class="meta">@Override</span></span><br><span class="line">                                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                            recordStats(tracer, stats, entity, <span class="keyword">null</span>);</span><br><span class="line">                                            <span class="comment">// <span class="doctag">TODO:</span> What to do if onNext or onError are never called?</span></span><br><span class="line">                                        &#125;</span><br><span class="line"></span><br><span class="line">                                        <span class="meta">@Override</span></span><br><span class="line">                                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                                            recordStats(tracer, stats, <span class="keyword">null</span>, e);</span><br><span class="line">                                            logger.debug(<span class="string">"Got error &#123;&#125; when executed on server &#123;&#125;"</span>, e, server);</span><br><span class="line">                                            <span class="keyword">if</span> (listenerInvoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                                listenerInvoker.onExceptionWithServer(e, context.toExecutionInfo());</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line"></span><br><span class="line">                                        <span class="meta">@Override</span></span><br><span class="line">                                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T entity)</span> </span>&#123;</span><br><span class="line">                                            <span class="keyword">this</span>.entity = entity;</span><br><span class="line">                                            <span class="keyword">if</span> (listenerInvoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                                listenerInvoker.onExecutionSuccess(entity, context.toExecutionInfo());</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;                            </span><br><span class="line">                                        </span><br><span class="line">                                        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recordStats</span><span class="params">(Stopwatch tracer, ServerStats stats, Object entity, Throwable exception)</span> </span>&#123;</span><br><span class="line">                                            tracer.stop();</span><br><span class="line">                                            loadBalancerContext.noteRequestCompletion(stats, entity, exception, tracer.getDuration(TimeUnit.MILLISECONDS), retryHandler);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (maxRetrysSame &gt; <span class="number">0</span>) </span><br><span class="line">                        o = o.retry(retryPolicy(maxRetrysSame, <span class="keyword">true</span>));</span><br><span class="line">                    <span class="keyword">return</span> o;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (maxRetrysNext &gt; <span class="number">0</span> &amp;&amp; server == <span class="keyword">null</span>) </span><br><span class="line">        o = o.retry(retryPolicy(maxRetrysNext, <span class="keyword">false</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> o.onErrorResumeNext(<span class="keyword">new</span> Func1&lt;Throwable, Observable&lt;T&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Observable&lt;T&gt; <span class="title">call</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (context.getAttemptCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (maxRetrysNext &gt; <span class="number">0</span> &amp;&amp; context.getServerAttemptCount() == (maxRetrysNext + <span class="number">1</span>)) &#123;</span><br><span class="line">                    e = <span class="keyword">new</span> ClientException(ClientException.ErrorType.NUMBEROF_RETRIES_NEXTSERVER_EXCEEDED,</span><br><span class="line">                            <span class="string">"Number of retries on next server exceeded max "</span> + maxRetrysNext</span><br><span class="line">                            + <span class="string">" retries, while making a call for: "</span> + context.getServer(), e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (maxRetrysSame &gt; <span class="number">0</span> &amp;&amp; context.getAttemptCount() == (maxRetrysSame + <span class="number">1</span>)) &#123;</span><br><span class="line">                    e = <span class="keyword">new</span> ClientException(ClientException.ErrorType.NUMBEROF_RETRIES_EXEEDED,</span><br><span class="line">                            <span class="string">"Number of retries exceeded max "</span> + maxRetrysSame</span><br><span class="line">                            + <span class="string">" retries, while making a call for: "</span> + context.getServer(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (listenerInvoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                listenerInvoker.onExecutionFailed(e, context.toFinalExecutionInfo());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Observable.error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>选择一个server</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Observable&lt;Server&gt; <span class="title">selectServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.create(<span class="keyword">new</span> OnSubscribe&lt;Server&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Server&gt; next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 这里其实就是调用Ribbon的ZoneAwareLoadBalancer选择一个Server出来</span></span><br><span class="line">                Server server = loadBalancerContext.getServerFromLoadBalancer(loadBalancerURI, loadBalancerKey);   </span><br><span class="line">                next.onNext(server);</span><br><span class="line">                next.onCompleted();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                next.onError(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>调用Ribbon的<code>ZoneAwareLoadBalancer</code>选择一个Server出来</li></ul></li><li><p>接着又回调到<code>AbstractLoadBalancerAwareClient#executeWithLoadBalancer()</code></p><blockquote><p>这里笔者不得不吐槽下这个rx系列的编程方式，难以调试，运行流程不清晰。国内很少人用，这里咱们看个大概就好</p></blockquote><ul><li><code>reconstructURIWithServer</code>和<code>request.replaceUri(finalUri)</code><br>根据选择好的server，把服务名替换成对应的主机名+端口号（比如<a href="http://serviceA/greeting/sam" target="_blank" rel="noopener">http://serviceA/greeting/sam</a>  -&gt; <a href="http://127.0.0.1:8081/greeting/sam）" target="_blank" rel="noopener">http://127.0.0.1:8081/greeting/sam）</a></li></ul></li><li><p><code>AbstractLoadBalancerAwareClient.this.execute</code><br>这个会调用<code>FeignLoadBalancer#execute()</code>方法</p></li><li><p>再往下就到了FeignCore的HTTP客户端组件，这里是最后发起HTTP请求的地方<br>可以看到feign底层使用JDK自带的<code>HttpURLConnection</code>这套HTTP API进行通信的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Client</span>  </span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    @<span class="title">Override</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">Response</span> <span class="title">execute</span>(<span class="title">Request</span> <span class="title">request</span>, <span class="title">Options</span> <span class="title">options</span>) <span class="title">throws</span> <span class="title">IOException</span> </span>&#123;</span><br><span class="line">      HttpURLConnection connection = convertAndSend(request, options);</span><br><span class="line">      <span class="keyword">return</span> convertResponse(connection, request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">HttpURLConnection <span class="title">convertAndSend</span><span class="params">(Request request, Options options)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> URL url = <span class="keyword">new</span> URL(request.url());</span><br><span class="line">      <span class="keyword">final</span> HttpURLConnection connection = <span class="keyword">this</span>.getConnection(url);</span><br><span class="line">      <span class="keyword">if</span> (connection <span class="keyword">instanceof</span> HttpsURLConnection) &#123;</span><br><span class="line">        HttpsURLConnection sslCon = (HttpsURLConnection) connection;</span><br><span class="line">        <span class="keyword">if</span> (sslContextFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">          sslCon.setSSLSocketFactory(sslContextFactory);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hostnameVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">          sslCon.setHostnameVerifier(hostnameVerifier);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 这里其实就是你配置的一系列的连接超时参数  </span></span><br><span class="line">      connection.setConnectTimeout(options.connectTimeoutMillis());</span><br><span class="line">      connection.setReadTimeout(options.readTimeoutMillis());</span><br><span class="line">      connection.setAllowUserInteraction(<span class="keyword">false</span>);</span><br><span class="line">      connection.setInstanceFollowRedirects(options.isFollowRedirects());</span><br><span class="line">      connection.setRequestMethod(request.httpMethod().name());</span><br><span class="line"></span><br><span class="line">      Collection&lt;String&gt; contentEncodingValues = request.headers().get(CONTENT_ENCODING);</span><br><span class="line">      <span class="keyword">boolean</span> gzipEncodedRequest =</span><br><span class="line">          contentEncodingValues != <span class="keyword">null</span> &amp;&amp; contentEncodingValues.contains(ENCODING_GZIP);</span><br><span class="line">      <span class="keyword">boolean</span> deflateEncodedRequest =</span><br><span class="line">          contentEncodingValues != <span class="keyword">null</span> &amp;&amp; contentEncodingValues.contains(ENCODING_DEFLATE);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">boolean</span> hasAcceptHeader = <span class="keyword">false</span>;</span><br><span class="line">      Integer contentLength = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">for</span> (String field : request.headers().keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (field.equalsIgnoreCase(<span class="string">"Accept"</span>)) &#123;</span><br><span class="line">          hasAcceptHeader = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String value : request.headers().get(field)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (field.equals(CONTENT_LENGTH)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!gzipEncodedRequest &amp;&amp; !deflateEncodedRequest) &#123;</span><br><span class="line">              contentLength = Integer.valueOf(value);</span><br><span class="line">              connection.addRequestProperty(field, value);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            connection.addRequestProperty(field, value);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Some servers choke on the default accept string.</span></span><br><span class="line">      <span class="keyword">if</span> (!hasAcceptHeader) &#123;</span><br><span class="line">        connection.addRequestProperty(<span class="string">"Accept"</span>, <span class="string">"*/*"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (request.requestBody().asBytes() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (contentLength != <span class="keyword">null</span>) &#123;</span><br><span class="line">          connection.setFixedLengthStreamingMode(contentLength);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          connection.setChunkedStreamingMode(<span class="number">8196</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        connection.setDoOutput(<span class="keyword">true</span>);</span><br><span class="line">        OutputStream out = connection.getOutputStream();</span><br><span class="line">        <span class="keyword">if</span> (gzipEncodedRequest) &#123;</span><br><span class="line">          out = <span class="keyword">new</span> GZIPOutputStream(out);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deflateEncodedRequest) &#123;</span><br><span class="line">          out = <span class="keyword">new</span> DeflaterOutputStream(out);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          out.write(request.requestBody().asBytes());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            out.close();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (IOException suppressed) &#123; <span class="comment">// NOPMD</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/blog/2020/05/28/声明式接口调用：Feign源码剖析（3）Feign是如何处理请求的/Feign-Feign%E6%8E%A5%E6%94%B6%E8%AF%B7%E6%B1%82%E5%B9%B6%E6%89%A7%E8%A1%8C.png" alt="Feign-Feign接收请求并执行"></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;上文已经完整的分析了FeignClient被创建的过程，每个服务消费者被注入的ServiceAClient，其实都是他的动态代理实例，对ServiceAClient的任何方法调用，都会被委托给动态代理实例来完成，也就是&lt;code&gt;SynchronousMethodHandler#invoke&lt;/code&gt;方法。本文就分析一下该方法的执行原理&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Feign" scheme="http://houqian.github.io/tags/Feign/"/>
    
  </entry>
  
  <entry>
    <title>声明式接口调用：Feign源码剖析（2）基于JDK动态代理构建FeignClient的过程</title>
    <link href="http://houqian.github.io/2020/05/19/%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%EF%BC%9AFeign%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%882%EF%BC%89%E5%9F%BA%E4%BA%8EJDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9E%84%E5%BB%BAFeignClient%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <id>http://houqian.github.io/2020/05/19/%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%EF%BC%9AFeign%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%882%EF%BC%89%E5%9F%BA%E4%BA%8EJDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9E%84%E5%BB%BAFeignClient%E7%9A%84%E8%BF%87%E7%A8%8B/</id>
    <published>2020-05-19T12:11:52.000Z</published>
    <updated>2021-06-09T07:46:11.753Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>上文我们已经分析到<code>FeignClientFactoryBean#getTarget()</code>方法，这里完成了FeignClient动态代理的创建。但并未分析具体的创建过程，本文将深入Feign Core将FeignClient到底是如何被创建出来的给摸清楚。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HystrixTargeter</span> <span class="keyword">implements</span> <span class="title">Targeter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(FeignClientFactoryBean factory, Feign.Builder feign,</span></span></span><br><span class="line"><span class="function"><span class="params">         FeignContext context, Target.HardCodedTarget&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!(feign <span class="keyword">instanceof</span> feign.hystrix.HystrixFeign.Builder)) &#123;</span><br><span class="line">         <span class="keyword">return</span> feign.target(target);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><ul><li>我们此时并未整合Hystrix，所以此处的feign还是<code>Feign.Builder</code>，此处直接走他的target方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Feign</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> InvocationHandlerFactory invocationHandlerFactory =</span><br><span class="line">            <span class="keyword">new</span> InvocationHandlerFactory.Default();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(Target&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> build().newInstance(target);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Feign <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          SynchronousMethodHandler.Factory synchronousMethodHandlerFactory =</span><br><span class="line">              <span class="keyword">new</span> SynchronousMethodHandler.Factory(client, retryer, requestInterceptors, logger,</span><br><span class="line">                  logLevel, decode404, closeAfterDecode, propagationPolicy);</span><br><span class="line">          ParseHandlersByName handlersByName =</span><br><span class="line">              <span class="keyword">new</span> ParseHandlersByName(contract, options, encoder, decoder, queryMapEncoder,</span><br><span class="line">                  errorDecoder, synchronousMethodHandlerFactory);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> ReflectiveFeign(handlersByName, invocationHandlerFactory, queryMapEncoder);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>SynchronousMethodHandler</code><br>同步方法处理器</p></li><li><p>invocationHandlerFactory<br>invocationHandler这东西怎么这么眼熟呢，这不是JDK动态代理那个套路里的接口吗？我们一探究竟</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Default</span> <span class="keyword">implements</span> <span class="title">InvocationHandlerFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> InvocationHandler <span class="title">create</span><span class="params">(Target target, Map&lt;Method, MethodHandler&gt; dispatch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReflectiveFeign.FeignInvocationHandler(target, dispatch);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>这包裹的层次够深的，我们看看这个<code>FeignInvoccationHandler</code>是啥</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Target target;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MethodHandler&gt; dispatch;</span><br><span class="line"></span><br><span class="line">  FeignInvocationHandler(Target target, Map&lt;Method, MethodHandler&gt; dispatch) &#123;</span><br><span class="line">    <span class="keyword">this</span>.target = checkNotNull(target, <span class="string">"target"</span>);</span><br><span class="line">    <span class="keyword">this</span>.dispatch = checkNotNull(dispatch, <span class="string">"dispatch for %s"</span>, target);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"equals"</span>.equals(method.getName())) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Object otherHandler =</span><br><span class="line">            args.length &gt; <span class="number">0</span> &amp;&amp; args[<span class="number">0</span>] != <span class="keyword">null</span> ? Proxy.getInvocationHandler(args[<span class="number">0</span>]) : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> equals(otherHandler);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"hashCode"</span>.equals(method.getName())) &#123;</span><br><span class="line">      <span class="keyword">return</span> hashCode();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"toString"</span>.equals(method.getName())) &#123;</span><br><span class="line">      <span class="keyword">return</span> toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dispatch.get(method).invoke(args);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>到此，终于真相大白，验证了我们根据命名得到的猜测，这确实是使用了JDK的动态代理技术，这个invoke方法我们后续再分析，其实也不难推测，无非是拦截对ServiceAClient的方法的调用，委托到这个<code>FeignInvocationHandler#invoke()</code>，然后执行feign的逻辑，最后就是调用底层的一个HTTP客户端，根据我们的<code>RequestMapping</code>等注解里的参数拼接一个HTTP Request，发送出去罢了</p></blockquote></li></ul></li><li><p>接上<code>build().newInstance(target)</code>，<code>build()</code>出了一个<code>ReflectiveFeign</code>对象，然后调用它的<code>newInstance()</code>方法，在这里，最终完成了基于JDK动态代理的FeignClient的创建</p></li></ul><h1 id="柳暗花明，看ReflectiveFeign-newInstance"><a href="#柳暗花明，看ReflectiveFeign-newInstance" class="headerlink" title="柳暗花明，看ReflectiveFeign#newInstance()"></a>柳暗花明，看<code>ReflectiveFeign#newInstance()</code></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReflectiveFeign</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    <span class="title">public</span> &lt;<span class="title">T</span>&gt; <span class="title">T</span> <span class="title">newInstance</span>(<span class="title">Target</span>&lt;<span class="title">T</span>&gt; <span class="title">target</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 这个apply会调用SpringMvcContract将注解都解析出来，放到Feign的RequestTemplate中去</span></span><br><span class="line">      Map&lt;String, MethodHandler&gt; nameToHandler = targetToHandlersByName.apply(target);</span><br><span class="line">      Map&lt;Method, MethodHandler&gt; methodToHandler = <span class="keyword">new</span> LinkedHashMap&lt;Method, MethodHandler&gt;();</span><br><span class="line">      List&lt;DefaultMethodHandler&gt; defaultMethodHandlers = <span class="keyword">new</span> LinkedList&lt;DefaultMethodHandler&gt;();</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 这里就是</span></span><br><span class="line">      <span class="keyword">for</span> (Method method : target.type().getMethods()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Util.isDefault(method)) &#123;</span><br><span class="line">          DefaultMethodHandler handler = <span class="keyword">new</span> DefaultMethodHandler(method);</span><br><span class="line">          defaultMethodHandlers.add(handler);</span><br><span class="line">          methodToHandler.put(method, handler);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 就是简单的组装了一个ServiceAClient中方法对象 -&gt;  SynchronousMethodHandler的映射</span></span><br><span class="line">          methodToHandler.put(method, nameToHandler.get(Feign.configKey(target.type(), method)));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 接下来就是最后的基于JDK动态代理创建Proxy对象实例了</span></span><br><span class="line">      InvocationHandler handler = factory.create(target, methodToHandler);</span><br><span class="line">      T proxy = (T) Proxy.newProxyInstance(target.type().getClassLoader(),</span><br><span class="line">          <span class="keyword">new</span> Class&lt;?&gt;[] &#123;target.type()&#125;, handler);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (DefaultMethodHandler defaultMethodHandler : defaultMethodHandlers) &#123;</span><br><span class="line">        defaultMethodHandler.bindTo(proxy);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>下面的部分是各个步骤的详细剖析，没兴趣的同学可以不看了，在这里已经完成了所有关于FeignClient创建的核心知识了。</strong></p></blockquote><ul><li><p>nameToHandler<br>看名字就可以猜测是什么东西的名称和代理方法处理器的映射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReflectiveFeign</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">Map</span>&lt;<span class="title">String</span>, <span class="title">MethodHandler</span>&gt; <span class="title">apply</span>(<span class="title">Target</span> <span class="title">key</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 这里执行了SpringMvcContract组件的解析SpringMVC注解的逻辑，最后解析后组成了一个List</span></span><br><span class="line">      List&lt;MethodMetadata&gt; metadata = contract.parseAndValidatateMetadata(key.type());</span><br><span class="line">      Map&lt;String, MethodHandler&gt; result = <span class="keyword">new</span> LinkedHashMap&lt;String, MethodHandler&gt;();</span><br><span class="line">      <span class="keyword">for</span> (MethodMetadata md : metadata) &#123;</span><br><span class="line">        BuildTemplateByResolvingArgs buildTemplate;</span><br><span class="line">        <span class="keyword">if</span> (!md.formParams().isEmpty() &amp;&amp; md.template().bodyTemplate() == <span class="keyword">null</span>) &#123;</span><br><span class="line">          buildTemplate = <span class="keyword">new</span> BuildFormEncodedTemplateFromArgs(md, encoder, queryMapEncoder);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (md.bodyIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">          buildTemplate = <span class="keyword">new</span> BuildEncodedTemplateFromArgs(md, encoder, queryMapEncoder);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          buildTemplate = <span class="keyword">new</span> BuildTemplateByResolvingArgs(md, queryMapEncoder);</span><br><span class="line">        &#125;</span><br><span class="line">        result.put(md.configKey(),</span><br><span class="line">            factory.create(key, md, buildTemplate, options, decoder, errorDecoder));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>contract.parseAndValidateMetadata</code><br>这里就轮到SpringMvcContract组件闪亮登场了，他负责对<code>ReqeustMapping</code>、<code>PathVaraiable</code>等注解的解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseContract</span> <span class="keyword">implements</span> <span class="title">Contract</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;MethodMetadata&gt; <span class="title">parseAndValidatateMetadata</span><span class="params">(Class&lt;?&gt; targetType)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, MethodMetadata&gt; result = <span class="keyword">new</span> LinkedHashMap&lt;String, MethodMetadata&gt;();</span><br><span class="line">    <span class="comment">// 使用反射，遍历ServiceAClient的每个方法  </span></span><br><span class="line">    <span class="keyword">for</span> (Method method : targetType.getMethods()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (method.getDeclaringClass() == Object.class ||</span><br><span class="line">          (method.getModifiers() &amp; Modifier.STATIC) != <span class="number">0</span> ||</span><br><span class="line">          Util.isDefault(method)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 调用SpringMvcContract来具体处理注解  </span></span><br><span class="line">      MethodMetadata metadata = parseAndValidateMetadata(targetType, method);</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      result.put(metadata.configKey(), metadata);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(result.values());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>通过反射遍历ServiceAClient中的每个方法，然后委托给<code>SpringMvcContract#parseValidateMetadata</code>处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringMvcContract</span> <span class="keyword">extends</span> <span class="title">Contract</span>.<span class="title">BaseContract</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    @<span class="title">Override</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">MethodMetadata</span> <span class="title">parseAndValidateMetadata</span>(<span class="title">Class</span>&lt;?&gt; <span class="title">targetType</span>, <span class="title">Method</span> <span class="title">method</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.processedMethods.put(Feign.configKey(targetType, method), method);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 又调回父类方法了</span></span><br><span class="line">       MethodMetadata md = <span class="keyword">super</span>.parseAndValidateMetadata(targetType, method);</span><br><span class="line">       RequestMapping classAnnotation = findMergedAnnotation(targetType,</span><br><span class="line">             RequestMapping.class);</span><br><span class="line">       <span class="keyword">if</span> (classAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// produces - use from class annotation only if method has not specified this</span></span><br><span class="line">          <span class="keyword">if</span> (!md.template().headers().containsKey(ACCEPT)) &#123;</span><br><span class="line">             parseProduces(md, method, classAnnotation);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// consumes -- use from class annotation only if method has not specified this</span></span><br><span class="line">          <span class="keyword">if</span> (!md.template().headers().containsKey(CONTENT_TYPE)) &#123;</span><br><span class="line">             parseConsumes(md, method, classAnnotation);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// headers -- class annotation is inherited to methods, always write these if</span></span><br><span class="line">          <span class="comment">// present</span></span><br><span class="line">          parseHeaders(md, method, classAnnotation);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> md;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>Feign的封装当真是山路十八弯，父类子类各种相互调用，这点儿一点也不优雅</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> MethodMetadata <span class="title">parseAndValidateMetadata</span><span class="params">(Class&lt;?&gt; targetType, Method method)</span> </span>&#123;</span><br><span class="line">  MethodMetadata data = <span class="keyword">new</span> MethodMetadata();</span><br><span class="line">  data.returnType(Types.resolve(targetType, targetType, method.getGenericReturnType()));</span><br><span class="line">  data.configKey(Feign.configKey(targetType, method));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (targetType.getInterfaces().length == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//  解析ServiceAClient类上的`RequestMapping`注解 </span></span><br><span class="line">    processAnnotationOnClass(data, targetType.getInterfaces()[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  processAnnotationOnClass(data, targetType);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析ServiceAClient方法上的`RequestMapping`注解</span></span><br><span class="line">  <span class="keyword">for</span> (Annotation methodAnnotation : method.getAnnotations()) &#123;</span><br><span class="line">    processAnnotationOnMethod(data, methodAnnotation, method);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">  Type[] genericParameterTypes = method.getGenericParameterTypes();</span><br><span class="line"></span><br><span class="line">  Annotation[][] parameterAnnotations = method.getParameterAnnotations();</span><br><span class="line">  <span class="keyword">int</span> count = parameterAnnotations.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> isHttpAnnotation = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (parameterAnnotations[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">      isHttpAnnotation = processAnnotationsOnParameter(data, parameterAnnotations[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (parameterTypes[i] == URI.class) &#123;</span><br><span class="line">      data.urlIndex(i);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isHttpAnnotation &amp;&amp; parameterTypes[i] != Request.Options.class) &#123;</span><br><span class="line">     </span><br><span class="line">      data.bodyIndex(i);</span><br><span class="line">      data.bodyType(Types.resolve(targetType, targetType, genericParameterTypes[i]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>解析ServiceAClient类上的<code>RequestMapping</code>注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processAnnotationOnClass</span><span class="params">(MethodMetadata data, Class&lt;?&gt; clz)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (clz.getInterfaces().length == <span class="number">0</span>) &#123;</span><br><span class="line">      RequestMapping classAnnotation = findMergedAnnotation(clz,</span><br><span class="line">            RequestMapping.class);</span><br><span class="line">      <span class="keyword">if</span> (classAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// Prepend path from class annotation if specified</span></span><br><span class="line">         <span class="keyword">if</span> (classAnnotation.value().length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            String pathValue = emptyToNull(classAnnotation.value()[<span class="number">0</span>]);</span><br><span class="line">            pathValue = resolve(pathValue);</span><br><span class="line">            <span class="keyword">if</span> (!pathValue.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">               pathValue = <span class="string">"/"</span> + pathValue;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里template()其实是一个RequestTemplate </span></span><br><span class="line">            data.template().uri(pathValue);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里其实就是将ServiceAClient类上面<code>RequestMapping</code>注解中解析出<code>url</code>，然后将他发到Feign的<code>RequestTemplate</code>组件中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processAnnotationOnMethod</span><span class="params">(MethodMetadata data,</span></span></span><br><span class="line"><span class="function"><span class="params">      Annotation methodAnnotation, Method method)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   RequestMapping methodMapping = findMergedAnnotation(method, RequestMapping.class);</span><br><span class="line">   <span class="comment">// HTTP Method</span></span><br><span class="line">   RequestMethod[] methods = methodMapping.method();</span><br><span class="line">   <span class="comment">// 如果你没有在`RequestMapping`里指定方法类型，那么默认就是GET方法 </span></span><br><span class="line">   <span class="keyword">if</span> (methods.length == <span class="number">0</span>) &#123;</span><br><span class="line">      methods = <span class="keyword">new</span> RequestMethod[] &#123; RequestMethod.GET &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 解析你在`RequestMapping`里指定的method类型，放到RequestTemplate中的method中去</span></span><br><span class="line">   data.template().method(Request.HttpMethod.valueOf(methods[<span class="number">0</span>].name()));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 解析你在RequestMapping中的path，拼接成url，放到RequestTemplate中的URL中去</span></span><br><span class="line">   <span class="keyword">if</span> (methodMapping.value().length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      String pathValue = emptyToNull(methodMapping.value()[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">if</span> (pathValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">         pathValue = resolve(pathValue);</span><br><span class="line">         <span class="comment">// Append path from @RequestMapping if value is present on method</span></span><br><span class="line">         <span class="keyword">if</span> (!pathValue.startsWith(<span class="string">"/"</span>) &amp;&amp; !data.template().path().endsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">            pathValue = <span class="string">"/"</span> + pathValue;</span><br><span class="line">         &#125;</span><br><span class="line">         data.template().uri(pathValue, <span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 解析RequestMapping注解里的produces属性，将这些属性放到RequestTemplate中的header中的ACCEPT值里</span></span><br><span class="line">   parseProduces(data, method, methodMapping);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 解析RequestMappinp注解的consumes属性，将这些属性放到RequestTemplate中的header中的CONTENT_TYPE值的</span></span><br><span class="line">   parseConsumes(data, method, methodMapping);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 解析RequestMapping注解的headers属性，将这些属性放到RequestTemplate中的header键值对里去</span></span><br><span class="line">   parseHeaders(data, method, methodMapping);</span><br><span class="line"></span><br><span class="line">   data.indexToExpander(<span class="keyword">new</span> LinkedHashMap&lt;Integer, Param.Expander&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>解析ServiceAClient中方法上的RequestMapping注解里各项属性<ul><li>如果你没有指定方法类型，那么默认就是GET方法 </li><li>解析method类型，放到RequestTemplate中的method中去</li><li>解析path，拼接成url，放到RequestTemplate中的URL中去</li><li>解析produces属性，将这些属性放到RequestTemplate中的header中的ACCEPT值里</li><li>解析consumes属性，将这些属性放到RequestTemplate中的header中的CONTENT_TYPE值的</li><li>解析headers属性，将这些属性放到RequestTemplate中的header键值对里去</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">processAnnotationsOnParameter</span><span class="params">(MethodMetadata data,</span></span></span><br><span class="line"><span class="function"><span class="params">      Annotation[] annotations, <span class="keyword">int</span> paramIndex)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">boolean</span> isHttpAnnotation = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">   AnnotatedParameterProcessor.AnnotatedParameterContext context = <span class="keyword">new</span> SimpleAnnotatedParameterContext(</span><br><span class="line">         data, paramIndex);</span><br><span class="line">   Method method = <span class="keyword">this</span>.processedMethods.get(data.configKey());</span><br><span class="line">   <span class="keyword">for</span> (Annotation parameterAnnotation : annotations) &#123;</span><br><span class="line">      AnnotatedParameterProcessor processor = <span class="keyword">this</span>.annotatedArgumentProcessors</span><br><span class="line">            .get(parameterAnnotation.annotationType());</span><br><span class="line">      <span class="keyword">if</span> (processor != <span class="keyword">null</span>) &#123;</span><br><span class="line">         Annotation processParameterAnnotation;</span><br><span class="line">         <span class="comment">// synthesize, handling @AliasFor, while falling back to parameter name on</span></span><br><span class="line">         <span class="comment">// missing String #value():</span></span><br><span class="line">         processParameterAnnotation = synthesizeWithMethodParameterNameAsFallbackValue(</span><br><span class="line">               parameterAnnotation, method, paramIndex);</span><br><span class="line">         isHttpAnnotation |= processor.processArgument(context,</span><br><span class="line">               processParameterAnnotation, method);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (isHttpAnnotation &amp;&amp; data.indexToExpander().get(paramIndex) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      TypeDescriptor typeDescriptor = createTypeDescriptor(method, paramIndex);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.conversionService.canConvert(typeDescriptor,</span><br><span class="line">            STRING_TYPE_DESCRIPTOR)) &#123;</span><br><span class="line">         Param.Expander expander = <span class="keyword">this</span>.convertingExpanderFactory</span><br><span class="line">               .getExpander(typeDescriptor);</span><br><span class="line">         <span class="keyword">if</span> (expander != <span class="keyword">null</span>) &#123;</span><br><span class="line">            data.indexToExpander().put(paramIndex, expander);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> isHttpAnnotation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>解析ServiceAClient中方法上的入参</p><ul><li>默认的参数处理器，这几个处理器都是spring-cloud-openfeign-core工程的<ul><li>解析<code>@PathVariable</code>：<code>PathVariableParameterProcessor</code></li><li>解析<code>@RequestParam</code>：<code>RequestParamParameterProcessor</code></li><li>解析<code>@ReqeustHeader</code>：<code>RequestHeaderParameterProcessor</code></li><li>解析<code>@QueryMap</code>:<code>QueryMapParameterProcessor</code></li></ul></li></ul></li><li><p><code>result.put(md.configKey(), factory.create(key, md, buildTemplate, options, decoder, errorDecoder));</code></p><ul><li><p>create方法其实创建了一个<code>SynchronousMethodHandler</code>，将所有和serviceAClient中一个方法相关的东西都放了进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronousMethodHandler</span></span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">Factory</span></span></span><br><span class="line"><span class="class">        <span class="title">public</span> <span class="title">MethodHandler</span> <span class="title">create</span>(<span class="title">Target</span>&lt;?&gt; <span class="title">target</span>,</span></span><br><span class="line"><span class="class">                                    <span class="title">MethodMetadata</span> <span class="title">md</span>,</span></span><br><span class="line"><span class="class">                                    <span class="title">RequestTemplate</span>.<span class="title">Factory</span> <span class="title">buildTemplateFromArgs</span>,</span></span><br><span class="line"><span class="class">                                    <span class="title">Options</span> <span class="title">options</span>,</span></span><br><span class="line"><span class="class">                                    <span class="title">Decoder</span> <span class="title">decoder</span>,</span></span><br><span class="line"><span class="class">                                    <span class="title">ErrorDecoder</span> <span class="title">errorDecoder</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> SynchronousMethodHandler(target, client, retryer, requestInterceptors, logger,</span><br><span class="line">              logLevel, md, buildTemplateFromArgs, options, decoder,</span><br><span class="line">              errorDecoder, decode404, closeAfterDecode, propagationPolicy);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>feign对FeignClient的创建过程，个人觉得封装的并不是很优雅，山路十八弯，各种父子类调用，很容易让源码阅读者绕晕。<br>按照惯例，笔者放出总结大图一张。<br><img src="/blog/2020/05/19/声明式接口调用：Feign源码剖析（2）基于JDK动态代理构建FeignClient的过程/Feign-FeignClient%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B.png" alt="Feign-FeignClient动态代理创建过程"></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;上文我们已经分析到&lt;code&gt;FeignClientFactoryBean#getTarget()&lt;/code&gt;方法，这里完成了FeignClient动态代理的创建。但并未分析具体的创建过程，本文将深入Feign Core将FeignClient到底是如何被创建出来的给摸清楚。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Feign" scheme="http://houqian.github.io/tags/Feign/"/>
    
  </entry>
  
  <entry>
    <title>声明式接口调用：Feign源码剖析（1）@FeignClient注解</title>
    <link href="http://houqian.github.io/2020/05/10/%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%EF%BC%9AFeign%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%881%EF%BC%89@FeignClient%E6%B3%A8%E8%A7%A3/"/>
    <id>http://houqian.github.io/2020/05/10/%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%EF%BC%9AFeign%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%881%EF%BC%89@FeignClient%E6%B3%A8%E8%A7%A3/</id>
    <published>2020-05-10T12:56:11.000Z</published>
    <updated>2021-06-09T07:46:06.246Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="按照SpringCloud集成套路寻找线索"><a href="#按照SpringCloud集成套路寻找线索" class="headerlink" title="按照SpringCloud集成套路寻找线索"></a>按照SpringCloud集成套路寻找线索</h1><blockquote><p>按照Spring的套路，肯定是提供一个<code>EnableXXX</code>的注解开启某项技术，Feign当然也不例外，还记得我们在入门篇里的<code>EnableFeignClients</code>吗？</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(FeignClientsRegistrar.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableFeignClients &#123;</span><br></pre></td></tr></table></figure><ul><li><code>@Import(FeignClientsRegistrar.class)</code><br>还是熟悉的配方-<code>@Import</code>，不用多说，这个肯定是处理<code>FeignClient</code>等注解的类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeignClientsRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">ResourceLoaderAware</span>, <span class="title">EnvironmentAware</span></span></span><br><span class="line"><span class="class">    @<span class="title">Override</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">void</span> <span class="title">registerBeanDefinitions</span>(<span class="title">AnnotationMetadata</span> <span class="title">metadata</span>,</span></span><br><span class="line"><span class="class"><span class="title">BeanDefinitionRegistry</span> <span class="title">registry</span>) </span>&#123;</span><br><span class="line">    registerDefaultConfiguration(metadata, registry);</span><br><span class="line">    registerFeignClients(metadata, registry);</span><br><span class="line">  &#125;]</span><br></pre></td></tr></table></figure><ul><li>这里的<code>FeignClientsRegistar</code>实现了Spring的一堆接口，我们先不管那么多，只关心这个<code>registerBeanDefinitions</code><br>这里显然就是Spring将扫描到的注解元数据和他的注册表一起交给了我们，让我们根据自己的需要（此处就是处理被<code>@FeignClient</code>等情况）处理。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeignClientsRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">ResourceLoaderAware</span>, <span class="title">EnvironmentAware</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">private</span> <span class="title">void</span> <span class="title">registerDefaultConfiguration</span>(<span class="title">AnnotationMetadata</span> <span class="title">metadata</span>,</span></span><br><span class="line"><span class="class"><span class="title">BeanDefinitionRegistry</span> <span class="title">registry</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 此处显然就是根据EnableFeignClients这个注解名，从当前这个注解元数据中获取对应的属性</span></span><br><span class="line">    Map&lt;String, Object&gt; defaultAttrs = metadata</span><br><span class="line">        .getAnnotationAttributes(EnableFeignClients.class.getName(), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (defaultAttrs != <span class="keyword">null</span> &amp;&amp; defaultAttrs.containsKey(<span class="string">"defaultConfiguration"</span>)) &#123;</span><br><span class="line">      String name;</span><br><span class="line">      <span class="keyword">if</span> (metadata.hasEnclosingClass()) &#123;</span><br><span class="line">        name = <span class="string">"default."</span> + metadata.getEnclosingClassName();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        name = <span class="string">"default."</span> + metadata.getClassName();</span><br><span class="line">      &#125;</span><br><span class="line">      registerClientConfiguration(registry, name,</span><br><span class="line">          defaultAttrs.get(<span class="string">"defaultConfiguration"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><p>看看当前注解是不是<code>EnableFeignClients</code></p></li><li><p>如果是，并且指定了<code>defaultConfiguration</code>这个属性的话，那就将这个属性处理一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeignClientsRegistrar</span></span></span><br><span class="line"><span class="class"><span class="title">private</span> <span class="title">void</span> <span class="title">registerClientConfiguration</span>(<span class="title">BeanDefinitionRegistry</span> <span class="title">registry</span>, <span class="title">Object</span> <span class="title">name</span>,</span></span><br><span class="line"><span class="class"><span class="title">Object</span> <span class="title">configuration</span>) </span>&#123;</span><br><span class="line">    BeanDefinitionBuilder builder = BeanDefinitionBuilder</span><br><span class="line">        .genericBeanDefinition(FeignClientSpecification.class);</span><br><span class="line">    builder.addConstructorArgValue(name);</span><br><span class="line">    builder.addConstructorArgValue(configuration);</span><br><span class="line">    registry.registerBeanDefinition(</span><br><span class="line">        name + <span class="string">"."</span> + FeignClientSpecification.class.getSimpleName(),</span><br><span class="line">        builder.getBeanDefinition());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><p>依旧是熟悉的配方，和Ribbon的处理简直一模一样。将这个<code>defaultConfiguration</code>封装成一个<code>FeignClientSpecification</code>，然后注册到容器中。</p><blockquote><p>如果还记得之前的文章，这里肯定在后续会有一个刷新上下文的操作，只有那个时候才会真正的实例化这些bean</p></blockquote></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeignClientsRegistrar</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">void</span> <span class="title">registerFeignClients</span>(<span class="title">AnnotationMetadata</span> <span class="title">metadata</span>,</span></span><br><span class="line"><span class="class">          <span class="title">BeanDefinitionRegistry</span> <span class="title">registry</span>) </span>&#123;</span><br><span class="line">       ClassPathScanningCandidateComponentProvider scanner = getScanner();</span><br><span class="line">       scanner.setResourceLoader(<span class="keyword">this</span>.resourceLoader);</span><br><span class="line"></span><br><span class="line">       Set&lt;String&gt; basePackages;</span><br><span class="line">    </span><br><span class="line">       Map&lt;String, Object&gt; attrs = metadata</span><br><span class="line">             .getAnnotationAttributes(EnableFeignClients.class.getName());</span><br><span class="line">      </span><br><span class="line">       AnnotationTypeFilter annotationTypeFilter = <span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">             FeignClient.class);</span><br><span class="line">       <span class="keyword">final</span> Class&lt;?&gt;[] clients = attrs == <span class="keyword">null</span> ? <span class="keyword">null</span></span><br><span class="line">             : (Class&lt;?&gt;[]) attrs.get(<span class="string">"clients"</span>);</span><br><span class="line">       <span class="keyword">if</span> (clients == <span class="keyword">null</span> || clients.length == <span class="number">0</span>) &#123;</span><br><span class="line">          scanner.addIncludeFilter(annotationTypeFilter);</span><br><span class="line">          <span class="comment">// 这里就是处理下EnableFeignClients里咱们指定的那个basePackages，将咱们配的属性值收集起来</span></span><br><span class="line">          basePackages = getBasePackages(metadata);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">final</span> Set&lt;String&gt; clientClasses = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">          basePackages = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">          <span class="keyword">for</span> (Class&lt;?&gt; clazz : clients) &#123;</span><br><span class="line">             basePackages.add(ClassUtils.getPackageName(clazz));</span><br><span class="line">             clientClasses.add(clazz.getCanonicalName());</span><br><span class="line">          &#125;</span><br><span class="line">          AbstractClassTestingTypeFilter filter = <span class="keyword">new</span> AbstractClassTestingTypeFilter() &#123;</span><br><span class="line">             <span class="meta">@Override</span></span><br><span class="line">             <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(ClassMetadata metadata)</span> </span>&#123;</span><br><span class="line">                String cleaned = metadata.getClassName().replaceAll(<span class="string">"\\$"</span>, <span class="string">"."</span>);</span><br><span class="line">                <span class="keyword">return</span> clientClasses.contains(cleaned);</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;;</span><br><span class="line">          scanner.addIncludeFilter(</span><br><span class="line">                <span class="keyword">new</span> AllTypeFilter(Arrays.asList(filter, annotationTypeFilter)));</span><br><span class="line">       &#125;</span><br><span class="line">     </span><br><span class="line">       <span class="comment">// 这里就到了真正处理basePackages的地方了</span></span><br><span class="line">       <span class="comment">// 不难推测，肯定就是将这个路径下的所有被FeignClient注解修饰的类都特殊处理一把</span></span><br><span class="line">       <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">          Set&lt;BeanDefinition&gt; candidateComponents = scanner</span><br><span class="line">                .findCandidateComponents(basePackage);</span><br><span class="line">          <span class="keyword">for</span> (BeanDefinition candidateComponent : candidateComponents) &#123;</span><br><span class="line">             <span class="keyword">if</span> (candidateComponent <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                <span class="comment">// verify annotated class is an interface</span></span><br><span class="line">                AnnotatedBeanDefinition beanDefinition = (AnnotatedBeanDefinition) candidateComponent;</span><br><span class="line">                AnnotationMetadata annotationMetadata = beanDefinition.getMetadata();</span><br><span class="line">                Assert.isTrue(annotationMetadata.isInterface(),</span><br><span class="line">                      <span class="string">"@FeignClient can only be specified on an interface"</span>);</span><br><span class="line"></span><br><span class="line">                Map&lt;String, Object&gt; attributes = annotationMetadata</span><br><span class="line">                      .getAnnotationAttributes(</span><br><span class="line">                            FeignClient.class.getCanonicalName());</span><br><span class="line"></span><br><span class="line">                String name = getClientName(attributes);</span><br><span class="line">                 <span class="comment">// 这里其实和上面相同，就是把咱们在FeignClient里指定的自定义configuration给包装成那个FeignClientSpecification</span></span><br><span class="line">                 <span class="comment">// 然后搞到Spring容器中去</span></span><br><span class="line">                registerClientConfiguration(registry, name,</span><br><span class="line">                      attributes.get(<span class="string">"configuration"</span>));</span><br><span class="line">        </span><br><span class="line">                registerFeignClient(registry, annotationMetadata, attributes);</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>处理<code>EnableFeignClients</code>中指定的<code>basePackages</code></p></li><li><p>将所有该路径下被<code>FeignClient</code>注解修饰的类做如下处理</p><ul><li><p>将用户自定义的<code>configuration</code>包装成<code>FeignClientSpecification</code>注册到Spring上下文中</p></li><li><p>包装一个<code>FeignClientFactoryBean</code>代表此类，注册到上下文中去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeignClientsRegistrar</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">void</span> <span class="title">registerFeignClient</span>(<span class="title">BeanDefinitionRegistry</span> <span class="title">registry</span>,</span></span><br><span class="line"><span class="class">          <span class="title">AnnotationMetadata</span> <span class="title">annotationMetadata</span>, <span class="title">Map</span>&lt;<span class="title">String</span>, <span class="title">Object</span>&gt; <span class="title">attributes</span>) </span>&#123;</span><br><span class="line">       String className = annotationMetadata.getClassName();</span><br><span class="line">       BeanDefinitionBuilder definition = BeanDefinitionBuilder</span><br><span class="line">             .genericBeanDefinition(FeignClientFactoryBean.class);</span><br><span class="line">       validate(attributes);</span><br><span class="line">       definition.addPropertyValue(<span class="string">"url"</span>, getUrl(attributes));</span><br><span class="line">       definition.addPropertyValue(<span class="string">"path"</span>, getPath(attributes));</span><br><span class="line">       String name = getName(attributes);</span><br><span class="line">       definition.addPropertyValue(<span class="string">"name"</span>, name);</span><br><span class="line">       String contextId = getContextId(attributes);</span><br><span class="line">       definition.addPropertyValue(<span class="string">"contextId"</span>, contextId);</span><br><span class="line">       definition.addPropertyValue(<span class="string">"type"</span>, className);</span><br><span class="line">       definition.addPropertyValue(<span class="string">"decode404"</span>, attributes.get(<span class="string">"decode404"</span>));</span><br><span class="line">       definition.addPropertyValue(<span class="string">"fallback"</span>, attributes.get(<span class="string">"fallback"</span>));</span><br><span class="line">       definition.addPropertyValue(<span class="string">"fallbackFactory"</span>, attributes.get(<span class="string">"fallbackFactory"</span>));</span><br><span class="line">       definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line"></span><br><span class="line">       String alias = contextId + <span class="string">"FeignClient"</span>;</span><br><span class="line">       AbstractBeanDefinition beanDefinition = definition.getBeanDefinition();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">boolean</span> primary = (Boolean) attributes.get(<span class="string">"primary"</span>); <span class="comment">// has a default, won't be</span></span><br><span class="line">                                                 <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">       beanDefinition.setPrimary(primary);</span><br><span class="line"></span><br><span class="line">       String qualifier = getQualifier(attributes);</span><br><span class="line">       <span class="keyword">if</span> (StringUtils.hasText(qualifier)) &#123;</span><br><span class="line">          alias = qualifier;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       BeanDefinitionHolder holder = <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, className,</span><br><span class="line">             <span class="keyword">new</span> String[] &#123; alias &#125;);</span><br><span class="line">       BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>这里的处理属于核心逻辑了，一看就是根据注解的属性值，构建出一个<code>FeignClientFactoryBean</code>，然后注册到Spring上下文中去</li></ul></li></ul></li></ul><h1 id="找到了核心组件FeignClientFactoryBean"><a href="#找到了核心组件FeignClientFactoryBean" class="headerlink" title="找到了核心组件FeignClientFactoryBean"></a>找到了核心组件<code>FeignClientFactoryBean</code></h1><blockquote><p>按照Spring惯例，一般叫xxFactoryBean的东东作用就是为了创建这个bean而提供的一种工厂类抽象。<br>一般情况下是用不到的，但如果这个bean的构建比较复杂，那使用这个<code>FactoryBean</code>接口是非常恰当的。他的主要方法就是一个<code>getObject()</code>，获取这个bean实例，简单粗暴。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeignClientFactoryBean</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Object</span>&gt;, <span class="title">InitializingBean</span>, <span class="title">ApplicationContextAware</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    @<span class="title">Override</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">Object</span> <span class="title">getObject</span>() <span class="title">throws</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> getTarget();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>这个<code>getTarget()</code>就是我们关心的核心逻辑了，猜测一下肯定是创建了FeignClient（或者代理类？）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeignClientFactoryBean</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    &lt;<span class="title">T</span>&gt; <span class="title">T</span> <span class="title">getTarget</span>() </span>&#123;</span><br><span class="line">       FeignContext context = <span class="keyword">this</span>.applicationContext.getBean(FeignContext.class);</span><br><span class="line">       <span class="comment">// 就是用Spring之前自动配置的那些Feign组件，比如编解码器、协议之类的东东构建一个Feign的构造器</span></span><br><span class="line">       <span class="comment">// 这里还将咱们在配置文件里配置的feign.client开头的那些配置也一并搞到这个Feign构造器里去了</span></span><br><span class="line">       Feign.Builder builder = feign(context);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!StringUtils.hasText(<span class="keyword">this</span>.url)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!<span class="keyword">this</span>.name.startsWith(<span class="string">"http"</span>)) &#123;</span><br><span class="line">             <span class="keyword">this</span>.url = <span class="string">"http://"</span> + <span class="keyword">this</span>.name;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">this</span>.url = <span class="keyword">this</span>.name;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 处理url，最后的url形式是`http://serviceA` </span></span><br><span class="line">          <span class="keyword">this</span>.url += cleanPath();</span><br><span class="line">          <span class="keyword">return</span> (T) loadBalance(builder, context,</span><br><span class="line">                <span class="keyword">new</span> HardCodedTarget&lt;&gt;(<span class="keyword">this</span>.type, <span class="keyword">this</span>.name, <span class="keyword">this</span>.url));</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">       <span class="comment">// 如果你在`FeignClient`注解里指定`url`属性，那么会走一段逻辑，这个不常用，我们先不用看了</span></span><br><span class="line">       <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.url) &amp;&amp; !<span class="keyword">this</span>.url.startsWith(<span class="string">"http"</span>)) &#123;</span><br><span class="line">          <span class="keyword">this</span>.url = <span class="string">"http://"</span> + <span class="keyword">this</span>.url;</span><br><span class="line">       &#125;</span><br><span class="line">       String url = <span class="keyword">this</span>.url + cleanPath();</span><br><span class="line">       Client client = getOptional(context, Client.class);</span><br><span class="line">       <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (client <span class="keyword">instanceof</span> LoadBalancerFeignClient) &#123;</span><br><span class="line">             <span class="comment">// not load balancing because we have a url,</span></span><br><span class="line">             <span class="comment">// but ribbon is on the classpath, so unwrap</span></span><br><span class="line">             client = ((LoadBalancerFeignClient) client).getDelegate();</span><br><span class="line">          &#125;</span><br><span class="line">          builder.client(client);</span><br><span class="line">       &#125;</span><br><span class="line">       Targeter targeter = get(context, Targeter.class);</span><br><span class="line">       <span class="keyword">return</span> (T) targeter.target(<span class="keyword">this</span>, builder, context,</span><br><span class="line">             <span class="keyword">new</span> HardCodedTarget&lt;&gt;(<span class="keyword">this</span>.type, <span class="keyword">this</span>.name, url));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>loadBalance</code></p><blockquote><p>这是非常关键的一个方法，完成了创建Feign动态代理的逻辑，不过此处我们先不用关心</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeignClientFactoryBean</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class"><span class="title">protected</span> &lt;<span class="title">T</span>&gt; <span class="title">T</span> <span class="title">loadBalance</span>(<span class="title">Feign</span>.<span class="title">Builder</span> <span class="title">builder</span>, <span class="title">FeignContext</span> <span class="title">context</span>,</span></span><br><span class="line"><span class="class"><span class="title">HardCodedTarget</span>&lt;<span class="title">T</span>&gt; <span class="title">target</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 此处获取到的就是那个LoadBalancerFeignClient</span></span><br><span class="line">    Client client = getOptional(context, Client.class);</span><br><span class="line">    <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">      builder.client(client);</span><br><span class="line">            <span class="comment">// 此处获取到的其实就是那个HystrixTargeter</span></span><br><span class="line">      Targeter targeter = get(context, Targeter.class);</span><br><span class="line">      <span class="keyword">return</span> targeter.target(<span class="keyword">this</span>, builder, context, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">        <span class="string">"No Feign Client for loadBalancing defined. Did you forget to include spring-cloud-starter-netflix-ribbon?"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/blog/2020/05/10/声明式接口调用：Feign源码剖析（1）@FeignClient注解/FeignClient%E6%B3%A8%E8%A7%A3%E5%8E%9F%E7%90%86.png" alt="FeignClient注解原理"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;按照SpringCloud集成套路寻找线索&quot;&gt;&lt;a href=&quot;#按照SpringCloud集成套路寻找线索&quot; class=&quot;headerlink&quot; title=&quot;按照SpringCloud集成套路寻找线索&quot;&gt;&lt;/a&gt;按照SpringCloud集成套路寻找线索&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;按照Spring的套路，肯定是提供一个&lt;code&gt;EnableXXX&lt;/code&gt;的注解开启某项技术，Feign当然也不例外，还记得我们在入门篇里的&lt;code&gt;EnableFeignClients&lt;/code&gt;吗？&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Feign" scheme="http://houqian.github.io/tags/Feign/"/>
    
  </entry>
  
  <entry>
    <title>声明式接口调用：Feign入门</title>
    <link href="http://houqian.github.io/2020/05/06/%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%EF%BC%9AFeign%E5%85%A5%E9%97%A8/"/>
    <id>http://houqian.github.io/2020/05/06/%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%EF%BC%9AFeign%E5%85%A5%E9%97%A8/</id>
    <published>2020-05-06T06:35:21.000Z</published>
    <updated>2021-06-09T07:45:57.674Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Feign解决了什么问题"><a href="#Feign解决了什么问题" class="headerlink" title="Feign解决了什么问题"></a>Feign解决了什么问题</h1><p>一个服务里要调用别的HTTP接口，每次要手写一些重复的HTTP处理逻辑，比如我们如果单独用Ribbon调用别的服务，就需要每次写这样一坨代码</p><p><code>String result = restTemplate.getForObject(&quot;http://ServiceName/InterfacePath&quot;, String.class);</code><br>虽然Spring的<code>RestTemplate</code>已经将HTTP调用的代码成本降到很低了，但如果极致一些，完全不写行不行？答案是可以。Feign就是提我们完成这件事情的不二之选。</p><a id="more"></a><h1 id="快速体验Feign"><a href="#快速体验Feign" class="headerlink" title="快速体验Feign"></a>快速体验Feign</h1><p>此次我们依然在以前的示例上添加代码，这样就可以将精力放到体会Feign的特性上了。</p><h2 id="1、给ServiceA加几个接口"><a href="#1、给ServiceA加几个接口" class="headerlink" title="1、给ServiceA加几个接口"></a>1、给ServiceA加几个接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">createUser</span><span class="params">(@RequestBody User user)</span> </span>&#123;</span><br><span class="line">    Integer port = environment.getProperty(<span class="string">"local.server.port"</span>, Integer.class);</span><br><span class="line">    System.out.println(<span class="string">"创建用户，"</span> + user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"&#123;'msg': 'success', 'from': "</span> + port + <span class="string">"&#125;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PutMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">updateUser</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id, @RequestBody User user) </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"更新用户，id:"</span> + id);</span><br><span class="line">    Integer port = environment.getProperty(<span class="string">"local.server.port"</span>, Integer.class);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"&#123;'msg': 'success', 'from': "</span> + port + <span class="string">"&#125;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@DeleteMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">deleteUser</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id) </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"删除用户，id:"</span> + id);</span><br><span class="line">    Integer port = environment.getProperty(<span class="string">"local.server.port"</span>, Integer.class);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"&#123;'msg': 'success', 'from': "</span> + port + <span class="string">"&#125;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span>Long id) </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"查询用户，id:"</span> + id);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">"sam"</span>, <span class="number">25</span>, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username, Integer age, Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"username='"</span> + username + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、重构ServiceB：基于Feign调用ServiceA"><a href="#2、重构ServiceB：基于Feign调用ServiceA" class="headerlink" title="2、重构ServiceB：基于Feign调用ServiceA"></a>2、重构ServiceB：基于Feign调用ServiceA</h2><p>在serviceB的pom.xml中添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在启动类中添加<code>@FeignClients</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@EnableFeignClients</span>(basePackages = &#123;<span class="string">"cc.houqian.eurekalearn.client"</span>&#125;)</span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ServiceBApplication.class, args);</span><br><span class="line">        log.info(<span class="string">"ServiceB 启动成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建一个Feign客户端类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(<span class="string">"serviceA"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceAClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/sayHello/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(@PathVariable(<span class="string">"name"</span>)</span> String name)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="function">String <span class="title">createUser</span><span class="params">(@RequestBody User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function">String <span class="title">updateUser</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id,</span></span><br><span class="line"><span class="function">                      @RequestBody User user)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function">String <span class="title">deleteUser</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function">User <span class="title">getById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String username;</span><br><span class="line">        <span class="keyword">private</span> Integer age;</span><br><span class="line">        <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username, Integer age, Long id)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.username = username;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> username;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.username = username;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                    <span class="string">"username='"</span> + username + <span class="string">'\''</span> +</span><br><span class="line">                    <span class="string">", age="</span> + age +</span><br><span class="line">                    <span class="string">'&#125;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改造接口调用处，使用Feign客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ServiceAClient serviceAClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/greeting/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">greeting</span><span class="params">(@PathVariable(<span class="string">"name"</span>)</span> String name) </span>&#123;</span><br><span class="line"><span class="comment">//        String response = restTemplate.getForObject("http://serviceA/sayHello/" + name, String.class);</span></span><br><span class="line">        String response = serviceAClient.sayHello(name);</span><br><span class="line">        log.info(response);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>打开浏览器，访问<code>http://localhost:9000/greeting/sam</code>，你会发现与之前使用<code>RestTemplate</code>时的效果一致</p><p><img src="/blog/2020/05/06/声明式接口调用：Feign入门/%E5%9F%BA%E4%BA%8EFeign%E8%B0%83%E7%94%A8%E6%9C%8D%E5%8A%A1A.png" alt="基于Feign调用服务A"></p><blockquote><p>此处功能已经实现，我们可以再想多一些，还有什么问题？<br>如果serviceA有多个调用方serviceC、D等等，按照现在这个套路，ServiceAClient这个Feign客户端是得每个服务都来一遍，非常不优雅。</p><p>我们可以想一下，提供服务的serviceA肯定是最了解自己的，根据知识专家原则，由他来提供feign客户端供其他消费者调用时合情合理的，这也解决了代码复用的问题。</p><p>所以，我们此时完全可以将ServiceAClient挪到一个新的工程里去，由serviceA自己维护，里面的职责就是维护serviceA一系列的暴露出去的feign客户端，然后让其他服务依赖这个工程，就可以消费serviceA的接口了。</p></blockquote><h2 id="3、Feign的继承特性"><a href="#3、Feign的继承特性" class="headerlink" title="3、Feign的继承特性"></a>3、Feign的继承特性</h2><blockquote><p>在上面，我们讨论了一个更好的做法。其实，Feign能提供的编码体验更为极致，我们上面还有一处代码是重复的，就是serviceA暴露接口的SpringMVC注解代码，现在使用Feign的继承特性，我们只需要定义一处SpringMVC的注解逻辑就可以了，这提供了极致的编码体验，非常的Clean。</p></blockquote><h3 id="（1）单独定义一个工程-service-a-api，定义统一对外暴露的接口和实体类"><a href="#（1）单独定义一个工程-service-a-api，定义统一对外暴露的接口和实体类" class="headerlink" title="（1）单独定义一个工程 service-a-api，定义统一对外暴露的接口和实体类"></a>（1）单独定义一个工程 service-a-api，定义统一对外暴露的接口和实体类</h3><p>依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>service-a-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>服务A对外暴露接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc.houqian.eurekalearn.servicea.client;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意此处不加@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceAInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/sayHello/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(@PathVariable(<span class="string">"name"</span>)</span> String name)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="function">String <span class="title">createUser</span><span class="params">(@RequestBody User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function">String <span class="title">updateUser</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id,</span></span><br><span class="line"><span class="function">                      @RequestBody User user)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function">String <span class="title">deleteUser</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function">User <span class="title">getById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String username;</span><br><span class="line">        <span class="keyword">private</span> Integer age;</span><br><span class="line">        <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username, Integer age, Long id)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.username = username;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> username;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.username = username;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                    <span class="string">"username='"</span> + username + <span class="string">'\''</span> +</span><br><span class="line">                    <span class="string">", age="</span> + age +</span><br><span class="line">                    <span class="string">'&#125;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）ServiceA对定义好的接口实现业务逻辑"><a href="#（2）ServiceA对定义好的接口实现业务逻辑" class="headerlink" title="（2）ServiceA对定义好的接口实现业务逻辑"></a>（2）ServiceA对定义好的接口实现业务逻辑</h3><p>在serviceA的pom.xml中新增依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cc.houqian<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>service-a-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>改造ServiceAController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceAController</span> <span class="keyword">implements</span> <span class="title">ServiceAInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(@PathVariable(<span class="string">"name"</span>)</span> String name) </span>&#123;</span><br><span class="line">        Integer port = environment.getProperty(<span class="string">"local.server.port"</span>, Integer.class);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello,"</span> + name + <span class="string">", came from "</span> + port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">createUser</span><span class="params">(@RequestBody User user)</span> </span>&#123;</span><br><span class="line">        Integer port = environment.getProperty(<span class="string">"local.server.port"</span>, Integer.class);</span><br><span class="line">        System.out.println(<span class="string">"创建用户，"</span> + user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;'msg': 'success', 'from': "</span> + port + <span class="string">"&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">updateUser</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id, @RequestBody User user) </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"更新用户，id:"</span> + id);</span><br><span class="line">        Integer port = environment.getProperty(<span class="string">"local.server.port"</span>, Integer.class);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;'msg': 'success', 'from': "</span> + port + <span class="string">"&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">deleteUser</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id) </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"删除用户，id:"</span> + id);</span><br><span class="line">        Integer port = environment.getProperty(<span class="string">"local.server.port"</span>, Integer.class);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;'msg': 'success', 'from': "</span> + port + <span class="string">"&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id) </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"查询用户，id:"</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">"sam"</span>, <span class="number">25</span>, id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（3）改造ServiceB依赖ServiceA的接口Jar包"><a href="#（3）改造ServiceB依赖ServiceA的接口Jar包" class="headerlink" title="（3）改造ServiceB依赖ServiceA的接口Jar包"></a>（3）改造ServiceB依赖ServiceA的接口Jar包</h3><p>在serviceB的pom.xml中新增依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cc.houqian<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>service-a-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>改造ServiceAClient</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc.houqian.eurekalearn.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cc.houqian.eurekalearn.servicea.client.ServiceAInterface;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient</span>(<span class="string">"serviceA"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceAClient</span> <span class="keyword">extends</span> <span class="title">ServiceAInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（4）实验"><a href="#（4）实验" class="headerlink" title="（4）实验"></a>（4）实验</h3><p>使用POSTMAN，随意调用接口，这里以createUser为例，可以看到基于Feign继承功能的调用是OK的。</p><p><img src="/blog/2020/05/06/声明式接口调用：Feign入门/Feign%E7%BB%A7%E6%89%BF%E5%8A%9F%E8%83%BD%E8%B0%83%E7%94%A8%E7%BB%93%E6%9E%9C.png" alt="Feign继承功能调用结果"></p><h1 id="Feign的自定义配置"><a href="#Feign的自定义配置" class="headerlink" title="Feign的自定义配置"></a>Feign的自定义配置</h1><blockquote><p>Feign提供了请求拦截器的功能，当我们调用的服务，有共性的需求需要处理时，非常适合使用拦截器实现，比如Token获取等。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConf</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RequestInterceptor <span class="title">requestInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyRequestInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRequestInterceptor</span> <span class="keyword">implements</span> <span class="title">RequestInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(RequestTemplate template)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"url:&#123;&#125;"</span>, template.url());</span><br><span class="line">        log.info(<span class="string">"variables:&#123;&#125;"</span>, template.variables());</span><br><span class="line">        log.info(<span class="string">"method:&#123;&#125;"</span>, template.method());</span><br><span class="line">        log.info(<span class="string">"headers:&#123;&#125;"</span>, template.headers());</span><br><span class="line">        log.info(<span class="string">"body:&#123;&#125;"</span>, template.bodyTemplate());</span><br><span class="line">        <span class="comment">// 这里非常适合获取token之类的操作</span></span><br><span class="line">        <span class="comment">// 比如某个三方接口，需要token之类的东西才能访问</span></span><br><span class="line">        <span class="comment">// 你就在这里把token获取到，放到header里就OK了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/blog/2020/05/06/声明式接口调用：Feign入门/Feign%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E9%AA%8C.png" alt="Feign拦截器实验"></p><h1 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h1><blockquote><p>笔者觉得核心组件这种东西完全可以放到入门篇里，因为这是你了解一门技术的必经之路，哪怕入门也是有必要了解的。<br>下面这张图摘录自<a href="https://github.com/OpenFeign/feign#feature-overview" target="_blank" rel="noopener">https://github.com/OpenFeign/feign#feature-overview</a></p></blockquote><p><img src="/blog/2020/05/06/声明式接口调用：Feign入门/Feign%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6.png" alt="Feign核心组件"></p><ul><li>Client（客户端）<br>在SpringCloud环境里就是<code>FeignClient</code>，我们使用Feign最核心的入口。其实，Spring就是帮我们构造了一个FeignClient，里面包含了各种核心组件，比如<code>Encoder</code>、<code>Decoder</code>、<code>Logger</code> 、<code>Contract</code>等待</li><li>Contract（协议）<br>意思是说除了Feign原生的那些API外，他还对各种其他技术做了集成，这个集成好像一个个协议，将Feign的核心API与别的技术连接起来，进行通信。<br>以Spring为例，Feign的核心API肯定不会识别Spring web mvc的各种注解，比如@PatchVariable、@RequestMapping、@RequestParam等，但他通过Spring4或者SpringBoot这些为三方库定制的协议，就可以将Spring的这么些个web注解解释成自己的API了，让人家不用改变自己的使用习惯就可以使用Feign。</li><li>Encoder、Decoder（编码器、解码器）<br>其实就是你调用接口的时候，传递的参数是个对象，feign需要将这个对象进行encode，编码，比如转成一个JSON格式，这就是Encoder的职责。<br>Decoder，解码器，就是你的接口收到一个JSON字符串后，Feign给你转成你定义的对象</li><li>Feign.Builder（图中未列出）<br>Feign Core提供的一个构造器，用来构造一个FeignClient实例</li><li>Logger（图中未列出）<br>Feign Core提供的日志组件</li></ul><h2 id="SpringCloud提供的Feign默认组件"><a href="#SpringCloud提供的Feign默认组件" class="headerlink" title="SpringCloud提供的Feign默认组件"></a>SpringCloud提供的Feign默认组件</h2><blockquote><p>笔者在前面Eureka、Ribbon的系列文章里，已经详细的剖析过SpringCloud整合三方技术的套路了，此处笔者不再赘述，直接给出对应的结论。</p></blockquote><ul><li>Spring提供的默认FeignClient是<code>LoadBalancerFeignClient</code></li><li>Spring提供的默认解码器是<code>ResponseEntityDecoder</code>，带有分页功能的解码器是<code>PageableSpringEncoder</code></li><li>Spring提供的默认编码器是<code>SpringEncoder</code></li><li>Spring提供的默认协议是<code>SpringMvcContract</code></li><li>Spring提供的默认构造器是<code>Feign.Builder</code>（这个就是Feign Core自带的，原生的）</li><li>Spring提供的默认日志组件是<code>Slf4jLogger</code></li></ul><h1 id="常见配置"><a href="#常见配置" class="headerlink" title="常见配置"></a>常见配置</h1><p>超时相关配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      serviceA:</span></span><br><span class="line"><span class="attr">        connectionTimeout:</span> <span class="number">500</span></span><br><span class="line"><span class="attr">        readTimeout:</span> <span class="number">1000</span></span><br><span class="line"><span class="attr">        loggerLevel:</span> <span class="string">full</span></span><br><span class="line"><span class="attr">        decode404:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">      defaul:</span></span><br><span class="line"><span class="attr">        connectionTimeout:</span> <span class="number">500</span></span><br><span class="line"><span class="attr">        readTimeout:</span> <span class="number">1000</span></span><br><span class="line"><span class="attr">        loggerLevel:</span> <span class="string">full</span></span><br><span class="line"><span class="attr">        decode404:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>压缩相关配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">  compression:</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">      enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      mime-types:</span> <span class="string">text/xml.application/xml,application/json</span></span><br><span class="line"><span class="attr">      min-request-size:</span> <span class="number">2048</span></span><br><span class="line"><span class="attr">    response:</span></span><br><span class="line"><span class="attr">      enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      useGzipDecoder:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>日志相关配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 此处配合feign的日志级别使用</span><br><span class="line">logging.level.cc.houqian.eurekalearn.client.ServiceAClient=debug</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConf</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Logger.<span class="function">Level <span class="title">feignLoggerLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// NONE:不打印日志</span></span><br><span class="line">        <span class="comment">// BASIC: 只打印请求方法类型、URL和返回状态码、执行时间</span></span><br><span class="line">        <span class="comment">// HEADERS： 在BASIC的基础上，附加请求、响应的header</span></span><br><span class="line">        <span class="comment">// FULL: 打印所有信息</span></span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果</p><p><img src="/blog/2020/05/06/声明式接口调用：Feign入门/Feign%E7%9A%84FULL%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB%E6%89%93%E5%8D%B0%E6%95%88%E6%9E%9C.png" alt="Feign的FULL日志级别打印效果"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇我们了解如下内容</p><ul><li>Feign的核心概念</li><li>SpringCloud环境下Feign的使用方法<ul><li>Feign的继承功能很好用，开发中经常使用</li></ul></li><li>SpringCloud环境下Feign的默认组件</li><li>SpringCloud环境下Feign的配置</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Feign解决了什么问题&quot;&gt;&lt;a href=&quot;#Feign解决了什么问题&quot; class=&quot;headerlink&quot; title=&quot;Feign解决了什么问题&quot;&gt;&lt;/a&gt;Feign解决了什么问题&lt;/h1&gt;&lt;p&gt;一个服务里要调用别的HTTP接口，每次要手写一些重复的HTTP处理逻辑，比如我们如果单独用Ribbon调用别的服务，就需要每次写这样一坨代码&lt;/p&gt;
&lt;p&gt;&lt;code&gt;String result = restTemplate.getForObject(&amp;quot;http://ServiceName/InterfacePath&amp;quot;, String.class);&lt;/code&gt;&lt;br&gt;虽然Spring的&lt;code&gt;RestTemplate&lt;/code&gt;已经将HTTP调用的代码成本降到很低了，但如果极致一些，完全不写行不行？答案是可以。Feign就是提我们完成这件事情的不二之选。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="Feign" scheme="http://houqian.github.io/tags/Feign/"/>
    
  </entry>
  
  <entry>
    <title>负载均衡：Ribbon总结</title>
    <link href="http://houqian.github.io/2020/05/05/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9ARibbon%E6%80%BB%E7%BB%93/"/>
    <id>http://houqian.github.io/2020/05/05/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9ARibbon%E6%80%BB%E7%BB%93/</id>
    <published>2020-05-05T09:35:21.000Z</published>
    <updated>2021-06-06T16:44:11.707Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>终于，到了和Ribbon系列说再见的时候，笔者任务Ribbon的源码逻辑虽然比Eureka简单一些，但与Spring集成上稍微有点儿绕，主要是自动配置的执行顺序那块儿，如果采用静态代码阅读的方式的话，很难发现问题。不过，这也让笔者对Spring的自动配置机制有了更深的了解。</p><a id="more"></a><hr><p>Ribbon的知识体系笔者认为主要分为4个部分</p><h1 id="组件初始化"><a href="#组件初始化" class="headerlink" title="组件初始化"></a>组件初始化</h1><p><img src="/blog/2020/05/05/负载均衡：Ribbon总结/Ribbon%E7%BB%84%E4%BB%B6%E5%88%9D%E5%A7%8B%E5%8C%96.png" alt="Ribbon组件初始化"></p><h1 id="执行请求"><a href="#执行请求" class="headerlink" title="执行请求"></a>执行请求</h1><p><img src="/blog/2020/05/05/负载均衡：Ribbon总结/Ribbon%E6%89%A7%E8%A1%8C%E8%AF%B7%E6%B1%82.png" alt="Ribbon执行请求"></p><h1 id="定时拉取服务列表"><a href="#定时拉取服务列表" class="headerlink" title="定时拉取服务列表"></a>定时拉取服务列表</h1><p><img src="/blog/2020/05/05/负载均衡：Ribbon总结/Ribbon%E5%AE%9A%E6%97%B6%E6%8B%89%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8.png" alt="Ribbon定时拉取服务列表"></p><h1 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h1><p><img src="/blog/2020/05/05/负载均衡：Ribbon总结/Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95.png" alt="Ribbon负载均衡算法"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;终于，到了和Ribbon系列说再见的时候，笔者任务Ribbon的源码逻辑虽然比Eureka简单一些，但与Spring集成上稍微有点儿绕，主要是自动配置的执行顺序那块儿，如果采用静态代码阅读的方式的话，很难发现问题。不过，这也让笔者对Spring的自动配置机制有了更深的了解。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Ribbon" scheme="http://houqian.github.io/tags/Ribbon/"/>
    
  </entry>
  
  <entry>
    <title>负载均衡：Ribbon源码剖析（4）选举出一个服务后如何发出请求</title>
    <link href="http://houqian.github.io/2020/05/05/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9ARibbon%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%884%EF%BC%89%E9%80%89%E4%B8%BE%E5%87%BA%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%90%8E%E5%A6%82%E4%BD%95%E5%8F%91%E5%87%BA%E8%AF%B7%E6%B1%82/"/>
    <id>http://houqian.github.io/2020/05/05/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9ARibbon%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%884%EF%BC%89%E9%80%89%E4%B8%BE%E5%87%BA%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%90%8E%E5%A6%82%E4%BD%95%E5%8F%91%E5%87%BA%E8%AF%B7%E6%B1%82/</id>
    <published>2020-05-05T04:02:11.000Z</published>
    <updated>2021-06-06T16:44:01.121Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这篇文章算是前面三篇的一个总结，从一个请求被执行的角度，将Spring以及Ribbon的关键组件串起来思考。</p><a id="more"></a><ul><li><code>RestTemplate</code>被加入针对Ribbon的定制的拦截器<code>LoadBalancerInterceptor</code></li><li><code>LoadBalancerInterceptor</code>中将请求委托给<code>RibbonLoadBalancerClient</code></li><li><code>RibbonLoadBalancerClient</code>调用真正的Ribbon组件完成请求<ul><li>负载均衡器<code>ZoneAwareLoadBalancer</code></li><li>负载均衡规则<code>ZoneAvoidanceRule</code></li></ul></li><li><code>request.getURI()</code>–&gt; <code>ServiceRequestWrapper#getURI</code> –&gt; <code>loadBalancer.reconstructURI</code>在这里完成服务名到ip:port的替换</li><li>实际上最后是<code>ClientHttpRequestExecution</code>发起HTTP请求</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>![Ribbon执行请求流程 (1)](负载均衡：Ribbon源码剖析（4）选举出一个服务后如何发出请求/Ribbon执行请求流程 (1).jpg)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇文章算是前面三篇的一个总结，从一个请求被执行的角度，将Spring以及Ribbon的关键组件串起来思考。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Ribbon" scheme="http://houqian.github.io/tags/Ribbon/"/>
    
  </entry>
  
  <entry>
    <title>负载均衡：Ribbon源码剖析（3）默认负载均衡算法可能存在的问题</title>
    <link href="http://houqian.github.io/2020/04/25/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9ARibbon%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%883%EF%BC%89%E9%BB%98%E8%AE%A4%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://houqian.github.io/2020/04/25/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9ARibbon%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%883%EF%BC%89%E9%BB%98%E8%AE%A4%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-04-25T12:11:36.000Z</published>
    <updated>2021-06-06T16:42:41.970Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Ribbon-Eureka感知故障实例的滞后性"><a href="#Ribbon-Eureka感知故障实例的滞后性" class="headerlink" title="Ribbon + Eureka感知故障实例的滞后性"></a>Ribbon + Eureka感知故障实例的滞后性</h1><p>我们先用一张图回顾一下Eureka客户端去Eureka Server拉取服务注册表的情况</p><p><img src="/blog/2020/04/25/负载均衡：Ribbon源码剖析（3）默认负载均衡算法可能存在的问题/Ribbon%E6%84%9F%E7%9F%A5%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B%E6%95%85%E9%9A%9C%E6%9C%80%E9%95%BF%E8%A6%814%E5%88%86%E9%92%9F.jpg" alt="Ribbon感知服务实例故障最长要4分钟"></p><a id="more"></a><ul><li>eureka server在最差情况下要3分钟才能感知到一个实例故障并从服务注册表剔除</li><li>eureka client每隔30秒拉取服务注册表一次</li><li>Spring提供的定时拉取eureka client的注册表，这个定时任务要30秒执行一次</li><li>综上所述，最差情况下Ribbon要4分钟才能感知到一个服务发生故障了</li></ul><blockquote><p>这里的最差情况只会发生在eureka client没有执行shutdown，或者没有调用eureka server对应的下线接口的情况下，这种发生的几率是很小的。</p><p>我们在生产环境中，肯定不是直接kill -9杀死一个服务，而是会做一定的优雅停机，这样的话，一般几十秒左右Ribbon就可以感知到一个服务实例故障，不再去请求这个故障实例了。</p></blockquote><h1 id="Spring是如何应对滞后性的？"><a href="#Spring是如何应对滞后性的？" class="headerlink" title="Spring是如何应对滞后性的？"></a>Spring是如何应对滞后性的？</h1><p>Spring的设计理念是利用Hystrix来填补发往故障实例的请求，直接走对应的降级逻辑，这样就确保不会因为故障实例的问题，导致调用这个故障实例的那些服务长时间不能释放资源，导致服务雪崩。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Ribbon-Eureka感知故障实例的滞后性&quot;&gt;&lt;a href=&quot;#Ribbon-Eureka感知故障实例的滞后性&quot; class=&quot;headerlink&quot; title=&quot;Ribbon + Eureka感知故障实例的滞后性&quot;&gt;&lt;/a&gt;Ribbon + Eureka感知故障实例的滞后性&lt;/h1&gt;&lt;p&gt;我们先用一张图回顾一下Eureka客户端去Eureka Server拉取服务注册表的情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blog/2020/04/25/负载均衡：Ribbon源码剖析（3）默认负载均衡算法可能存在的问题/Ribbon%E6%84%9F%E7%9F%A5%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B%E6%95%85%E9%9A%9C%E6%9C%80%E9%95%BF%E8%A6%814%E5%88%86%E9%92%9F.jpg&quot; alt=&quot;Ribbon感知服务实例故障最长要4分钟&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Ribbon" scheme="http://houqian.github.io/tags/Ribbon/"/>
    
  </entry>
  
  <entry>
    <title>负载均衡：Ribbon源码剖析（2）维护服务列表</title>
    <link href="http://houqian.github.io/2020/04/19/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9ARibbon%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%882%EF%BC%89%E7%BB%B4%E6%8A%A4%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8/"/>
    <id>http://houqian.github.io/2020/04/19/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9ARibbon%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%882%EF%BC%89%E7%BB%B4%E6%8A%A4%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8/</id>
    <published>2020-04-19T14:10:03.000Z</published>
    <updated>2021-06-06T16:43:42.105Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我们上篇已经知道<code>PollingServerListUpdater</code>有可能是负责与Eureka交互定时获取服务列表的，本篇我们就剖析下这个组件相关的逻辑。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PollingServerListUpdater</span> <span class="keyword">implements</span> <span class="title">ServerListUpdater</span></span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">static</span> <span class="title">long</span> <span class="title">LISTOFSERVERS_CACHE_UPDATE_DELAY</span> </span>= <span class="number">1000</span>; <span class="comment">// msecs;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> LISTOFSERVERS_CACHE_REPEAT_INTERVAL = <span class="number">30</span> * <span class="number">1000</span>; <span class="comment">// msecs;</span></span><br></pre></td></tr></table></figure><ul><li>LISTOFSERVERS_CACHE_UPDATE_DELAY<br>服务列表缓存更新延时时间默认是1秒</li><li>LISTOFSERVERS_CACHE_REPEAT_INTERVAL<br>服务列表更新间隔默认是30秒</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PollingServerListUpdater</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">@<span class="title">Override</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">synchronized</span> <span class="title">void</span> <span class="title">start</span>(<span class="title">final</span> <span class="title">UpdateAction</span> <span class="title">updateAction</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Runnable wrapperRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 这行代码就是拉取服务列表的核心逻辑</span></span><br><span class="line">                    updateActiondoUpdate();</span><br><span class="line">                    lastUpdated = SystemcurrentTimeMillis();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            scheduledFuture = getRefreshExecutor()scheduleWithFixedDelay(</span><br><span class="line">                    wrapperRunnable,</span><br><span class="line">                    initialDelayMs,</span><br><span class="line">                    refreshIntervalMs,</span><br><span class="line">                    TimeUnitMILLISECONDS</span><br><span class="line">            );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>updateActiondoUpdate<br>通过引用分析，可以得到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicServerListLoadBalancer</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class"><span class="title">protected</span> <span class="title">final</span> <span class="title">ServerListUpdaterUpdateAction</span> <span class="title">updateAction</span> </span>= <span class="keyword">new</span> ServerListUpdaterUpdateAction() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        updateListOfServers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>原来逻辑就是这个<code>updateListOfServers()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateListOfServers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;T&gt; servers = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">    <span class="keyword">if</span> (serverListImpl != <span class="keyword">null</span>) &#123;</span><br><span class="line">        servers = serverListImplgetUpdatedListOfServers();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (filter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            servers = filtergetFilteredListOfServers(servers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    updateAllServerList(servers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>serverListImplgetUpdatedListOfServers<br>看到此处，笔者当时也是比较疑惑，因为上篇文章里的那个<code>ConfigurationBasedServerList</code>并没有这个方法，在查找实现类后，笔者发现事情并不简单，经过一番debug后结论如下：</p><blockquote><ul><li>Spring提供的默认ServerList是<code>DomainExtractingServerList</code></li><li>Spring提供的默认IPing是<code>NIWSDiscoveryPing</code></li></ul><p>有兴趣的同学可以看一下<code>EurekaRibbonClientConfiguration</code>这个自动配置类，你会发现这里也声明了ribbon的核心组件。为了验证到底哪个会生效，可以分别对对应创建bean的方法打上断点debug一下，笔者上述结论就是这么得出的。</p><p>顺便说一下，这和Spring初始化自动装配类的顺序有关。</p></blockquote></li><li><p>事实上，<code>serverListImplgetUpdatedListOfServers</code>最后调用的是<code>DiscoveryEnabledNIWSServerList#obtainServersViaDiscovery</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;DiscoveryEnabledServer&gt; <span class="title">obtainServersViaDiscovery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;DiscoveryEnabledServer&gt; serverList = <span class="keyword">new</span> ArrayList&lt;DiscoveryEnabledServer&gt;();</span><br><span class="line"></span><br><span class="line">    EurekaClient eurekaClient = eurekaClientProviderget();</span><br><span class="line">    <span class="keyword">if</span> (vipAddresses!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">// vipAddresses</span></span><br><span class="line">        <span class="keyword">for</span> (String vipAddress : vipAddressessplit(<span class="string">","</span>)) &#123;</span><br><span class="line">            List&lt;InstanceInfo&gt; listOfInstanceInfo = eurekaClientgetInstancesByVipAddress(vipAddress, isSecure, targetRegion);</span><br><span class="line">            <span class="keyword">for</span> (InstanceInfo ii : listOfInstanceInfo) &#123;</span><br><span class="line">                <span class="keyword">if</span> (iigetStatus()equals(InstanceStatusUP)) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(shouldUseOverridePort)&#123;</span><br><span class="line">                        InstanceInfo copy = <span class="keyword">new</span> InstanceInfo(ii);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    DiscoveryEnabledServer des = createServer(ii, isSecure, shouldUseIpAddr);</span><br><span class="line">                    serverListadd(des);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (serverListsize()&gt;<span class="number">0</span> &amp;&amp; prioritizeVipAddressBasedServers)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> serverList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>此处的逻辑非常直观，就是根据vipAddress，也就是serverId、AppName，取出对应的服务实例列表，然后根据服务实例列表构造出Ribbon的`DiscoveryEnabledServer`</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Spring通过一个<code>PollingServerListUpdater</code>定时任务每隔30秒，委托<code>DiscoveryEnabledNIWSServerList</code>组件的<code>obtainServersViaDiscovery</code>方法，从eureka client中拉取RibbonClient配置的服务对应的的服务器列表</li></ul><p>正确的默认组件如下</p><ul><li><p>Spring提供的默认ServerList是<code>DomainExtractingServerList</code></p></li><li><p>Spring提供的默认IPing是<code>NIWSDiscoveryPing</code></p></li><li><p>Spring提供的默认负载均衡器是<code>ZoneAwareLoadBalancer</code></p></li><li><p>Spring提供的默认负载均衡规则是<code>ZoneAvoidanceRule</code></p></li><li><p>Spring提供的默认RestClient是<code>OverrideRestClient</code></p></li><li><p>Spring定时更新服务列表的组件是<code>PollingServerListUpdater</code></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们上篇已经知道&lt;code&gt;PollingServerListUpdater&lt;/code&gt;有可能是负责与Eureka交互定时获取服务列表的，本篇我们就剖析下这个组件相关的逻辑。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Ribbon" scheme="http://houqian.github.io/tags/Ribbon/"/>
    
  </entry>
  
  <entry>
    <title>负载均衡：Ribbon源码剖析（1）创建负载均衡器</title>
    <link href="http://houqian.github.io/2020/04/13/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9ARibbon%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%881%EF%BC%89%E5%88%9B%E5%BB%BA%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8/"/>
    <id>http://houqian.github.io/2020/04/13/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9ARibbon%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%881%EF%BC%89%E5%88%9B%E5%BB%BA%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8/</id>
    <published>2020-04-13T13:29:35.000Z</published>
    <updated>2021-06-06T16:40:06.948Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h1><p>我们在每次使用Spring Cloud Netflix Ribbon的时候，有一个固定的套路就是需要用<code>@LoadBalanced</code>注解修饰一个<code>RestTemplate</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>根据以往Spring Cloud集成套路，必然会有一个与之相关的自动配置类，果不其然，找到了一个<code>LoadBalancerAutoConfiguration</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(RestTemplate.class)</span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(LoadBalancerClient.class)</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(LoadBalancerRetryProperties.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalancerAutoConfiguration</span> </span>&#123;</span><br></pre></td></tr></table></figure><ul><li>ConditionalOnBean<br>会依赖一个叫<code>LoadBalancerClient</code>的对象</li><li>LoadBalancerRetryProperties<br>开启了一个配置，是Ribbon重试相关的</li></ul><p>下面这行代码，比较灵活的运用了Spring原生注解的特性，作用就是把所有的被@LoadBalanced注解修饰的RestTemplate对象都收集到这个集合里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RibbonAutoConfiguration</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">@<span class="title">LoadBalanced</span></span></span><br><span class="line"><span class="class">@<span class="title">Autowired</span>(<span class="title">required</span> </span>= <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> List&lt;RestTemplate&gt; restTemplates = Collections.emptyList();</span><br></pre></td></tr></table></figure><blockquote><p>其实现原理，玄机在<code>@LoadBalanced</code>中，可以看到该注解上被<code>@Qulifier</code>注解修饰，这就触发了Spring一个比较偏门的特性，Spring会把这个注解修饰的对象注册到Spring容器中去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">@Target</span>(&#123; ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD &#125;)</span><br><span class="line">&gt; <span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line">&gt; <span class="meta">@Documented</span></span><br><span class="line">&gt; <span class="meta">@Inherited</span></span><br><span class="line">&gt; <span class="meta">@Qualifier</span> <span class="comment">// 注意这个</span></span><br><span class="line">&gt; <span class="keyword">public</span> <span class="meta">@interface</span> LoadBalanced &#123;</span><br><span class="line">&gt; </span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>有兴趣的朋友可以看看Spring处理<code>@Qulifier</code>的过程。QualifierAnnotationAutowireCandidateResolver#checkQualifier方法</p></blockquote><p>接着，我们看到了Spring集成Ribbon关键的一步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RibbonAutoConfiguration</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">@<span class="title">Configuration</span>(<span class="title">proxyBeanMethods</span> </span>= <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnMissingClass</span>(<span class="string">"org.springframework.retry.support.RetryTemplate"</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalancerInterceptorConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> LoadBalancerInterceptor <span class="title">ribbonInterceptor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">         LoadBalancerClient loadBalancerClient,</span></span></span><br><span class="line"><span class="function"><span class="params">         LoadBalancerRequestFactory requestFactory)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> LoadBalancerInterceptor(loadBalancerClient, requestFactory);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> RestTemplateCustomizer <span class="title">restTemplateCustomizer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">final</span> LoadBalancerInterceptor loadBalancerInterceptor)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> restTemplate -&gt; &#123;</span><br><span class="line">         List&lt;ClientHttpRequestInterceptor&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">               restTemplate.getInterceptors());</span><br><span class="line">         list.add(loadBalancerInterceptor);</span><br><span class="line">         restTemplate.setInterceptors(list);</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>LoadBalancerInterceptor<br>这是Spring与Ribbon代码的关键结合点。他是通过Spring为Ribbon定制的RestTemplate拦截器来实现的，在这个拦截器里，完成了将RestTemplate收到的请求委托给Ribbon处理的逻辑。</p></li><li><p>restTemplateCustomizer<br>这里就是对Ribbon的RestTemplate拦截器加入到restTemplate中去。<br>这一步的逻辑要结合着此处去看，一下子就明白了。原来Spring就是把被<code>@LoadBalanced</code>修饰的RestTemplate收集起来，然后一个个遍历，在每一个RestTemplate里追加一个为Ribbon定制的拦截器，完成了请求的委托处理，这算是Spring整合Ribbon最核心的逻辑之一了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RibbonAutoConfiguration</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    @<span class="title">Bean</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">SmartInitializingSingleton</span> <span class="title">loadBalancedRestTemplateInitializerDeprecated</span>(</span></span><br><span class="line"><span class="class">          <span class="title">final</span> <span class="title">ObjectProvider</span>&lt;<span class="title">List</span>&lt;<span class="title">RestTemplateCustomizer</span>&gt;&gt; <span class="title">restTemplateCustomizers</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> () -&gt; restTemplateCustomizers.ifAvailable(customizers -&gt; &#123;</span><br><span class="line">          <span class="keyword">for</span> (RestTemplate restTemplate : LoadBalancerAutoConfiguration.<span class="keyword">this</span>.restTemplates) &#123;</span><br><span class="line">             <span class="keyword">for</span> (RestTemplateCustomizer customizer : customizers) &#123;</span><br><span class="line">                customizer.customize(restTemplate);</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Spring整合Ribbon的核心结合点"><a href="#Spring整合Ribbon的核心结合点" class="headerlink" title="Spring整合Ribbon的核心结合点"></a>Spring整合Ribbon的核心结合点</h1><p>既然如此，我们就看看在为Ribbon定制的RestTemplate拦截器里具体完成了什么事情吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalancerInterceptor</span> <span class="keyword">implements</span> <span class="title">ClientHttpRequestInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> LoadBalancerClient loadBalancer;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> LoadBalancerRequestFactory requestFactory;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ClientHttpResponse <span class="title">intercept</span><span class="params">(<span class="keyword">final</span> HttpRequest request, <span class="keyword">final</span> <span class="keyword">byte</span>[] body,</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">final</span> ClientHttpRequestExecution execution)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       </span><br><span class="line">      <span class="keyword">final</span> URI originalUri = request.getURI();</span><br><span class="line">      String serviceName = originalUri.getHost();</span><br><span class="line">       </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.loadBalancer.execute(serviceName,</span><br><span class="line">            <span class="keyword">this</span>.requestFactory.createRequest(request, body, execution));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>LoadBalancerClient<br>这个里面其实存放了Ribbon的几个核心组件，比如ILoadBalancer、IRule、RestClient、IPing等等，这个我们后面再仔细看，这里有个印象就好</li><li>LoadBalancerRequestFactory<br>这里完成了遍历RestTemplate里的拦截器链，并一个个执行</li><li>loadBalancer.execute<br>这里最最关键，完成了RestTemplate请求到Ribbon请求的转换，并且将请求委托给Ribbon处理</li></ul><blockquote><p>这段代码实现的非常优雅，不像我们之前分析Eureka源码的时候，都是大段大段的代码，看起来令人眼花缭乱，其最主要的槽点就是控制和业务逻辑没有做到很好的分离。人家Spring通过一系列组件的封装，控制逻辑，比如这里的请求转换，请求委托都清爽的呈现在我们眼前，让人一眼就知道Spring干了什么。如果想更详细的了解具体的处理逻辑，只要看那个组件的很少的代码就可以了，非常的内聚，我们要向这种代码风格学习</p></blockquote><h1 id="看看到底负载均衡器是如何创建的"><a href="#看看到底负载均衡器是如何创建的" class="headerlink" title="看看到底负载均衡器是如何创建的"></a>看看到底负载均衡器是如何创建的</h1><p>我们上面已经分析了Spring集成Ribbon的核心骨架代码的一部分了，剩下的其实都是比较零散，也可以说非常内聚的点了，逐个击破即可。<br>其实在<code>RibbonAutoConfiguration</code>中还有一个关键的对象被创建了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RibbonAutoConfiguration</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    @<span class="title">Bean</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">SpringClientFactory</span> <span class="title">springClientFactory</span>() </span>&#123;</span><br><span class="line">       SpringClientFactory factory = <span class="keyword">new</span> SpringClientFactory();</span><br><span class="line">       factory.setConfigurations(<span class="keyword">this</span>.configurations);</span><br><span class="line">       <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们看到他的方法列表，就会倍感熟悉，这ILoadBalancer不就是负载均衡器吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringClientFactory</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">SpringClientFactory</span>() </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(RibbonClientConfiguration.class, NAMESPACE, <span class="string">"ribbon.client.name"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  IClient&lt;?, ?&gt;&gt; C getClient</span><br><span class="line">  ILoadBalancer getLoadBalancer</span><br></pre></td></tr></table></figure><p>我们此时先按捺住激动的心情，先看看构造器里的<code>RibbonClientConfiguration</code>是个什么东东吧。</p><blockquote><p>根据笔者阅读Spring集成代码的经验，涉及到三方技术核心组件创建的这样重要逻辑，Spring往往是在xxConfiguration里完成的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RibbonClientConfiguration</span> </span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    @<span class="title">Bean</span></span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnMissingBean</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">IRule</span> <span class="title">ribbonRule</span>(<span class="title">IClientConfig</span> <span class="title">config</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(IRule.class, name)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(IRule.class, config, name);</span><br><span class="line">    &#125;</span><br><span class="line">    ZoneAvoidanceRule rule = <span class="keyword">new</span> ZoneAvoidanceRule();</span><br><span class="line">    rule.initWithNiwsConfig(config);</span><br><span class="line">    <span class="keyword">return</span> rule;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>我们的选择是没有白费，看看这是什么，这里构建了一个IRule的实现ZoneAvoidanceRule，Ribbon组件+1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RibbonClientConfiguration</span> </span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    @<span class="title">Bean</span></span></span><br><span class="line"><span class="class">    @<span class="title">ConditionalOnMissingBean</span></span></span><br><span class="line">    @SuppressWarnings("unchecked")</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerList&lt;Server&gt; <span class="title">ribbonServerList</span><span class="params">(IClientConfig config)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(ServerList.class, name)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(ServerList.class, config, name);</span><br><span class="line">       &#125;</span><br><span class="line">       ConfigurationBasedServerList serverList = <span class="keyword">new</span> ConfigurationBasedServerList();</span><br><span class="line">       serverList.initWithNiwsConfig(config);</span><br><span class="line">       <span class="keyword">return</span> serverList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerListUpdater <span class="title">ribbonServerListUpdater</span><span class="params">(IClientConfig config)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> PollingServerListUpdater(config);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>ServerList<br>服务列表，Ribbon的核心概念</p></li><li><p>ServerListUpdater<br>服务列表更新器，我们知道Ribbon的服务列表肯定是来自于Eureka，这个更新器的作用就不难猜测了<br>PollingServerListUpdater，定时从Eureka那边拉取服务列表，至此，Spring集成Ribbon的所有核心逻辑都已经看到了</p><blockquote><p>这里不得不再夸赞一下Spring的代码水平，非常的高内聚，上一个是静态的服务列表，紧挨着就是服务列表的动态更新。<br>这种代码对阅读者实在是太爽了，是一种享受。</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RibbonClientConfiguration</span> </span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    @<span class="title">Bean</span></span></span><br><span class="line"><span class="class">    @<span class="title">ConditionalOnMissingBean</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ILoadBalancer</span> <span class="title">ribbonLoadBalancer</span>(<span class="title">IClientConfig</span> <span class="title">config</span>,</span></span><br><span class="line"><span class="class">          <span class="title">ServerList</span>&lt;<span class="title">Server</span>&gt; <span class="title">serverList</span>, <span class="title">ServerListFilter</span>&lt;<span class="title">Server</span>&gt; <span class="title">serverListFilter</span>,</span></span><br><span class="line"><span class="class">          <span class="title">IRule</span> <span class="title">rule</span>, <span class="title">IPing</span> <span class="title">ping</span>, <span class="title">ServerListUpdater</span> <span class="title">serverListUpdater</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(ILoadBalancer.class, name)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(ILoadBalancer.class, config, name);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ZoneAwareLoadBalancer&lt;&gt;(config, rule, ping, serverList,</span><br><span class="line">             serverListFilter, serverListUpdater);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>来了来了，我们本篇也可以拉下帷幕了<br>此处就是ILoadBalancer负载均衡器的创建逻辑<br>可以看到是用的ZoneAwareLoadBalancer这个实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RibbonClientConfiguration</span> </span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class"><span class="title">static</span> <span class="title">class</span> <span class="title">OverrideRestClient</span> <span class="keyword">extends</span> <span class="title">RestClient</span></span></span><br></pre></td></tr></table></figure></li><li><p>OverrideRestClient，Ribbon的核心RestClient实现类<br>通过引用分析，可以知道这个OverrideRestClient就是Spring提供的默认RestClient实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RestClientRibbonConfiguration</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    @<span class="title">Bean</span></span></span><br><span class="line"><span class="class">@<span class="title">Lazy</span></span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnMissingBean</span>(<span class="title">AbstractLoadBalancerAwareClient</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">RestClient</span> <span class="title">ribbonRestClient</span>(<span class="title">IClientConfig</span> <span class="title">config</span>, <span class="title">ILoadBalancer</span> <span class="title">loadBalancer</span>,</span></span><br><span class="line"><span class="class"><span class="title">ServerIntrospector</span> <span class="title">serverIntrospector</span>, <span class="title">RetryHandler</span> <span class="title">retryHandler</span>) </span>&#123;</span><br><span class="line">    RestClient client = <span class="keyword">new</span> RibbonClientConfiguration.OverrideRestClient(config,</span><br><span class="line">        serverIntrospector);</span><br><span class="line">    client.setLoadBalancer(loadBalancer);</span><br><span class="line">    client.setRetryHandler(retryHandler);</span><br><span class="line">    <span class="keyword">return</span> client;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>阅读Spring的代码是令人愉悦的，写法非常的高内聚，相关的逻辑紧紧的放在一处，生怕你看漏了。低耦合，控制与业务逻辑分离，非常清爽。</p><blockquote><p>此处的结论在我们当前的视角是合乎逻辑的，但实际上与这个结果是有一些出入的，我们在后续的篇幅里再行探讨。</p></blockquote><ul><li>Spring提供的默认负载均衡器是<code>ZoneAwareLoadBalancer</code></li><li>Spring提供的默认负载均衡规则是<code>ZoneAvoidanceRule</code></li><li>Spring提供的默认RestClient是<code>OverrideRestClient</code></li><li>Spring提供的默认检查存活组件是<code>DummyPing</code></li><li>Spring定时更新服务列表的组件是<code>PollingServerListUpdater</code></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;入口&quot;&gt;&lt;a href=&quot;#入口&quot; class=&quot;headerlink&quot; title=&quot;入口&quot;&gt;&lt;/a&gt;入口&lt;/h1&gt;&lt;p&gt;我们在每次使用Spring Cloud Netflix Ribbon的时候，有一个固定的套路就是需要用&lt;code&gt;@LoadBalanced&lt;/code&gt;注解修饰一个&lt;code&gt;RestTemplate&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@LoadBalanced&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; RestTemplate &lt;span class=&quot;title&quot;&gt;getRestTemplate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RestTemplate();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Ribbon" scheme="http://houqian.github.io/tags/Ribbon/"/>
    
  </entry>
  
  <entry>
    <title>负载均衡：Ribbon入门</title>
    <link href="http://houqian.github.io/2020/04/08/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9ARibbon%E5%85%A5%E9%97%A8/"/>
    <id>http://houqian.github.io/2020/04/08/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9ARibbon%E5%85%A5%E9%97%A8/</id>
    <published>2020-04-08T12:32:21.000Z</published>
    <updated>2021-06-06T16:43:24.884Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Ribbon解决了什么问题"><a href="#Ribbon解决了什么问题" class="headerlink" title="Ribbon解决了什么问题"></a>Ribbon解决了什么问题</h1><p>当集群中有了注册中心之后，服务消费者可以拿到所有服务的列表，此时就需要有一个组件能够将请求负载均衡到各个实例上去。ribbon就是这样一个客户端侧的负载均衡组件，同出Netflix，与其他组件整合后非常实用。</p><p>Ribbon提供了多种不同的负载均衡算法实现，非常实用。</p><a id="more"></a><h1 id="快速体验Ribbon（一）"><a href="#快速体验Ribbon（一）" class="headerlink" title="快速体验Ribbon（一）"></a>快速体验Ribbon（一）</h1><p>此次我们直接基于原生ribbon体验下他的API，这是由于Spring Cloud Netflix对Ribbon的封装比较彻底，几乎没有使用成本，这也让我们很难了解到Ribbon的架构设计理念、核心概念、API等。</p><h2 id="1、开发一个服务提供者"><a href="#1、开发一个服务提供者" class="headerlink" title="1、开发一个服务提供者"></a>1、开发一个服务提供者</h2><p>依赖项</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>服务接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/greeting"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment env;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/sayHello/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(@PathVariable(<span class="string">"name"</span>)</span> String name) </span>&#123;</span><br><span class="line">        log.info(<span class="string">"port:&#123;&#125;, name:&#123;&#125;"</span>, env.getProperty(<span class="string">"local.server.port"</span>), name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello, "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingServiceApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(GreetingServiceApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别使用如下两个端口启动工程</p><p>application.yml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#server:</span></span><br><span class="line"><span class="comment">#  port: 8080</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8088</span></span><br></pre></td></tr></table></figure><h2 id="2、开发一个服务调用者"><a href="#2、开发一个服务调用者" class="headerlink" title="2、开发一个服务调用者"></a>2、开发一个服务调用者</h2><p>依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.ribbon<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.ribbon<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ribbon-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.ribbon<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ribbon-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.ribbon<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ribbon-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.archaius<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>archaius-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.7.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>16.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-configuration<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-configuration<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ribbon.version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">ribbon.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">archaius-core.version</span>&gt;</span>0.7.6<span class="tag">&lt;/<span class="name">archaius-core.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>服务消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.netflix.client.ClientFactory;</span><br><span class="line"><span class="keyword">import</span> com.netflix.client.http.HttpRequest;</span><br><span class="line"><span class="keyword">import</span> com.netflix.client.http.HttpResponse;</span><br><span class="line"><span class="keyword">import</span> com.netflix.config.ConfigurationManager;</span><br><span class="line"><span class="keyword">import</span> com.netflix.niws.client.http.RestClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 基于ribbon的api来开发一个可以负载均衡调用一个服务的代码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先使用代码的方式对ribbon进行一下配置，配置一下ribbon要调用的那个服务的server list</span></span><br><span class="line">        ConfigurationManager.getConfigInstance().setProperty(</span><br><span class="line">                <span class="string">"greeting-service.ribbon.listOfServers"</span>, <span class="string">"localhost:8080,localhost:8088"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取指定服务的RestClient，用于请求某个服务的client</span></span><br><span class="line">        RestClient restClient = (RestClient) ClientFactory.getNamedClient(<span class="string">"greeting-service"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 你要请求哪个接口，构造一个对应的HttpRequest</span></span><br><span class="line">        HttpRequest request = HttpRequest.newBuilder()</span><br><span class="line">                .uri(<span class="string">"/greeting/sayHello/leo"</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟请求一个接口10次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            HttpResponse response = restClient.executeWithLoadBalancer(request);</span><br><span class="line">            String result = response.getEntity(String.class);</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、开始实验"><a href="#3、开始实验" class="headerlink" title="3、开始实验"></a>3、开始实验</h2><p>运行GreetingClient，发现10次调用被均匀的分给了两个服务实例，实现了负载均衡。</p><p><img src="/blog/2020/04/08/负载均衡：Ribbon入门/Ribbon%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E6%96%B9.png" alt="Ribbon服务消费方"></p><p><img src="/blog/2020/04/08/负载均衡：Ribbon入门/Ribbon%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E6%96%B91.png" alt="Ribbon服务提供方1"></p><p><img src="/blog/2020/04/08/负载均衡：Ribbon入门/Ribbon%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E6%96%B92.png" alt="Ribbon服务提供方2"></p><h1 id="快速体验Ribbon（二）"><a href="#快速体验Ribbon（二）" class="headerlink" title="快速体验Ribbon（二）"></a>快速体验Ribbon（二）</h1><h2 id="1、体验底层的负载均衡器API"><a href="#1、体验底层的负载均衡器API" class="headerlink" title="1、体验底层的负载均衡器API"></a>1、体验底层的负载均衡器API</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingClient2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ILoadBalancer loadBalancer = <span class="keyword">new</span> BaseLoadBalancer();</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Server&gt; servers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        servers.add(<span class="keyword">new</span> Server(<span class="string">"localhost"</span>, <span class="number">8080</span>));</span><br><span class="line">        servers.add(<span class="keyword">new</span> Server(<span class="string">"localhost"</span>, <span class="number">8088</span>));</span><br><span class="line">        loadBalancer.addServers(servers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认使用round robin轮询策略</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Server server = loadBalancer.chooseServer(<span class="keyword">null</span>);</span><br><span class="line">            System.out.println(<span class="string">"chosen server:"</span> + server);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/blog/2020/04/08/负载均衡：Ribbon入门/Ribbon%E5%BA%95%E5%B1%82%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8API.png" alt="Ribbon底层的负载均衡器API"></p><p>可以看到，底层默认的负载均衡算法就是轮询算法。RestClient底层也是依赖负载均衡器工作的</p><h2 id="2、自定义负载均衡规则"><a href="#2、自定义负载均衡规则" class="headerlink" title="2、自定义负载均衡规则"></a>2、自定义负载均衡规则</h2><p>负载均衡器是基于一个IRule接口指定的负载均衡规则，来从服务器列表里获取每次要请求的服务器的，所以可以自定义负载均衡规则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义负载均衡策略，这里就返回第一个服务作为示例了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRule</span> <span class="keyword">implements</span> <span class="title">IRule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ILoadBalancer loadBalancer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        List&lt;Server&gt; servers = loadBalancer.getAllServers();</span><br><span class="line">        <span class="keyword">return</span> servers.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoadBalancer</span><span class="params">(ILoadBalancer lb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadBalancer = lb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ILoadBalancer <span class="title">getLoadBalancer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.loadBalancer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    BaseLoadBalancer loadBalancer = <span class="keyword">new</span> BaseLoadBalancer();</span><br><span class="line">    MyRule myRule = <span class="keyword">new</span> MyRule();</span><br><span class="line">    myRule.setLoadBalancer(loadBalancer);</span><br><span class="line">    loadBalancer.setRule(myRule);</span><br><span class="line"></span><br><span class="line">    List&lt;Server&gt; servers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    servers.add(<span class="keyword">new</span> Server(<span class="string">"localhost"</span>, <span class="number">8080</span>));</span><br><span class="line">    servers.add(<span class="keyword">new</span> Server(<span class="string">"localhost"</span>, <span class="number">8088</span>));</span><br><span class="line">    loadBalancer.addServers(servers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认使用round robin轮询策略</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        Server server = loadBalancer.chooseServer(<span class="keyword">null</span>);</span><br><span class="line">        System.out.println(<span class="string">"chosen server:"</span> + server);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下，Ribbon内置的负载均衡规则就足够使用了，这里仅仅是为了体验一下底层API的设计。我们通过这个实验了解了ILoadBalancer和IRule是什么，两者有什么关系，以及特定场景下可以通过实现IRule接口实现自己的负载均衡规则（算法）。</p><h2 id="3、Ribbon内置负载均衡规则"><a href="#3、Ribbon内置负载均衡规则" class="headerlink" title="3、Ribbon内置负载均衡规则"></a>3、Ribbon内置负载均衡规则</h2><p><img src="/blog/2020/04/08/负载均衡：Ribbon入门/Ribbon%E5%86%85%E7%BD%AE%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%A7%84%E5%88%99.png" alt="Ribbon内置的负载均衡规则"></p><ul><li><p>RoundRobinRule：默认的负载均衡规则。直接从一堆server list中，不断轮询选择出一个server，每个server收到的请求是均匀的。</p></li><li><p>AvailabilityFilteringRule: 这个rule会检查服务器的可用性<br>如果连续3次连接失败，就会等待30秒后再次访问；<br>如果不断失败，那么等待时间会不断变长。<br>如果某个服务器的并发请求太高了，那么会绕过去，不再访问。</p></li><li><p>WeightedResponseTimeRule: 附带权重的，每个服务器可以指定一个权重，权重越高优先访问，如果魔鬼服务器响应时间比较长，那么权重就会降低，减少访问</p></li><li><p>ZoneAvoidanceRule：根据区域和服务器来进行负载均衡，根据机房划分</p></li><li><p>BestAvailableRule：忽略那些连接失败的服务器，然后尽量找并发比较低的服务器来请求</p></li><li><p>RandomRule：随机选择一个服务器</p></li><li><p>RetryRule：可以重试，先通过round robin找到的服务器，如果请求失败，就会接着会重新找一个服务器</p></li></ul><p>可以看到，ribbon主打的就是负载均衡、网络通信，别的一些东西都是次要的。本系列文章会分析一些负载均衡算法的实现，以及看ribbon+eureka+spring cloud是如何整合使用的，会从源码角度分析下ribbon里的一些配置参数</p><h1 id="快速体验Ribbon（三）"><a href="#快速体验Ribbon（三）" class="headerlink" title="快速体验Ribbon（三）"></a>快速体验Ribbon（三）</h1><h2 id="1、体验Ribbon中健康检查组件IPing"><a href="#1、体验Ribbon中健康检查组件IPing" class="headerlink" title="1、体验Ribbon中健康检查组件IPing"></a>1、体验Ribbon中健康检查组件IPing</h2><p>负载均衡器ILoadBalancer里，有IRule负责负载均衡的规则，选择一个服务器；还有一个IPing组件负责定时ping每个服务器，判断其是否存活。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingClient4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        BaseLoadBalancer loadBalancer = <span class="keyword">new</span> BaseLoadBalancer();</span><br><span class="line"></span><br><span class="line">        List&lt;Server&gt; servers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        servers.add(<span class="keyword">new</span> Server(<span class="string">"localhost"</span>, <span class="number">8080</span>));</span><br><span class="line">        servers.add(<span class="keyword">new</span> Server(<span class="string">"localhost"</span>, <span class="number">8088</span>));</span><br><span class="line">        loadBalancer.addServers(servers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每隔1秒ping一次上面那2个server</span></span><br><span class="line">        loadBalancer.setPing(<span class="keyword">new</span> PingUrl(<span class="keyword">false</span>, <span class="string">"/greeting/ping"</span>));</span><br><span class="line">        loadBalancer.setPingInterval(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Server server = loadBalancer.chooseServer(<span class="keyword">null</span>);</span><br><span class="line">            System.out.println(server);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过给负载均衡器LoadBalancer设置Ping组件，比如要ping的url，间隔时间等，就可以使用ping功能了。为了实验效果，笔者在原来的greeting服务里新加了一个ping接口，这个接口是个GET接口，没有逻辑和返回值。在启动实验时，可以等1~2秒，停掉其中一个greeting服务实例，可以观察到有趣的现象</p><p><img src="/blog/2020/04/08/负载均衡：Ribbon入门/%E5%AE%9E%E9%AA%8CRibbon%E7%9A%84ping%E7%BB%84%E4%BB%B6.png" alt="实验Ribbon的ping组件"></p><p>笔者停掉了8088端口的实例，可以看到此时选取的服务器已经都是8080了，这在生产环境是比较实用的。</p><blockquote><p>在生产环境，如果我们想要自定义更为强大的健康检查接口，可以通过实现IPing这个接口，覆盖里面的isAlive方法来实现。</p></blockquote><h1 id="快速体验Ribbon（四）"><a href="#快速体验Ribbon（四）" class="headerlink" title="快速体验Ribbon（四）"></a>快速体验Ribbon（四）</h1><h2 id="1、改造eureka入门里的实验代码"><a href="#1、改造eureka入门里的实验代码" class="headerlink" title="1、改造eureka入门里的实验代码"></a>1、改造eureka入门里的实验代码</h2><p>在eureka入门里，我们其实已经体验过了，这里为了更明显，对之前的代码稍加改造即可。</p><p>服务A-服务提供者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceAController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/sayHello/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(@PathVariable(<span class="string">"name"</span>)</span> String name) </span>&#123;</span><br><span class="line">        Integer port = environment.getProperty(<span class="string">"local.server.port"</span>, Integer.class);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello,"</span> + name + <span class="string">", came from "</span> + port;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务B-服务消费者</p><p>使用<code>@LoadBalanced</code>注解启用Ribbon</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ServiceBApplication.class, args);</span><br><span class="line">        log.info(<span class="string">"ServiceB 启动成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/greeting/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">greeting</span><span class="params">(@PathVariable(<span class="string">"name"</span>)</span> String name) </span>&#123;</span><br><span class="line">        String response = restTemplate.getForObject(<span class="string">"http://serviceA/sayHello/"</span> + name, String.class);</span><br><span class="line">        log.info(response);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、开始实验"><a href="#2、开始实验" class="headerlink" title="2、开始实验"></a>2、开始实验</h2><ul><li>分别用8081、8082两个端口启动服务A</li><li>用9000端口启动服务B</li><li>启动eureka集群</li><li>打开浏览器，访问<code>http://localhost:9000/greeting/sam</code>多次刷新</li></ul><p><img src="/blog/2020/04/08/负载均衡：Ribbon入门/SpringCloudRibbon%E5%AE%9E%E9%AA%8C.png" alt="SpringCloudRibbon实验"></p><p>与我们快速体验Ribbon的效果一样，请求被均匀的打到各个实例上去了。</p><blockquote><p>此处不知你是否有疑问，为什么只是简单的加了一个注解，就可以用restTemplate访问不同的实例了呢？</p><p>不难猜测，肯定是从eureka那里获取到了服务注册表，然后ribbon拿着这些服务注册表，用自己的IRule组件选出一个server，然后就发送过去请求就可以了。</p><p>其实，ribbon的底层原理说白了，就是这些，我们此次源码分析的目的也是围绕这些点剖析一下就可以了，难度比eureka低不少。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们通过几个实验，了解到了ribbon的几个核心组件，ILoadBalancer负载均衡器，IRule负载均衡规则、IPing定时检测服务存活，以及回味了基于Spring Cloud Netflix Ribbon的简洁集成方式。下一步，跟随笔者进入Ribbon的源码世界吧！</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Ribbon解决了什么问题&quot;&gt;&lt;a href=&quot;#Ribbon解决了什么问题&quot; class=&quot;headerlink&quot; title=&quot;Ribbon解决了什么问题&quot;&gt;&lt;/a&gt;Ribbon解决了什么问题&lt;/h1&gt;&lt;p&gt;当集群中有了注册中心之后，服务消费者可以拿到所有服务的列表，此时就需要有一个组件能够将请求负载均衡到各个实例上去。ribbon就是这样一个客户端侧的负载均衡组件，同出Netflix，与其他组件整合后非常实用。&lt;/p&gt;
&lt;p&gt;Ribbon提供了多种不同的负载均衡算法实现，非常实用。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="Ribbon" scheme="http://houqian.github.io/tags/Ribbon/"/>
    
  </entry>
  
  <entry>
    <title>服务注册发现：Eureka源码剖析（13）Spring Cloud Eureka源码剖析</title>
    <link href="http://houqian.github.io/2020/03/28/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%8813%EF%BC%89Spring-Cloud-Eureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <id>http://houqian.github.io/2020/03/28/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%8813%EF%BC%89Spring-Cloud-Eureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</id>
    <published>2020-03-28T12:26:51.000Z</published>
    <updated>2021-06-05T15:24:17.204Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Spring Cloud Netflix Eureka对eureka原生项目做了一点儿轻量级的封装。</p><a id="more"></a><p>下面通过几个Spring Cloud Netflix Eureka的核心注解来分析</p><ul><li><p><code>@EnableEurekaClient</code> 在Spring cloud Netflix eureka-client工程里<br>这个注解会将当前spring boot应用作为eureka client进行启动。他的处理类是<code>EurekaClientAutoConfiguration</code></p><ul><li>EurekaClientConfigBean 这个是Spring自己实现EurekaClient接口搞的一个配置类，主要内容和原版Eureka的DefaultEurekaClientConfig作用是一样的，只不过提供了Spring方式的外部配置方式。</li><li>EurekaInstanceConfigBean 这个是Spring自己实现EurekaInstanceConfig接口搞的一个配置类，作用和原版差不多</li><li>EurekaServiceRegistry 是Spring自定义的服务注册中心，主要有注册、下线方法，这个类其实主要做心跳</li><li>EurekaAutoServiceRegistration 这个是Spring对原生Eureka 的一个优化，会在服务启动时马上执行服务注册（原版需要等待40秒）</li><li>CloudEurekaClient 继承了DiscoveryClient，主要是提供了一个onCacheRefreshed方法，这个拓展就是为了在EurekaClient拉取服务注册表时，更新一下Ribbon的ServerList。还有通过@Bean(destroyMethod = “shutdown”) 指定了Spring容器销毁时调用eureka client的服务下线方法进行下线</li><li>ApplicationInfoManager 服务信息管理器，原版组件，没啥好说的</li><li>EurekaRegistration 是ServiceInstance的子类，没啥特别的</li><li>EurekaHealthIndicator Spring自定义了Eureka的HealthIndicator，边缘代码，不用看了</li></ul></li><li><p><code>@EnableEurekaServer</code> 在Spring cloud Netflix eureka-server工程里</p><ul><li>EurekaController 这是Spring根据原生eureka控制台的Controller写的控制器，因为Spring重写了控制台，所以也配套搞了个Controller，没啥可说的</li><li>InstanceRegistry我们的老朋友，原生的PeerAwareInstanceRegistryImpl的子类，主要是扩展了当发生注册、下线等等这些东西时，发布对应的Spring事件，算是Spring老生常谈的扩展方式了</li><li>RefreshablePeerEurekaNodes 继承了原生的PeerEurekaNodes，主要是对接了Spring的配置体系，当涉及到eureka server地址列表的配置变更时，就可以联动PeerEurekaNodes，搞在线扩容缩容了。</li><li>DefaultEurekaServerContext 老朋友，原生的，代表一个eureka服务器的上下文，里面包含了所有的组件资源</li><li>EurekaServerBootstrap 这个是Spring把原生的同名类代码拷贝了过来，由于使用了Spring的@Bean装配，这个类的代码享受到了依赖注入的好处，清爽了不少，但功能没变。还是启动eureka server</li></ul></li></ul><p>可以看到，Spring对eureka的扩展主要是对接Spring，都是一些胶水代码，没啥可说的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Spring Cloud Netflix Eureka对eureka原生项目做了一点儿轻量级的封装。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Eureka" scheme="http://houqian.github.io/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>服务注册发现：Eureka源码剖析（12）核心机制源码剖析总结</title>
    <link href="http://houqian.github.io/2020/03/25/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%8812%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E6%80%BB%E7%BB%93/"/>
    <id>http://houqian.github.io/2020/03/25/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%8812%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E6%80%BB%E7%BB%93/</id>
    <published>2020-03-25T13:13:56.000Z</published>
    <updated>2021-06-05T15:24:21.053Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li>eureka 客户端会在启动时，从eureka server抓取全量注册表到本地</li></ul><a id="more"></a><ul><li><p>eureka server的维护了一个注册表多级缓存，所有外部对eureka server的注册表查询都会走这个缓存机制。这个二级缓存有30秒的同步间隔，也就意味着服务注册、下线、取消、状态变更，可能得等30秒才能生效</p></li><li><p>eureka client会每隔30秒，从eureka server抓取增量注册表，这个增量注册表也是放到注册表缓存里的</p></li><li><p>eureka client和eureka server之间通过心跳机制来完成健康检查</p></li><li><p>当eureka server发现最近1分钟内有低于85%的服务实例心跳成功，就会将自己置为自我保护模式。这个模式下，eureka server不会剔除过期服务实例。由于实现代码的问题，导致我么生产环境要么不用自我保护机制，要么就不能调整心跳时间间隔。</p></li><li><p>当eureka server不在自我保护模式时，会每隔1分钟，自动剔除最近3分钟内没有发送心跳的服务实例</p></li><li><p>eureka 集群节点之间是首次全量不同注册表，随后服务实例的变更是通过异步批量复制的，每当服务注册、下线、取消、状态变更时，会把这种动作通过三层队列机制，最终一次发送一批的方式同步到其他eureka 节点</p></li></ul><p><img src="/blog/2020/03/25/服务注册发现：Eureka源码剖析（12）核心机制源码剖析总结/eureka%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93-(3).png" alt="eureka核心机制总结 (3)"></p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;eureka 客户端会在启动时，从eureka server抓取全量注册表到本地&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Eureka" scheme="http://houqian.github.io/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>服务注册发现：Eureka源码剖析（11）核心机制之Eureka Server集群机制</title>
    <link href="http://houqian.github.io/2020/03/18/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%8811%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8BEurekaServer%E9%9B%86%E7%BE%A4%E6%9C%BA%E5%88%B6/"/>
    <id>http://houqian.github.io/2020/03/18/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%8811%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8BEurekaServer%E9%9B%86%E7%BE%A4%E6%9C%BA%E5%88%B6/</id>
    <published>2020-03-18T11:22:56.000Z</published>
    <updated>2021-06-05T15:24:24.794Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li>什么是eureka集群？<br>一组互相复制数据，完全对等的eureka节点。通过配置文件指定，也可以热刷新（扩容缩容）</li></ul><a id="more"></a><ul><li><p>集群机制的实现？</p><p>在eureka server启动的时候，初始化服务器上下文阶段，会启动eureka集群信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class: DefaultEurekaServerContext</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="string">"Initializing ..."</span>);</span><br><span class="line">    <span class="comment">// 启动eureka集群，这个集群是每个eureka server节点都维护的一组内存对象。</span></span><br><span class="line">    <span class="comment">// 他的作用是每当本节点发生变更，比如有服务实例注册、下线、心跳续约等事件发生时，会修改这组对象</span></span><br><span class="line">    <span class="comment">// 然后这组对象负责将修改同步到对应的eureka server节点上去。</span></span><br><span class="line">    peerEurekaNodes.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化服务注册表</span></span><br><span class="line">        <span class="comment">// 这里其实是将所有的eureka server节点上的注册表都抓取过来，合并一下</span></span><br><span class="line">        <span class="comment">// 然后存放到自己的本地注册表中去</span></span><br><span class="line">        registry.init(peerEurekaNodes);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    logger.info(<span class="string">"Initialized"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启动eureka集群，这个集群是每个eureka server节点都维护的一组内存对象。</li><li>他的作用是每当本节点发生变更，比如有服务实例注册、下线、心跳续约等事件发生时，会修改这组对象</li><li>然后这组对象负责将修改同步到对应的eureka server节点上去。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class: PeerEurekaNodes</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 搞了一个单线程的线程池 用来跑eureka集群节点的更新任务</span></span><br><span class="line">    taskExecutor = Executors.newSingleThreadScheduledExecutor(</span><br><span class="line">        <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                Thread thread = <span class="keyword">new</span> Thread(r, <span class="string">"Eureka-PeerNodesUpdater"</span>);</span><br><span class="line">                thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">return</span> thread;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这里是更新自己内存中的eureka集群，</span></span><br><span class="line">        <span class="comment">// 对新的eureka节点进行创建实例，然后添加到集群进去</span></span><br><span class="line">        <span class="comment">// 对已经无效的eureka 节点清除出这个集群中</span></span><br><span class="line">        <span class="comment">// 这里被Spring Cloud Netflix Eureka拿来做eureka集群的在线扩缩容</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新eureka server集群信息</span></span><br><span class="line">        updatePeerEurekaNodes(resolvePeerUrls());</span><br><span class="line">        Runnable peersUpdateTask = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    updatePeerEurekaNodes(resolvePeerUrls());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    logger.error(<span class="string">"Cannot update the replica Nodes"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        taskExecutor.scheduleWithFixedDelay(</span><br><span class="line">            peersUpdateTask,</span><br><span class="line">            serverConfig.getPeerEurekaNodesUpdateIntervalMs(),</span><br><span class="line">            serverConfig.getPeerEurekaNodesUpdateIntervalMs(),</span><br><span class="line">            TimeUnit.MILLISECONDS</span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (PeerEurekaNode node : peerEurekaNodes) &#123;</span><br><span class="line">        logger.info(<span class="string">"Replica node URL:  &#123;&#125;"</span>, node.getServiceUrl());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建一个线程池</li><li>解析配置文件中配置的eureka server地址列表</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class: PeerEurekaNodes</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">updatePeerEurekaNodes</span><span class="params">(List&lt;String&gt; newPeerUrls)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里toShutdown就是需要缩容的eureka server节点</span></span><br><span class="line">    <span class="comment">// 实现很简单，就是以最新的服务地址列表为准，除此之外的都需要干掉</span></span><br><span class="line">    Set&lt;String&gt; toShutdown = <span class="keyword">new</span> HashSet&lt;&gt;(peerEurekaNodeUrls);</span><br><span class="line">    toShutdown.removeAll(newPeerUrls);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里toAdd就是需要扩容的eureka server节点</span></span><br><span class="line">    <span class="comment">// 实现很简单，就是拿新增的服务地址列表</span></span><br><span class="line">    Set&lt;String&gt; toAdd = <span class="keyword">new</span> HashSet&lt;&gt;(newPeerUrls);</span><br><span class="line">    toAdd.removeAll(peerEurekaNodeUrls);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove peers no long available</span></span><br><span class="line">    List&lt;PeerEurekaNode&gt; newNodeList = <span class="keyword">new</span> ArrayList&lt;&gt;(peerEurekaNodes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里处理缩容的逻辑</span></span><br><span class="line">    <span class="comment">// 遍历现在的集群里的节点，删除缩容的节点，并且关停缩容的节点</span></span><br><span class="line">    <span class="comment">// 关停缩容的节点 其实没啥特别的 就是释放一些线程池资源而已</span></span><br><span class="line">    <span class="keyword">if</span> (!toShutdown.isEmpty()) &#123;</span><br><span class="line">        logger.info(<span class="string">"Removing no longer available peer nodes &#123;&#125;"</span>, toShutdown);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; newNodeList.size()) &#123;</span><br><span class="line">            PeerEurekaNode eurekaNode = newNodeList.get(i);</span><br><span class="line">            <span class="keyword">if</span> (toShutdown.contains(eurekaNode.getServiceUrl())) &#123;</span><br><span class="line">                newNodeList.remove(i);</span><br><span class="line">                eurekaNode.shutDown();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里处理扩容的逻辑</span></span><br><span class="line">    <span class="comment">// 遍历需要扩容的节点，创建之，加入集群</span></span><br><span class="line">    <span class="comment">// Add new peers</span></span><br><span class="line">    <span class="keyword">if</span> (!toAdd.isEmpty()) &#123;</span><br><span class="line">        logger.info(<span class="string">"Adding new peer nodes &#123;&#125;"</span>, toAdd);</span><br><span class="line">        <span class="keyword">for</span> (String peerUrl : toAdd) &#123;</span><br><span class="line">            newNodeList.add(createPeerEurekaNode(peerUrl));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.peerEurekaNodes = newNodeList;</span><br><span class="line">    <span class="keyword">this</span>.peerEurekaNodeUrls = <span class="keyword">new</span> HashSet&lt;&gt;(newPeerUrls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>集群的扩容和缩容</p><p>扩容</p><ul><li>根据最新的eureka server地址列表</li><li>与老的服务列表做比对，算出新增的服务地址，这里就是需要扩容的节点</li><li>创建节点，加入集群</li></ul><p>缩容</p><ul><li>根据最新的eureka server地址列表</li><li>与老的服务列表做比对，算出待删除的服务地址，这里就是需要缩容的节点</li><li>从集群中剔除节点，释放节点的线程池资源</li></ul></blockquote></li><li><p>集群同步机制怎么实现的？</p><p>每当服务注册、下线、取消、状态变更时，都会执行PeerAwareInstanceRegistryImpl的replicateToPeers的方法，这个方法会将这些动作同步到内存集群的队列中，然后有定时任务，会分派这些动作，将这些动作打成一批批的包，分批请求对应的eureka server。</p><p>在内存集群中，复制任务的接收、分派、消费这套流程采用了三层队列来实现，下面我们分析一下这个机制</p><ul><li><p>每个内存集群中的节点都有两个任务分派器TaskDispatcher</p></li><li><p>每个TaskDispatcher有两个执行器组成</p><ul><li>一个acceptorExecutor，负责接收任务<ul><li>如果重新处理队列、接收队列、待处理任务任意一个不为空，就执行如下逻辑；否则就睡10秒钟<ul><li>任务先进接收队列（acceptorQueue） </li><li>有个叫AcceptorRunner的后台线程不断的消费接收队列<ul><li>不断拉取重新处理队列（reprocessQueue）<ul><li>如果不为空，将里面的任务放到待执行任务（pendingTasks）中去； 插入处理顺序队列（processingOrder）</li><li>如果满了，累加重新处理队列已经清除的任务个数；清空重新处理队列</li></ul></li><li>不断拉取接收队列<ul><li>如果待执行任务满了，处理顺序队列里删除这个任务</li><li>如果没满，就放入待执行任务中去</li><li>如果刚才放入待执行任务中的那个任务是新任务，就将这个任务加入处理顺序队列中去</li></ul></li></ul></li></ul></li><li>分派批处理任务<ul><li>积攒到一批或者待执行任务中最老的任务已经延时超过500毫秒，就将待执行任务任务打成一批，放到批处理任务工作队列里</li></ul></li><li>分派单项处理任务</li></ul></li><li>一个taskExecutor，负责执行任务<ul><li>这里会从批处理任务队列里，一批批的消费，将一批任务一次请求发送到对应的eureka server节点</li></ul></li></ul></li><li><p>总结</p><p><img src="/blog/2020/03/18/服务注册发现：Eureka源码剖析（11）核心机制之EurekaServer集群机制/eureka-server%E5%90%8C%E6%AD%A5%E4%BB%BB%E5%8A%A1%E6%89%B9%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6(1).png" alt="eureka server同步任务批处理机制(1)"></p></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;什么是eureka集群？&lt;br&gt;一组互相复制数据，完全对等的eureka节点。通过配置文件指定，也可以热刷新（扩容缩容）&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Eureka" scheme="http://houqian.github.io/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>服务注册发现：Eureka源码剖析（10）核心机制之Eureka Server网络故障时的自我保护机制</title>
    <link href="http://houqian.github.io/2020/03/09/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%8810%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8BEureka-Server%E7%BD%91%E7%BB%9C%E6%95%85%E9%9A%9C%E6%97%B6%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"/>
    <id>http://houqian.github.io/2020/03/09/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%8810%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8BEureka-Server%E7%BD%91%E7%BB%9C%E6%95%85%E9%9A%9C%E6%97%B6%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</id>
    <published>2020-03-09T11:19:15.000Z</published>
    <updated>2021-06-05T15:24:29.588Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li>自我保护机制是什么？<br>在eureka server中，他假定正常情况下肯定有大于85%的服务实例能够保持正常的心跳，最近1分钟内少于85%的服务实例心跳成功，eureka开发团队认为，此时大概率是eureka server自己的网络故障了，此时再进行过期实例剔除都会是误伤，于是就不再对故障实例剔除。这就叫进入了自我保护机制。</li></ul><a id="more"></a><ul><li><p>自我保护的实现原理</p><p>eureka自我保护机制的代码实现比较零散，逻辑分散的各处，需要仔细翻阅源码才能找到，笔者也是花了几个小时（一个开源项目里的代码质量还真是参差不齐。。。）</p><ul><li><p>在上篇文章讲解的自动摘除服务实例的实现方法evit中，在最开始进行了当前是否进入自我保护状态的判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeaseExpirationEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!isSelfPreservationModeEnabled()) &#123;</span><br><span class="line">           <span class="comment">// The self preservation mode is disabled, hence allowing the instances to expire.</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">       <span class="comment">// 如果开启自我保护机制 就会走下面的逻辑</span></span><br><span class="line">    </span><br><span class="line">       <span class="comment">// numberOfRenewsPerMinThreshold = 服务实例数量 * 2 * 0.85 期望值，最少有85%的实例发送心跳 心跳30秒1次，于是就 *2</span></span><br><span class="line">    </span><br><span class="line">       <span class="comment">// getNumOfRenewsInLastMin() 返回的就是 最近1分钟实际心跳成功的服务实例数</span></span><br><span class="line">       <span class="comment">// 是通过 MeasuredRate 组件 + renew时触发来实现的</span></span><br><span class="line">    </span><br><span class="line">       <span class="comment">// 这个判断的意思也就明了了，最近1分钟实际心跳成功的服务实例数 &gt; 要大于85% ，这个时候才会允许处理过期服务实例</span></span><br><span class="line">    </span><br><span class="line">       <span class="comment">// 为啥这么做？</span></span><br><span class="line">       <span class="comment">// 这也就是eureka所谓的自我保护机制的实现了。他假定正常情况下肯定会有超过85%的服务实例能够心跳成功成功的</span></span><br><span class="line">       <span class="comment">// 如果小于85%，那么就有可能是eureka server自己的网络出现故障了，此时就不能再剔除过期实例了，因为可能是误伤</span></span><br><span class="line">       <span class="comment">// 这种状态下不剔除服务实例，这个操作，就是进入自我保护模式这个动作，达到了自我保护这个状态和效果，此时eureka控制台里也会显示出那行红字</span></span><br><span class="line">    </span><br><span class="line">       <span class="comment">// 为什么测试环境非常容易触发自我保护机制呢？</span></span><br><span class="line">       <span class="comment">// 测试环境频繁的有服务实例注册、销毁，生命周期非常的短，可能连第二次心跳都没进行，这就导致最近一分钟内的服务实例心跳成功数大大降低</span></span><br><span class="line">       <span class="comment">// 非常有可能低于85%，一旦低于85%就会进入自我保护模式。</span></span><br><span class="line">       <span class="comment">// 测试环境这种情况是持续存在的，所以就会显示出eureka持续进入自我保护模式了</span></span><br><span class="line">    </span><br><span class="line">       <span class="comment">// 这个方法 返回true，说明正常；返回false，就是进入了自我保护模式了</span></span><br><span class="line">       <span class="comment">// 这点儿注意，与Spring cloud netflix eureka的实现方式相同，但返回值的含义是相反的</span></span><br><span class="line">       <span class="keyword">return</span> numberOfRenewsPerMinThreshold &gt; <span class="number">0</span> &amp;&amp; getNumOfRenewsInLastMin() &gt; numberOfRenewsPerMinThreshold;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li><p>numberOfRenewsPerMinThreshold 服务实例数量 * 2 * 0.85 期望值，最少有85%的实例发送心跳 心跳30秒1次，于是就 *2</p></li><li><p>getNumOfRenewsInLastMin()  返回的就是 最近1分钟实际心跳成功的服务实例数<br>是通过 MeasuredRate 组件 + renew时触发来实现的<br>也就是每次心跳成功都会对MeasuredRate 内的数值加1，而每隔1分钟，MeasuredRate 组件会把自己的数值清零</p></li><li><p>如果 getNumOfRenewsInLastMin() &gt; numberOfRenewsPerMinThreshold，也就是最近1分钟，少于85%的服务实例心跳成功，就意味着进入了自我保护状态了</p><blockquote><p>这个方法 返回true，说明正常；返回false，就是进入了自我保护模式了</p><p>注意，与Spring cloud netflix eureka的实现方式相同，但返回值的含义是相反的</p></blockquote></li></ul></li></ul></li><li><p>为什么测试环境非常容易触发自我保护机制呢？<br>测试环境频繁的有服务实例注册、销毁，生命周期非常的短，可能连第二次心跳都没进行，这就导致最近一分钟内的服务实例心跳成功数大大降低，非常有可能低于85%，一旦低于85%就会进入自我保护模式。 测试环境这种情况是持续存在的，所以就会显示出eureka持续进入自我保护模式了</p></li></ul><blockquote><p>注意</p><p>自我保护机制的实现，采用了硬编码的方式强制指定了30秒的心跳周期，所以在实际生产中，我们要么不用这个自我保护模式，要么就不要修改心跳间隔，否则逻辑就错乱了</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/blog/2020/03/09/服务注册发现：Eureka源码剖析（10）核心机制之Eureka-Server网络故障时的自我保护机制/eureka%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6.png" alt="eureka自我保护机制"></p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;自我保护机制是什么？&lt;br&gt;在eureka server中，他假定正常情况下肯定有大于85%的服务实例能够保持正常的心跳，最近1分钟内少于85%的服务实例心跳成功，eureka开发团队认为，此时大概率是eureka server自己的网络故障了，此时再进行过期实例剔除都会是误伤，于是就不再对故障实例剔除。这就叫进入了自我保护机制。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Eureka" scheme="http://houqian.github.io/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>服务注册发现：Eureka源码剖析（9）核心机制之服务实例的自动故障感知及自动摘除机制</title>
    <link href="http://houqian.github.io/2020/03/03/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%889%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8B%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B%E7%9A%84%E8%87%AA%E5%8A%A8%E6%95%85%E9%9A%9C%E6%84%9F%E7%9F%A5%E5%8F%8A%E8%87%AA%E5%8A%A8%E6%91%98%E9%99%A4%E6%9C%BA%E5%88%B6/"/>
    <id>http://houqian.github.io/2020/03/03/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%889%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8B%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B%E7%9A%84%E8%87%AA%E5%8A%A8%E6%95%85%E9%9A%9C%E6%84%9F%E7%9F%A5%E5%8F%8A%E8%87%AA%E5%8A%A8%E6%91%98%E9%99%A4%E6%9C%BA%E5%88%B6/</id>
    <published>2020-03-03T11:26:18.000Z</published>
    <updated>2021-06-05T15:24:32.945Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li>故障感知和摘除指的是什么？<br>正常下线，会通过eureka client的shutdown方法进行，走下线流程。<br>当因为一些原因，没有通过正常下线的方式，服务实例却下线了，这种异常情况，成为故障。<br>感知，eureka server会通过定时检查多久没心跳了，感知到这种故障服务实例，并自动从注册表中把这个服务实例摘除。</li></ul><a id="more"></a><ul><li><p>eureka的自动故障感知和自动摘除机制</p><p>在eureka server启动的最后一步，openForTraffic中，最后一步super.postInit()方法里，启动了一个定时过期任务evictionTask</p><ul><li>定时过期任务延迟1分钟开始执行，然后每间隔1分钟执行一次</li><li>该任务会遍历本地注册表里，所有超过3分钟没有心跳的服务实例，将这些服务实例收集起来，这一步算是完成了<strong>自动感知机制</strong></li><li>默认情况下，一次性最多只会过期15%的服务实例</li><li>每个服务实例的剔除，是从收集到的过期服务实例列表里<strong>随机</strong>选择的，最多选择15%个</li><li>接着正式执行每个服务实例的剔除操作<ul><li>从本地注册表里摘除这个故障实例（这一步算是完成了<strong>自动摘除机制</strong>了）</li><li>将这个实例放到最近下线队列里</li><li>从overriddenInstanceStatusMap中移除</li><li>将这个实例放到最近变更队列里</li><li>失效响应缓存（就是那个注册表多级缓存）</li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;故障感知和摘除指的是什么？&lt;br&gt;正常下线，会通过eureka client的shutdown方法进行，走下线流程。&lt;br&gt;当因为一些原因，没有通过正常下线的方式，服务实例却下线了，这种异常情况，成为故障。&lt;br&gt;感知，eureka server会通过定时检查多久没心跳了，感知到这种故障服务实例，并自动从注册表中把这个服务实例摘除。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Eureka" scheme="http://houqian.github.io/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>服务注册发现：Eureka源码剖析（8）核心机制之服务下线与实例摘除</title>
    <link href="http://houqian.github.io/2020/02/25/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%888%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8B%E6%9C%8D%E5%8A%A1%E4%B8%8B%E7%BA%BF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E6%91%98%E9%99%A4/"/>
    <id>http://houqian.github.io/2020/02/25/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%888%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8B%E6%9C%8D%E5%8A%A1%E4%B8%8B%E7%BA%BF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E6%91%98%E9%99%A4/</id>
    <published>2020-02-25T11:11:11.000Z</published>
    <updated>2021-06-05T15:24:36.144Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li>当调用eureka client的shutdown方法时，会走服务下线流程。（这个shutdown方法会在Spring Cloud Netflix中spring上下文关闭时调用）<ul><li>触发下线监听器</li><li>停止调度任务（心跳、拉取注册表）</li><li>调用eureka server的 DELETA /v2/apps/APP_NAME/服务实例ID 接口</li><li>释放一系列jersey client的网络资源</li><li>注销监控<ul><li>心跳监控</li><li>注册表监控</li></ul></li></ul></li></ul><a id="more"></a><ul><li>eureka server的InstanceResource的cancelLease方法接收请求<ul><li>本节点下线<ul><li>把下线的服务实例放入最近下线队列里</li><li>从overriddenInstanceStatusMap中删除这个服务实例</li><li>把下线的服务实例放入最近变更队列里</li><li>失效响应缓存（那个注册表多级缓存）</li></ul></li><li>复制服务实例下线到集群</li></ul></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/blog/2020/02/25/服务注册发现：Eureka源码剖析（8）核心机制之服务下线与实例摘除/%E6%9C%8D%E5%8A%A1%E4%B8%8B%E7%BA%BF%E7%9A%84%E9%80%BB%E8%BE%91(1).png" alt="服务下线的逻辑(1)"></p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;当调用eureka client的shutdown方法时，会走服务下线流程。（这个shutdown方法会在Spring Cloud Netflix中spring上下文关闭时调用）&lt;ul&gt;
&lt;li&gt;触发下线监听器&lt;/li&gt;
&lt;li&gt;停止调度任务（心跳、拉取注册表）&lt;/li&gt;
&lt;li&gt;调用eureka server的 DELETA /v2/apps/APP_NAME/服务实例ID 接口&lt;/li&gt;
&lt;li&gt;释放一系列jersey client的网络资源&lt;/li&gt;
&lt;li&gt;注销监控&lt;ul&gt;
&lt;li&gt;心跳监控&lt;/li&gt;
&lt;li&gt;注册表监控&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Eureka" scheme="http://houqian.github.io/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>服务注册发现：Eureka源码剖析（7）核心机制之Eureka Clien与Eureka Server之间的心跳机制</title>
    <link href="http://houqian.github.io/2020/02/18/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%887%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8BEureka-Clien%E4%B8%8EEureka-Server%E4%B9%8B%E9%97%B4%E7%9A%84%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6/"/>
    <id>http://houqian.github.io/2020/02/18/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%887%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8BEureka-Clien%E4%B8%8EEureka-Server%E4%B9%8B%E9%97%B4%E7%9A%84%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6/</id>
    <published>2020-02-18T11:30:11.000Z</published>
    <updated>2021-06-05T15:24:38.765Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li>当eureka client启动时，会有一个定时任务每隔30秒向eureka server发送心跳<ul><li>心跳会将服务实例信息带上</li><li>请求的eureka server的  PUT /v2/apps/APP_NAME/服务实例ID</li><li>根据响应做如下处理<ul><li>如果返回状态码为404<br>说明eureka server没有这个服务实例，此时会走服务注册流程</li><li>如果返回状态码200，说明心跳成功了，会更新本地的最近一次成功心跳时间戳</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;ul&gt;
&lt;li&gt;当eureka client启动时，会有一个定时任务每隔30秒向</summary>
      
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Eureka" scheme="http://houqian.github.io/tags/Eureka/"/>
    
  </entry>
  
</feed>
