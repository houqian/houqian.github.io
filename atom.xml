<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>且听风吟</title>
  
  <subtitle>647 号小宇宙</subtitle>
  <link href="http://houqian.github.io/atom.xml" rel="self"/>
  
  <link href="http://houqian.github.io/"/>
  <updated>2021-06-06T16:44:11.707Z</updated>
  <id>http://houqian.github.io/</id>
  
  <author>
    <name>侯乾</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>负载均衡：Ribbon总结</title>
    <link href="http://houqian.github.io/2020/05/05/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9ARibbon%E6%80%BB%E7%BB%93/"/>
    <id>http://houqian.github.io/2020/05/05/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9ARibbon%E6%80%BB%E7%BB%93/</id>
    <published>2020-05-05T09:35:21.000Z</published>
    <updated>2021-06-06T16:44:11.707Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>终于，到了和Ribbon系列说再见的时候，笔者任务Ribbon的源码逻辑虽然比Eureka简单一些，但与Spring集成上稍微有点儿绕，主要是自动配置的执行顺序那块儿，如果采用静态代码阅读的方式的话，很难发现问题。不过，这也让笔者对Spring的自动配置机制有了更深的了解。</p><a id="more"></a><hr><p>Ribbon的知识体系笔者认为主要分为4个部分</p><h1 id="组件初始化"><a href="#组件初始化" class="headerlink" title="组件初始化"></a>组件初始化</h1><p><img src="/2020/05/05/负载均衡：Ribbon总结/Ribbon%E7%BB%84%E4%BB%B6%E5%88%9D%E5%A7%8B%E5%8C%96.png" alt="Ribbon组件初始化"></p><h1 id="执行请求"><a href="#执行请求" class="headerlink" title="执行请求"></a>执行请求</h1><p><img src="/2020/05/05/负载均衡：Ribbon总结/Ribbon%E6%89%A7%E8%A1%8C%E8%AF%B7%E6%B1%82.png" alt="Ribbon执行请求"></p><h1 id="定时拉取服务列表"><a href="#定时拉取服务列表" class="headerlink" title="定时拉取服务列表"></a>定时拉取服务列表</h1><p><img src="/2020/05/05/负载均衡：Ribbon总结/Ribbon%E5%AE%9A%E6%97%B6%E6%8B%89%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8.png" alt="Ribbon定时拉取服务列表"></p><h1 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h1><p><img src="/2020/05/05/负载均衡：Ribbon总结/Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95.png" alt="Ribbon负载均衡算法"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;终于，到了和Ribbon系列说再见的时候，笔者任务Ribbon的源码逻辑虽然比Eureka简单一些，但与Spring集成上稍微有点儿绕，主要是自动配置的执行顺序那块儿，如果采用静态代码阅读的方式的话，很难发现问题。不过，这也让笔者对Spring的自动配置机制有了更深的了解。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Ribbon" scheme="http://houqian.github.io/tags/Ribbon/"/>
    
  </entry>
  
  <entry>
    <title>负载均衡：Ribbon源码剖析（4）选举出一个服务后如何发出请求</title>
    <link href="http://houqian.github.io/2020/05/05/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9ARibbon%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%884%EF%BC%89%E9%80%89%E4%B8%BE%E5%87%BA%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%90%8E%E5%A6%82%E4%BD%95%E5%8F%91%E5%87%BA%E8%AF%B7%E6%B1%82/"/>
    <id>http://houqian.github.io/2020/05/05/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9ARibbon%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%884%EF%BC%89%E9%80%89%E4%B8%BE%E5%87%BA%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%90%8E%E5%A6%82%E4%BD%95%E5%8F%91%E5%87%BA%E8%AF%B7%E6%B1%82/</id>
    <published>2020-05-05T04:02:11.000Z</published>
    <updated>2021-06-06T16:44:01.121Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这篇文章算是前面三篇的一个总结，从一个请求被执行的角度，将Spring以及Ribbon的关键组件串起来思考。</p><a id="more"></a><ul><li><code>RestTemplate</code>被加入针对Ribbon的定制的拦截器<code>LoadBalancerInterceptor</code></li><li><code>LoadBalancerInterceptor</code>中将请求委托给<code>RibbonLoadBalancerClient</code></li><li><code>RibbonLoadBalancerClient</code>调用真正的Ribbon组件完成请求<ul><li>负载均衡器<code>ZoneAwareLoadBalancer</code></li><li>负载均衡规则<code>ZoneAvoidanceRule</code></li></ul></li><li><code>request.getURI()</code>–&gt; <code>ServiceRequestWrapper#getURI</code> –&gt; <code>loadBalancer.reconstructURI</code>在这里完成服务名到ip:port的替换</li><li>实际上最后是<code>ClientHttpRequestExecution</code>发起HTTP请求</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>![Ribbon执行请求流程 (1)](负载均衡：Ribbon源码剖析（4）选举出一个服务后如何发出请求/Ribbon执行请求流程 (1).jpg)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇文章算是前面三篇的一个总结，从一个请求被执行的角度，将Spring以及Ribbon的关键组件串起来思考。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Ribbon" scheme="http://houqian.github.io/tags/Ribbon/"/>
    
  </entry>
  
  <entry>
    <title>负载均衡：Ribbon源码剖析（3）默认负载均衡算法可能存在的问题</title>
    <link href="http://houqian.github.io/2020/04/25/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9ARibbon%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%883%EF%BC%89%E9%BB%98%E8%AE%A4%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://houqian.github.io/2020/04/25/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9ARibbon%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%883%EF%BC%89%E9%BB%98%E8%AE%A4%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-04-25T12:11:36.000Z</published>
    <updated>2021-06-06T16:42:41.970Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Ribbon-Eureka感知故障实例的滞后性"><a href="#Ribbon-Eureka感知故障实例的滞后性" class="headerlink" title="Ribbon + Eureka感知故障实例的滞后性"></a>Ribbon + Eureka感知故障实例的滞后性</h1><p>我们先用一张图回顾一下Eureka客户端去Eureka Server拉取服务注册表的情况</p><p><img src="/2020/04/25/负载均衡：Ribbon源码剖析（3）默认负载均衡算法可能存在的问题/Ribbon%E6%84%9F%E7%9F%A5%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B%E6%95%85%E9%9A%9C%E6%9C%80%E9%95%BF%E8%A6%814%E5%88%86%E9%92%9F.jpg" alt="Ribbon感知服务实例故障最长要4分钟"></p><a id="more"></a><ul><li>eureka server在最差情况下要3分钟才能感知到一个实例故障并从服务注册表剔除</li><li>eureka client每隔30秒拉取服务注册表一次</li><li>Spring提供的定时拉取eureka client的注册表，这个定时任务要30秒执行一次</li><li>综上所述，最差情况下Ribbon要4分钟才能感知到一个服务发生故障了</li></ul><blockquote><p>这里的最差情况只会发生在eureka client没有执行shutdown，或者没有调用eureka server对应的下线接口的情况下，这种发生的几率是很小的。</p><p>我们在生产环境中，肯定不是直接kill -9杀死一个服务，而是会做一定的优雅停机，这样的话，一般几十秒左右Ribbon就可以感知到一个服务实例故障，不再去请求这个故障实例了。</p></blockquote><h1 id="Spring是如何应对滞后性的？"><a href="#Spring是如何应对滞后性的？" class="headerlink" title="Spring是如何应对滞后性的？"></a>Spring是如何应对滞后性的？</h1><p>Spring的设计理念是利用Hystrix来填补发往故障实例的请求，直接走对应的降级逻辑，这样就确保不会因为故障实例的问题，导致调用这个故障实例的那些服务长时间不能释放资源，导致服务雪崩。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Ribbon-Eureka感知故障实例的滞后性&quot;&gt;&lt;a href=&quot;#Ribbon-Eureka感知故障实例的滞后性&quot; class=&quot;headerlink&quot; title=&quot;Ribbon + Eureka感知故障实例的滞后性&quot;&gt;&lt;/a&gt;Ribbon + Eureka感知故障实例的滞后性&lt;/h1&gt;&lt;p&gt;我们先用一张图回顾一下Eureka客户端去Eureka Server拉取服务注册表的情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/04/25/负载均衡：Ribbon源码剖析（3）默认负载均衡算法可能存在的问题/Ribbon%E6%84%9F%E7%9F%A5%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B%E6%95%85%E9%9A%9C%E6%9C%80%E9%95%BF%E8%A6%814%E5%88%86%E9%92%9F.jpg&quot; alt=&quot;Ribbon感知服务实例故障最长要4分钟&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Ribbon" scheme="http://houqian.github.io/tags/Ribbon/"/>
    
  </entry>
  
  <entry>
    <title>负载均衡：Ribbon源码剖析（2）维护服务列表</title>
    <link href="http://houqian.github.io/2020/04/19/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9ARibbon%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%882%EF%BC%89%E7%BB%B4%E6%8A%A4%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8/"/>
    <id>http://houqian.github.io/2020/04/19/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9ARibbon%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%882%EF%BC%89%E7%BB%B4%E6%8A%A4%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8/</id>
    <published>2020-04-19T14:10:03.000Z</published>
    <updated>2021-06-06T16:43:42.105Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我们上篇已经知道<code>PollingServerListUpdater</code>有可能是负责与Eureka交互定时获取服务列表的，本篇我们就剖析下这个组件相关的逻辑。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PollingServerListUpdater</span> <span class="keyword">implements</span> <span class="title">ServerListUpdater</span></span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">static</span> <span class="title">long</span> <span class="title">LISTOFSERVERS_CACHE_UPDATE_DELAY</span> </span>= <span class="number">1000</span>; <span class="comment">// msecs;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> LISTOFSERVERS_CACHE_REPEAT_INTERVAL = <span class="number">30</span> * <span class="number">1000</span>; <span class="comment">// msecs;</span></span><br></pre></td></tr></table></figure><ul><li>LISTOFSERVERS_CACHE_UPDATE_DELAY<br>服务列表缓存更新延时时间默认是1秒</li><li>LISTOFSERVERS_CACHE_REPEAT_INTERVAL<br>服务列表更新间隔默认是30秒</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PollingServerListUpdater</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">@<span class="title">Override</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">synchronized</span> <span class="title">void</span> <span class="title">start</span>(<span class="title">final</span> <span class="title">UpdateAction</span> <span class="title">updateAction</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Runnable wrapperRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 这行代码就是拉取服务列表的核心逻辑</span></span><br><span class="line">                    updateActiondoUpdate();</span><br><span class="line">                    lastUpdated = SystemcurrentTimeMillis();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            scheduledFuture = getRefreshExecutor()scheduleWithFixedDelay(</span><br><span class="line">                    wrapperRunnable,</span><br><span class="line">                    initialDelayMs,</span><br><span class="line">                    refreshIntervalMs,</span><br><span class="line">                    TimeUnitMILLISECONDS</span><br><span class="line">            );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>updateActiondoUpdate<br>通过引用分析，可以得到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicServerListLoadBalancer</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class"><span class="title">protected</span> <span class="title">final</span> <span class="title">ServerListUpdaterUpdateAction</span> <span class="title">updateAction</span> </span>= <span class="keyword">new</span> ServerListUpdaterUpdateAction() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        updateListOfServers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>原来逻辑就是这个<code>updateListOfServers()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateListOfServers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;T&gt; servers = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">    <span class="keyword">if</span> (serverListImpl != <span class="keyword">null</span>) &#123;</span><br><span class="line">        servers = serverListImplgetUpdatedListOfServers();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (filter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            servers = filtergetFilteredListOfServers(servers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    updateAllServerList(servers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>serverListImplgetUpdatedListOfServers<br>看到此处，笔者当时也是比较疑惑，因为上篇文章里的那个<code>ConfigurationBasedServerList</code>并没有这个方法，在查找实现类后，笔者发现事情并不简单，经过一番debug后结论如下：</p><blockquote><ul><li>Spring提供的默认ServerList是<code>DomainExtractingServerList</code></li><li>Spring提供的默认IPing是<code>NIWSDiscoveryPing</code></li></ul><p>有兴趣的同学可以看一下<code>EurekaRibbonClientConfiguration</code>这个自动配置类，你会发现这里也声明了ribbon的核心组件。为了验证到底哪个会生效，可以分别对对应创建bean的方法打上断点debug一下，笔者上述结论就是这么得出的。</p><p>顺便说一下，这和Spring初始化自动装配类的顺序有关。</p></blockquote></li><li><p>事实上，<code>serverListImplgetUpdatedListOfServers</code>最后调用的是<code>DiscoveryEnabledNIWSServerList#obtainServersViaDiscovery</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;DiscoveryEnabledServer&gt; <span class="title">obtainServersViaDiscovery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;DiscoveryEnabledServer&gt; serverList = <span class="keyword">new</span> ArrayList&lt;DiscoveryEnabledServer&gt;();</span><br><span class="line"></span><br><span class="line">    EurekaClient eurekaClient = eurekaClientProviderget();</span><br><span class="line">    <span class="keyword">if</span> (vipAddresses!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">// vipAddresses</span></span><br><span class="line">        <span class="keyword">for</span> (String vipAddress : vipAddressessplit(<span class="string">","</span>)) &#123;</span><br><span class="line">            List&lt;InstanceInfo&gt; listOfInstanceInfo = eurekaClientgetInstancesByVipAddress(vipAddress, isSecure, targetRegion);</span><br><span class="line">            <span class="keyword">for</span> (InstanceInfo ii : listOfInstanceInfo) &#123;</span><br><span class="line">                <span class="keyword">if</span> (iigetStatus()equals(InstanceStatusUP)) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(shouldUseOverridePort)&#123;</span><br><span class="line">                        InstanceInfo copy = <span class="keyword">new</span> InstanceInfo(ii);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    DiscoveryEnabledServer des = createServer(ii, isSecure, shouldUseIpAddr);</span><br><span class="line">                    serverListadd(des);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (serverListsize()&gt;<span class="number">0</span> &amp;&amp; prioritizeVipAddressBasedServers)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> serverList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>此处的逻辑非常直观，就是根据vipAddress，也就是serverId、AppName，取出对应的服务实例列表，然后根据服务实例列表构造出Ribbon的`DiscoveryEnabledServer`</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Spring通过一个<code>PollingServerListUpdater</code>定时任务每隔30秒，委托<code>DiscoveryEnabledNIWSServerList</code>组件的<code>obtainServersViaDiscovery</code>方法，从eureka client中拉取RibbonClient配置的服务对应的的服务器列表</li></ul><p>正确的默认组件如下</p><ul><li><p>Spring提供的默认ServerList是<code>DomainExtractingServerList</code></p></li><li><p>Spring提供的默认IPing是<code>NIWSDiscoveryPing</code></p></li><li><p>Spring提供的默认负载均衡器是<code>ZoneAwareLoadBalancer</code></p></li><li><p>Spring提供的默认负载均衡规则是<code>ZoneAvoidanceRule</code></p></li><li><p>Spring提供的默认RestClient是<code>OverrideRestClient</code></p></li><li><p>Spring定时更新服务列表的组件是<code>PollingServerListUpdater</code></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们上篇已经知道&lt;code&gt;PollingServerListUpdater&lt;/code&gt;有可能是负责与Eureka交互定时获取服务列表的，本篇我们就剖析下这个组件相关的逻辑。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Ribbon" scheme="http://houqian.github.io/tags/Ribbon/"/>
    
  </entry>
  
  <entry>
    <title>负载均衡：Ribbon源码剖析（1）创建负载均衡器</title>
    <link href="http://houqian.github.io/2020/04/13/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9ARibbon%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%881%EF%BC%89%E5%88%9B%E5%BB%BA%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8/"/>
    <id>http://houqian.github.io/2020/04/13/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9ARibbon%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%881%EF%BC%89%E5%88%9B%E5%BB%BA%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8/</id>
    <published>2020-04-13T13:29:35.000Z</published>
    <updated>2021-06-06T16:40:06.948Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h1><p>我们在每次使用Spring Cloud Netflix Ribbon的时候，有一个固定的套路就是需要用<code>@LoadBalanced</code>注解修饰一个<code>RestTemplate</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>根据以往Spring Cloud集成套路，必然会有一个与之相关的自动配置类，果不其然，找到了一个<code>LoadBalancerAutoConfiguration</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(RestTemplate.class)</span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(LoadBalancerClient.class)</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(LoadBalancerRetryProperties.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalancerAutoConfiguration</span> </span>&#123;</span><br></pre></td></tr></table></figure><ul><li>ConditionalOnBean<br>会依赖一个叫<code>LoadBalancerClient</code>的对象</li><li>LoadBalancerRetryProperties<br>开启了一个配置，是Ribbon重试相关的</li></ul><p>下面这行代码，比较灵活的运用了Spring原生注解的特性，作用就是把所有的被@LoadBalanced注解修饰的RestTemplate对象都收集到这个集合里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RibbonAutoConfiguration</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">@<span class="title">LoadBalanced</span></span></span><br><span class="line"><span class="class">@<span class="title">Autowired</span>(<span class="title">required</span> </span>= <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> List&lt;RestTemplate&gt; restTemplates = Collections.emptyList();</span><br></pre></td></tr></table></figure><blockquote><p>其实现原理，玄机在<code>@LoadBalanced</code>中，可以看到该注解上被<code>@Qulifier</code>注解修饰，这就触发了Spring一个比较偏门的特性，Spring会把这个注解修饰的对象注册到Spring容器中去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">@Target</span>(&#123; ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD &#125;)</span><br><span class="line">&gt; <span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line">&gt; <span class="meta">@Documented</span></span><br><span class="line">&gt; <span class="meta">@Inherited</span></span><br><span class="line">&gt; <span class="meta">@Qualifier</span> <span class="comment">// 注意这个</span></span><br><span class="line">&gt; <span class="keyword">public</span> <span class="meta">@interface</span> LoadBalanced &#123;</span><br><span class="line">&gt; </span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>有兴趣的朋友可以看看Spring处理<code>@Qulifier</code>的过程。QualifierAnnotationAutowireCandidateResolver#checkQualifier方法</p></blockquote><p>接着，我们看到了Spring集成Ribbon关键的一步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RibbonAutoConfiguration</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">@<span class="title">Configuration</span>(<span class="title">proxyBeanMethods</span> </span>= <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnMissingClass</span>(<span class="string">"org.springframework.retry.support.RetryTemplate"</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalancerInterceptorConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> LoadBalancerInterceptor <span class="title">ribbonInterceptor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">         LoadBalancerClient loadBalancerClient,</span></span></span><br><span class="line"><span class="function"><span class="params">         LoadBalancerRequestFactory requestFactory)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> LoadBalancerInterceptor(loadBalancerClient, requestFactory);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> RestTemplateCustomizer <span class="title">restTemplateCustomizer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">final</span> LoadBalancerInterceptor loadBalancerInterceptor)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> restTemplate -&gt; &#123;</span><br><span class="line">         List&lt;ClientHttpRequestInterceptor&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">               restTemplate.getInterceptors());</span><br><span class="line">         list.add(loadBalancerInterceptor);</span><br><span class="line">         restTemplate.setInterceptors(list);</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>LoadBalancerInterceptor<br>这是Spring与Ribbon代码的关键结合点。他是通过Spring为Ribbon定制的RestTemplate拦截器来实现的，在这个拦截器里，完成了将RestTemplate收到的请求委托给Ribbon处理的逻辑。</p></li><li><p>restTemplateCustomizer<br>这里就是对Ribbon的RestTemplate拦截器加入到restTemplate中去。<br>这一步的逻辑要结合着此处去看，一下子就明白了。原来Spring就是把被<code>@LoadBalanced</code>修饰的RestTemplate收集起来，然后一个个遍历，在每一个RestTemplate里追加一个为Ribbon定制的拦截器，完成了请求的委托处理，这算是Spring整合Ribbon最核心的逻辑之一了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RibbonAutoConfiguration</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    @<span class="title">Bean</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">SmartInitializingSingleton</span> <span class="title">loadBalancedRestTemplateInitializerDeprecated</span>(</span></span><br><span class="line"><span class="class">          <span class="title">final</span> <span class="title">ObjectProvider</span>&lt;<span class="title">List</span>&lt;<span class="title">RestTemplateCustomizer</span>&gt;&gt; <span class="title">restTemplateCustomizers</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> () -&gt; restTemplateCustomizers.ifAvailable(customizers -&gt; &#123;</span><br><span class="line">          <span class="keyword">for</span> (RestTemplate restTemplate : LoadBalancerAutoConfiguration.<span class="keyword">this</span>.restTemplates) &#123;</span><br><span class="line">             <span class="keyword">for</span> (RestTemplateCustomizer customizer : customizers) &#123;</span><br><span class="line">                customizer.customize(restTemplate);</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Spring整合Ribbon的核心结合点"><a href="#Spring整合Ribbon的核心结合点" class="headerlink" title="Spring整合Ribbon的核心结合点"></a>Spring整合Ribbon的核心结合点</h1><p>既然如此，我们就看看在为Ribbon定制的RestTemplate拦截器里具体完成了什么事情吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalancerInterceptor</span> <span class="keyword">implements</span> <span class="title">ClientHttpRequestInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> LoadBalancerClient loadBalancer;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> LoadBalancerRequestFactory requestFactory;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ClientHttpResponse <span class="title">intercept</span><span class="params">(<span class="keyword">final</span> HttpRequest request, <span class="keyword">final</span> <span class="keyword">byte</span>[] body,</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">final</span> ClientHttpRequestExecution execution)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       </span><br><span class="line">      <span class="keyword">final</span> URI originalUri = request.getURI();</span><br><span class="line">      String serviceName = originalUri.getHost();</span><br><span class="line">       </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.loadBalancer.execute(serviceName,</span><br><span class="line">            <span class="keyword">this</span>.requestFactory.createRequest(request, body, execution));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>LoadBalancerClient<br>这个里面其实存放了Ribbon的几个核心组件，比如ILoadBalancer、IRule、RestClient、IPing等等，这个我们后面再仔细看，这里有个印象就好</li><li>LoadBalancerRequestFactory<br>这里完成了遍历RestTemplate里的拦截器链，并一个个执行</li><li>loadBalancer.execute<br>这里最最关键，完成了RestTemplate请求到Ribbon请求的转换，并且将请求委托给Ribbon处理</li></ul><blockquote><p>这段代码实现的非常优雅，不像我们之前分析Eureka源码的时候，都是大段大段的代码，看起来令人眼花缭乱，其最主要的槽点就是控制和业务逻辑没有做到很好的分离。人家Spring通过一系列组件的封装，控制逻辑，比如这里的请求转换，请求委托都清爽的呈现在我们眼前，让人一眼就知道Spring干了什么。如果想更详细的了解具体的处理逻辑，只要看那个组件的很少的代码就可以了，非常的内聚，我们要向这种代码风格学习</p></blockquote><h1 id="看看到底负载均衡器是如何创建的"><a href="#看看到底负载均衡器是如何创建的" class="headerlink" title="看看到底负载均衡器是如何创建的"></a>看看到底负载均衡器是如何创建的</h1><p>我们上面已经分析了Spring集成Ribbon的核心骨架代码的一部分了，剩下的其实都是比较零散，也可以说非常内聚的点了，逐个击破即可。<br>其实在<code>RibbonAutoConfiguration</code>中还有一个关键的对象被创建了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RibbonAutoConfiguration</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    @<span class="title">Bean</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">SpringClientFactory</span> <span class="title">springClientFactory</span>() </span>&#123;</span><br><span class="line">       SpringClientFactory factory = <span class="keyword">new</span> SpringClientFactory();</span><br><span class="line">       factory.setConfigurations(<span class="keyword">this</span>.configurations);</span><br><span class="line">       <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们看到他的方法列表，就会倍感熟悉，这ILoadBalancer不就是负载均衡器吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringClientFactory</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">SpringClientFactory</span>() </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(RibbonClientConfiguration.class, NAMESPACE, <span class="string">"ribbon.client.name"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  IClient&lt;?, ?&gt;&gt; C getClient</span><br><span class="line">  ILoadBalancer getLoadBalancer</span><br></pre></td></tr></table></figure><p>我们此时先按捺住激动的心情，先看看构造器里的<code>RibbonClientConfiguration</code>是个什么东东吧。</p><blockquote><p>根据笔者阅读Spring集成代码的经验，涉及到三方技术核心组件创建的这样重要逻辑，Spring往往是在xxConfiguration里完成的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RibbonClientConfiguration</span> </span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    @<span class="title">Bean</span></span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnMissingBean</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">IRule</span> <span class="title">ribbonRule</span>(<span class="title">IClientConfig</span> <span class="title">config</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(IRule.class, name)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(IRule.class, config, name);</span><br><span class="line">    &#125;</span><br><span class="line">    ZoneAvoidanceRule rule = <span class="keyword">new</span> ZoneAvoidanceRule();</span><br><span class="line">    rule.initWithNiwsConfig(config);</span><br><span class="line">    <span class="keyword">return</span> rule;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>我们的选择是没有白费，看看这是什么，这里构建了一个IRule的实现ZoneAvoidanceRule，Ribbon组件+1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RibbonClientConfiguration</span> </span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    @<span class="title">Bean</span></span></span><br><span class="line"><span class="class">    @<span class="title">ConditionalOnMissingBean</span></span></span><br><span class="line">    @SuppressWarnings("unchecked")</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerList&lt;Server&gt; <span class="title">ribbonServerList</span><span class="params">(IClientConfig config)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(ServerList.class, name)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(ServerList.class, config, name);</span><br><span class="line">       &#125;</span><br><span class="line">       ConfigurationBasedServerList serverList = <span class="keyword">new</span> ConfigurationBasedServerList();</span><br><span class="line">       serverList.initWithNiwsConfig(config);</span><br><span class="line">       <span class="keyword">return</span> serverList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerListUpdater <span class="title">ribbonServerListUpdater</span><span class="params">(IClientConfig config)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> PollingServerListUpdater(config);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>ServerList<br>服务列表，Ribbon的核心概念</p></li><li><p>ServerListUpdater<br>服务列表更新器，我们知道Ribbon的服务列表肯定是来自于Eureka，这个更新器的作用就不难猜测了<br>PollingServerListUpdater，定时从Eureka那边拉取服务列表，至此，Spring集成Ribbon的所有核心逻辑都已经看到了</p><blockquote><p>这里不得不再夸赞一下Spring的代码水平，非常的高内聚，上一个是静态的服务列表，紧挨着就是服务列表的动态更新。<br>这种代码对阅读者实在是太爽了，是一种享受。</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RibbonClientConfiguration</span> </span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    @<span class="title">Bean</span></span></span><br><span class="line"><span class="class">    @<span class="title">ConditionalOnMissingBean</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ILoadBalancer</span> <span class="title">ribbonLoadBalancer</span>(<span class="title">IClientConfig</span> <span class="title">config</span>,</span></span><br><span class="line"><span class="class">          <span class="title">ServerList</span>&lt;<span class="title">Server</span>&gt; <span class="title">serverList</span>, <span class="title">ServerListFilter</span>&lt;<span class="title">Server</span>&gt; <span class="title">serverListFilter</span>,</span></span><br><span class="line"><span class="class">          <span class="title">IRule</span> <span class="title">rule</span>, <span class="title">IPing</span> <span class="title">ping</span>, <span class="title">ServerListUpdater</span> <span class="title">serverListUpdater</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(ILoadBalancer.class, name)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(ILoadBalancer.class, config, name);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ZoneAwareLoadBalancer&lt;&gt;(config, rule, ping, serverList,</span><br><span class="line">             serverListFilter, serverListUpdater);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>来了来了，我们本篇也可以拉下帷幕了<br>此处就是ILoadBalancer负载均衡器的创建逻辑<br>可以看到是用的ZoneAwareLoadBalancer这个实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RibbonClientConfiguration</span> </span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class"><span class="title">static</span> <span class="title">class</span> <span class="title">OverrideRestClient</span> <span class="keyword">extends</span> <span class="title">RestClient</span></span></span><br></pre></td></tr></table></figure></li><li><p>OverrideRestClient，Ribbon的核心RestClient实现类<br>通过引用分析，可以知道这个OverrideRestClient就是Spring提供的默认RestClient实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RestClientRibbonConfiguration</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    @<span class="title">Bean</span></span></span><br><span class="line"><span class="class">@<span class="title">Lazy</span></span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnMissingBean</span>(<span class="title">AbstractLoadBalancerAwareClient</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">RestClient</span> <span class="title">ribbonRestClient</span>(<span class="title">IClientConfig</span> <span class="title">config</span>, <span class="title">ILoadBalancer</span> <span class="title">loadBalancer</span>,</span></span><br><span class="line"><span class="class"><span class="title">ServerIntrospector</span> <span class="title">serverIntrospector</span>, <span class="title">RetryHandler</span> <span class="title">retryHandler</span>) </span>&#123;</span><br><span class="line">    RestClient client = <span class="keyword">new</span> RibbonClientConfiguration.OverrideRestClient(config,</span><br><span class="line">        serverIntrospector);</span><br><span class="line">    client.setLoadBalancer(loadBalancer);</span><br><span class="line">    client.setRetryHandler(retryHandler);</span><br><span class="line">    <span class="keyword">return</span> client;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>阅读Spring的代码是令人愉悦的，写法非常的高内聚，相关的逻辑紧紧的放在一处，生怕你看漏了。低耦合，控制与业务逻辑分离，非常清爽。</p><blockquote><p>此处的结论在我们当前的视角是合乎逻辑的，但实际上与这个结果是有一些出入的，我们在后续的篇幅里再行探讨。</p></blockquote><ul><li>Spring提供的默认负载均衡器是<code>ZoneAwareLoadBalancer</code></li><li>Spring提供的默认负载均衡规则是<code>ZoneAvoidanceRule</code></li><li>Spring提供的默认RestClient是<code>OverrideRestClient</code></li><li>Spring提供的默认检查存活组件是<code>DummyPing</code></li><li>Spring定时更新服务列表的组件是<code>PollingServerListUpdater</code></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;入口&quot;&gt;&lt;a href=&quot;#入口&quot; class=&quot;headerlink&quot; title=&quot;入口&quot;&gt;&lt;/a&gt;入口&lt;/h1&gt;&lt;p&gt;我们在每次使用Spring Cloud Netflix Ribbon的时候，有一个固定的套路就是需要用&lt;code&gt;@LoadBalanced&lt;/code&gt;注解修饰一个&lt;code&gt;RestTemplate&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@LoadBalanced&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; RestTemplate &lt;span class=&quot;title&quot;&gt;getRestTemplate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RestTemplate();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Ribbon" scheme="http://houqian.github.io/tags/Ribbon/"/>
    
  </entry>
  
  <entry>
    <title>负载均衡：Ribbon入门</title>
    <link href="http://houqian.github.io/2020/04/08/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9ARibbon%E5%85%A5%E9%97%A8/"/>
    <id>http://houqian.github.io/2020/04/08/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9ARibbon%E5%85%A5%E9%97%A8/</id>
    <published>2020-04-08T12:32:21.000Z</published>
    <updated>2021-06-06T16:43:24.884Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Ribbon解决了什么问题"><a href="#Ribbon解决了什么问题" class="headerlink" title="Ribbon解决了什么问题"></a>Ribbon解决了什么问题</h1><p>当集群中有了注册中心之后，服务消费者可以拿到所有服务的列表，此时就需要有一个组件能够将请求负载均衡到各个实例上去。ribbon就是这样一个客户端侧的负载均衡组件，同出Netflix，与其他组件整合后非常实用。</p><p>Ribbon提供了多种不同的负载均衡算法实现，非常实用。</p><a id="more"></a><h1 id="快速体验Ribbon（一）"><a href="#快速体验Ribbon（一）" class="headerlink" title="快速体验Ribbon（一）"></a>快速体验Ribbon（一）</h1><p>此次我们直接基于原生ribbon体验下他的API，这是由于Spring Cloud Netflix对Ribbon的封装比较彻底，几乎没有使用成本，这也让我们很难了解到Ribbon的架构设计理念、核心概念、API等。</p><h2 id="1、开发一个服务提供者"><a href="#1、开发一个服务提供者" class="headerlink" title="1、开发一个服务提供者"></a>1、开发一个服务提供者</h2><p>依赖项</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>服务接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/greeting"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment env;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/sayHello/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(@PathVariable(<span class="string">"name"</span>)</span> String name) </span>&#123;</span><br><span class="line">        log.info(<span class="string">"port:&#123;&#125;, name:&#123;&#125;"</span>, env.getProperty(<span class="string">"local.server.port"</span>), name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello, "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingServiceApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(GreetingServiceApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别使用如下两个端口启动工程</p><p>application.yml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#server:</span></span><br><span class="line"><span class="comment">#  port: 8080</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8088</span></span><br></pre></td></tr></table></figure><h2 id="2、开发一个服务调用者"><a href="#2、开发一个服务调用者" class="headerlink" title="2、开发一个服务调用者"></a>2、开发一个服务调用者</h2><p>依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.ribbon<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.ribbon<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ribbon-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.ribbon<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ribbon-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.ribbon<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ribbon-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.archaius<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>archaius-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.7.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>16.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-configuration<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-configuration<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ribbon.version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">ribbon.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">archaius-core.version</span>&gt;</span>0.7.6<span class="tag">&lt;/<span class="name">archaius-core.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>服务消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.netflix.client.ClientFactory;</span><br><span class="line"><span class="keyword">import</span> com.netflix.client.http.HttpRequest;</span><br><span class="line"><span class="keyword">import</span> com.netflix.client.http.HttpResponse;</span><br><span class="line"><span class="keyword">import</span> com.netflix.config.ConfigurationManager;</span><br><span class="line"><span class="keyword">import</span> com.netflix.niws.client.http.RestClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 基于ribbon的api来开发一个可以负载均衡调用一个服务的代码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先使用代码的方式对ribbon进行一下配置，配置一下ribbon要调用的那个服务的server list</span></span><br><span class="line">        ConfigurationManager.getConfigInstance().setProperty(</span><br><span class="line">                <span class="string">"greeting-service.ribbon.listOfServers"</span>, <span class="string">"localhost:8080,localhost:8088"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取指定服务的RestClient，用于请求某个服务的client</span></span><br><span class="line">        RestClient restClient = (RestClient) ClientFactory.getNamedClient(<span class="string">"greeting-service"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 你要请求哪个接口，构造一个对应的HttpRequest</span></span><br><span class="line">        HttpRequest request = HttpRequest.newBuilder()</span><br><span class="line">                .uri(<span class="string">"/greeting/sayHello/leo"</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟请求一个接口10次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            HttpResponse response = restClient.executeWithLoadBalancer(request);</span><br><span class="line">            String result = response.getEntity(String.class);</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、开始实验"><a href="#3、开始实验" class="headerlink" title="3、开始实验"></a>3、开始实验</h2><p>运行GreetingClient，发现10次调用被均匀的分给了两个服务实例，实现了负载均衡。</p><p><img src="/2020/04/08/负载均衡：Ribbon入门/Ribbon%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E6%96%B9.png" alt="Ribbon服务消费方"></p><p><img src="/2020/04/08/负载均衡：Ribbon入门/Ribbon%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E6%96%B91.png" alt="Ribbon服务提供方1"></p><p><img src="/2020/04/08/负载均衡：Ribbon入门/Ribbon%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E6%96%B92.png" alt="Ribbon服务提供方2"></p><h1 id="快速体验Ribbon（二）"><a href="#快速体验Ribbon（二）" class="headerlink" title="快速体验Ribbon（二）"></a>快速体验Ribbon（二）</h1><h2 id="1、体验底层的负载均衡器API"><a href="#1、体验底层的负载均衡器API" class="headerlink" title="1、体验底层的负载均衡器API"></a>1、体验底层的负载均衡器API</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingClient2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ILoadBalancer loadBalancer = <span class="keyword">new</span> BaseLoadBalancer();</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Server&gt; servers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        servers.add(<span class="keyword">new</span> Server(<span class="string">"localhost"</span>, <span class="number">8080</span>));</span><br><span class="line">        servers.add(<span class="keyword">new</span> Server(<span class="string">"localhost"</span>, <span class="number">8088</span>));</span><br><span class="line">        loadBalancer.addServers(servers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认使用round robin轮询策略</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Server server = loadBalancer.chooseServer(<span class="keyword">null</span>);</span><br><span class="line">            System.out.println(<span class="string">"chosen server:"</span> + server);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/08/负载均衡：Ribbon入门/Ribbon%E5%BA%95%E5%B1%82%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8API.png" alt="Ribbon底层的负载均衡器API"></p><p>可以看到，底层默认的负载均衡算法就是轮询算法。RestClient底层也是依赖负载均衡器工作的</p><h2 id="2、自定义负载均衡规则"><a href="#2、自定义负载均衡规则" class="headerlink" title="2、自定义负载均衡规则"></a>2、自定义负载均衡规则</h2><p>负载均衡器是基于一个IRule接口指定的负载均衡规则，来从服务器列表里获取每次要请求的服务器的，所以可以自定义负载均衡规则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义负载均衡策略，这里就返回第一个服务作为示例了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRule</span> <span class="keyword">implements</span> <span class="title">IRule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ILoadBalancer loadBalancer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        List&lt;Server&gt; servers = loadBalancer.getAllServers();</span><br><span class="line">        <span class="keyword">return</span> servers.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoadBalancer</span><span class="params">(ILoadBalancer lb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadBalancer = lb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ILoadBalancer <span class="title">getLoadBalancer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.loadBalancer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    BaseLoadBalancer loadBalancer = <span class="keyword">new</span> BaseLoadBalancer();</span><br><span class="line">    MyRule myRule = <span class="keyword">new</span> MyRule();</span><br><span class="line">    myRule.setLoadBalancer(loadBalancer);</span><br><span class="line">    loadBalancer.setRule(myRule);</span><br><span class="line"></span><br><span class="line">    List&lt;Server&gt; servers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    servers.add(<span class="keyword">new</span> Server(<span class="string">"localhost"</span>, <span class="number">8080</span>));</span><br><span class="line">    servers.add(<span class="keyword">new</span> Server(<span class="string">"localhost"</span>, <span class="number">8088</span>));</span><br><span class="line">    loadBalancer.addServers(servers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认使用round robin轮询策略</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        Server server = loadBalancer.chooseServer(<span class="keyword">null</span>);</span><br><span class="line">        System.out.println(<span class="string">"chosen server:"</span> + server);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下，Ribbon内置的负载均衡规则就足够使用了，这里仅仅是为了体验一下底层API的设计。我们通过这个实验了解了ILoadBalancer和IRule是什么，两者有什么关系，以及特定场景下可以通过实现IRule接口实现自己的负载均衡规则（算法）。</p><h2 id="3、Ribbon内置负载均衡规则"><a href="#3、Ribbon内置负载均衡规则" class="headerlink" title="3、Ribbon内置负载均衡规则"></a>3、Ribbon内置负载均衡规则</h2><p><img src="/2020/04/08/负载均衡：Ribbon入门/Ribbon%E5%86%85%E7%BD%AE%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%A7%84%E5%88%99.png" alt="Ribbon内置的负载均衡规则"></p><ul><li><p>RoundRobinRule：默认的负载均衡规则。直接从一堆server list中，不断轮询选择出一个server，每个server收到的请求是均匀的。</p></li><li><p>AvailabilityFilteringRule: 这个rule会检查服务器的可用性<br>如果连续3次连接失败，就会等待30秒后再次访问；<br>如果不断失败，那么等待时间会不断变长。<br>如果某个服务器的并发请求太高了，那么会绕过去，不再访问。</p></li><li><p>WeightedResponseTimeRule: 附带权重的，每个服务器可以指定一个权重，权重越高优先访问，如果魔鬼服务器响应时间比较长，那么权重就会降低，减少访问</p></li><li><p>ZoneAvoidanceRule：根据区域和服务器来进行负载均衡，根据机房划分</p></li><li><p>BestAvailableRule：忽略那些连接失败的服务器，然后尽量找并发比较低的服务器来请求</p></li><li><p>RandomRule：随机选择一个服务器</p></li><li><p>RetryRule：可以重试，先通过round robin找到的服务器，如果请求失败，就会接着会重新找一个服务器</p></li></ul><p>可以看到，ribbon主打的就是负载均衡、网络通信，别的一些东西都是次要的。本系列文章会分析一些负载均衡算法的实现，以及看ribbon+eureka+spring cloud是如何整合使用的，会从源码角度分析下ribbon里的一些配置参数</p><h1 id="快速体验Ribbon（三）"><a href="#快速体验Ribbon（三）" class="headerlink" title="快速体验Ribbon（三）"></a>快速体验Ribbon（三）</h1><h2 id="1、体验Ribbon中健康检查组件IPing"><a href="#1、体验Ribbon中健康检查组件IPing" class="headerlink" title="1、体验Ribbon中健康检查组件IPing"></a>1、体验Ribbon中健康检查组件IPing</h2><p>负载均衡器ILoadBalancer里，有IRule负责负载均衡的规则，选择一个服务器；还有一个IPing组件负责定时ping每个服务器，判断其是否存活。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingClient4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        BaseLoadBalancer loadBalancer = <span class="keyword">new</span> BaseLoadBalancer();</span><br><span class="line"></span><br><span class="line">        List&lt;Server&gt; servers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        servers.add(<span class="keyword">new</span> Server(<span class="string">"localhost"</span>, <span class="number">8080</span>));</span><br><span class="line">        servers.add(<span class="keyword">new</span> Server(<span class="string">"localhost"</span>, <span class="number">8088</span>));</span><br><span class="line">        loadBalancer.addServers(servers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每隔1秒ping一次上面那2个server</span></span><br><span class="line">        loadBalancer.setPing(<span class="keyword">new</span> PingUrl(<span class="keyword">false</span>, <span class="string">"/greeting/ping"</span>));</span><br><span class="line">        loadBalancer.setPingInterval(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Server server = loadBalancer.chooseServer(<span class="keyword">null</span>);</span><br><span class="line">            System.out.println(server);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过给负载均衡器LoadBalancer设置Ping组件，比如要ping的url，间隔时间等，就可以使用ping功能了。为了实验效果，笔者在原来的greeting服务里新加了一个ping接口，这个接口是个GET接口，没有逻辑和返回值。在启动实验时，可以等1~2秒，停掉其中一个greeting服务实例，可以观察到有趣的现象</p><p><img src="/2020/04/08/负载均衡：Ribbon入门/%E5%AE%9E%E9%AA%8CRibbon%E7%9A%84ping%E7%BB%84%E4%BB%B6.png" alt="实验Ribbon的ping组件"></p><p>笔者停掉了8088端口的实例，可以看到此时选取的服务器已经都是8080了，这在生产环境是比较实用的。</p><blockquote><p>在生产环境，如果我们想要自定义更为强大的健康检查接口，可以通过实现IPing这个接口，覆盖里面的isAlive方法来实现。</p></blockquote><h1 id="快速体验Ribbon（四）"><a href="#快速体验Ribbon（四）" class="headerlink" title="快速体验Ribbon（四）"></a>快速体验Ribbon（四）</h1><h2 id="1、改造eureka入门里的实验代码"><a href="#1、改造eureka入门里的实验代码" class="headerlink" title="1、改造eureka入门里的实验代码"></a>1、改造eureka入门里的实验代码</h2><p>在eureka入门里，我们其实已经体验过了，这里为了更明显，对之前的代码稍加改造即可。</p><p>服务A-服务提供者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceAController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/sayHello/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(@PathVariable(<span class="string">"name"</span>)</span> String name) </span>&#123;</span><br><span class="line">        Integer port = environment.getProperty(<span class="string">"local.server.port"</span>, Integer.class);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello,"</span> + name + <span class="string">", came from "</span> + port;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务B-服务消费者</p><p>使用<code>@LoadBalanced</code>注解启用Ribbon</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ServiceBApplication.class, args);</span><br><span class="line">        log.info(<span class="string">"ServiceB 启动成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/greeting/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">greeting</span><span class="params">(@PathVariable(<span class="string">"name"</span>)</span> String name) </span>&#123;</span><br><span class="line">        String response = restTemplate.getForObject(<span class="string">"http://serviceA/sayHello/"</span> + name, String.class);</span><br><span class="line">        log.info(response);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、开始实验"><a href="#2、开始实验" class="headerlink" title="2、开始实验"></a>2、开始实验</h2><ul><li>分别用8081、8082两个端口启动服务A</li><li>用9000端口启动服务B</li><li>启动eureka集群</li><li>打开浏览器，访问<code>http://localhost:9000/greeting/sam</code>多次刷新</li></ul><p><img src="/2020/04/08/负载均衡：Ribbon入门/SpringCloudRibbon%E5%AE%9E%E9%AA%8C.png" alt="SpringCloudRibbon实验"></p><p>与我们快速体验Ribbon的效果一样，请求被均匀的打到各个实例上去了。</p><blockquote><p>此处不知你是否有疑问，为什么只是简单的加了一个注解，就可以用restTemplate访问不同的实例了呢？</p><p>不难猜测，肯定是从eureka那里获取到了服务注册表，然后ribbon拿着这些服务注册表，用自己的IRule组件选出一个server，然后就发送过去请求就可以了。</p><p>其实，ribbon的底层原理说白了，就是这些，我们此次源码分析的目的也是围绕这些点剖析一下就可以了，难度比eureka低不少。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们通过几个实验，了解到了ribbon的几个核心组件，ILoadBalancer负载均衡器，IRule负载均衡规则、IPing定时检测服务存活，以及回味了基于Spring Cloud Netflix Ribbon的简洁集成方式。下一步，跟随笔者进入Ribbon的源码世界吧！</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Ribbon解决了什么问题&quot;&gt;&lt;a href=&quot;#Ribbon解决了什么问题&quot; class=&quot;headerlink&quot; title=&quot;Ribbon解决了什么问题&quot;&gt;&lt;/a&gt;Ribbon解决了什么问题&lt;/h1&gt;&lt;p&gt;当集群中有了注册中心之后，服务消费者可以拿到所有服务的列表，此时就需要有一个组件能够将请求负载均衡到各个实例上去。ribbon就是这样一个客户端侧的负载均衡组件，同出Netflix，与其他组件整合后非常实用。&lt;/p&gt;
&lt;p&gt;Ribbon提供了多种不同的负载均衡算法实现，非常实用。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="Ribbon" scheme="http://houqian.github.io/tags/Ribbon/"/>
    
  </entry>
  
  <entry>
    <title>服务注册发现：Eureka源码剖析（13）Spring Cloud Eureka源码剖析</title>
    <link href="http://houqian.github.io/2020/03/28/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%8813%EF%BC%89Spring-Cloud-Eureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <id>http://houqian.github.io/2020/03/28/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%8813%EF%BC%89Spring-Cloud-Eureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</id>
    <published>2020-03-28T12:26:51.000Z</published>
    <updated>2021-06-05T15:24:17.204Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Spring Cloud Netflix Eureka对eureka原生项目做了一点儿轻量级的封装。</p><a id="more"></a><p>下面通过几个Spring Cloud Netflix Eureka的核心注解来分析</p><ul><li><p><code>@EnableEurekaClient</code> 在Spring cloud Netflix eureka-client工程里<br>这个注解会将当前spring boot应用作为eureka client进行启动。他的处理类是<code>EurekaClientAutoConfiguration</code></p><ul><li>EurekaClientConfigBean 这个是Spring自己实现EurekaClient接口搞的一个配置类，主要内容和原版Eureka的DefaultEurekaClientConfig作用是一样的，只不过提供了Spring方式的外部配置方式。</li><li>EurekaInstanceConfigBean 这个是Spring自己实现EurekaInstanceConfig接口搞的一个配置类，作用和原版差不多</li><li>EurekaServiceRegistry 是Spring自定义的服务注册中心，主要有注册、下线方法，这个类其实主要做心跳</li><li>EurekaAutoServiceRegistration 这个是Spring对原生Eureka 的一个优化，会在服务启动时马上执行服务注册（原版需要等待40秒）</li><li>CloudEurekaClient 继承了DiscoveryClient，主要是提供了一个onCacheRefreshed方法，这个拓展就是为了在EurekaClient拉取服务注册表时，更新一下Ribbon的ServerList。还有通过@Bean(destroyMethod = “shutdown”) 指定了Spring容器销毁时调用eureka client的服务下线方法进行下线</li><li>ApplicationInfoManager 服务信息管理器，原版组件，没啥好说的</li><li>EurekaRegistration 是ServiceInstance的子类，没啥特别的</li><li>EurekaHealthIndicator Spring自定义了Eureka的HealthIndicator，边缘代码，不用看了</li></ul></li><li><p><code>@EnableEurekaServer</code> 在Spring cloud Netflix eureka-server工程里</p><ul><li>EurekaController 这是Spring根据原生eureka控制台的Controller写的控制器，因为Spring重写了控制台，所以也配套搞了个Controller，没啥可说的</li><li>InstanceRegistry我们的老朋友，原生的PeerAwareInstanceRegistryImpl的子类，主要是扩展了当发生注册、下线等等这些东西时，发布对应的Spring事件，算是Spring老生常谈的扩展方式了</li><li>RefreshablePeerEurekaNodes 继承了原生的PeerEurekaNodes，主要是对接了Spring的配置体系，当涉及到eureka server地址列表的配置变更时，就可以联动PeerEurekaNodes，搞在线扩容缩容了。</li><li>DefaultEurekaServerContext 老朋友，原生的，代表一个eureka服务器的上下文，里面包含了所有的组件资源</li><li>EurekaServerBootstrap 这个是Spring把原生的同名类代码拷贝了过来，由于使用了Spring的@Bean装配，这个类的代码享受到了依赖注入的好处，清爽了不少，但功能没变。还是启动eureka server</li></ul></li></ul><p>可以看到，Spring对eureka的扩展主要是对接Spring，都是一些胶水代码，没啥可说的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Spring Cloud Netflix Eureka对eureka原生项目做了一点儿轻量级的封装。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Eureka" scheme="http://houqian.github.io/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>服务注册发现：Eureka源码剖析（12）核心机制源码剖析总结</title>
    <link href="http://houqian.github.io/2020/03/25/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%8812%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E6%80%BB%E7%BB%93/"/>
    <id>http://houqian.github.io/2020/03/25/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%8812%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E6%80%BB%E7%BB%93/</id>
    <published>2020-03-25T13:13:56.000Z</published>
    <updated>2021-06-05T15:24:21.053Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li>eureka 客户端会在启动时，从eureka server抓取全量注册表到本地</li></ul><a id="more"></a><ul><li><p>eureka server的维护了一个注册表多级缓存，所有外部对eureka server的注册表查询都会走这个缓存机制。这个二级缓存有30秒的同步间隔，也就意味着服务注册、下线、取消、状态变更，可能得等30秒才能生效</p></li><li><p>eureka client会每隔30秒，从eureka server抓取增量注册表，这个增量注册表也是放到注册表缓存里的</p></li><li><p>eureka client和eureka server之间通过心跳机制来完成健康检查</p></li><li><p>当eureka server发现最近1分钟内有低于85%的服务实例心跳成功，就会将自己置为自我保护模式。这个模式下，eureka server不会剔除过期服务实例。由于实现代码的问题，导致我么生产环境要么不用自我保护机制，要么就不能调整心跳时间间隔。</p></li><li><p>当eureka server不在自我保护模式时，会每隔1分钟，自动剔除最近3分钟内没有发送心跳的服务实例</p></li><li><p>eureka 集群节点之间是首次全量不同注册表，随后服务实例的变更是通过异步批量复制的，每当服务注册、下线、取消、状态变更时，会把这种动作通过三层队列机制，最终一次发送一批的方式同步到其他eureka 节点</p></li></ul><p><img src="/2020/03/25/服务注册发现：Eureka源码剖析（12）核心机制源码剖析总结/eureka%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93-(3).png" alt="eureka核心机制总结 (3)"></p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;eureka 客户端会在启动时，从eureka server抓取全量注册表到本地&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Eureka" scheme="http://houqian.github.io/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>服务注册发现：Eureka源码剖析（11）核心机制之Eureka Server集群机制</title>
    <link href="http://houqian.github.io/2020/03/18/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%8811%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8BEurekaServer%E9%9B%86%E7%BE%A4%E6%9C%BA%E5%88%B6/"/>
    <id>http://houqian.github.io/2020/03/18/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%8811%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8BEurekaServer%E9%9B%86%E7%BE%A4%E6%9C%BA%E5%88%B6/</id>
    <published>2020-03-18T11:22:56.000Z</published>
    <updated>2021-06-05T15:24:24.794Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li>什么是eureka集群？<br>一组互相复制数据，完全对等的eureka节点。通过配置文件指定，也可以热刷新（扩容缩容）</li></ul><a id="more"></a><ul><li><p>集群机制的实现？</p><p>在eureka server启动的时候，初始化服务器上下文阶段，会启动eureka集群信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class: DefaultEurekaServerContext</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="string">"Initializing ..."</span>);</span><br><span class="line">    <span class="comment">// 启动eureka集群，这个集群是每个eureka server节点都维护的一组内存对象。</span></span><br><span class="line">    <span class="comment">// 他的作用是每当本节点发生变更，比如有服务实例注册、下线、心跳续约等事件发生时，会修改这组对象</span></span><br><span class="line">    <span class="comment">// 然后这组对象负责将修改同步到对应的eureka server节点上去。</span></span><br><span class="line">    peerEurekaNodes.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化服务注册表</span></span><br><span class="line">        <span class="comment">// 这里其实是将所有的eureka server节点上的注册表都抓取过来，合并一下</span></span><br><span class="line">        <span class="comment">// 然后存放到自己的本地注册表中去</span></span><br><span class="line">        registry.init(peerEurekaNodes);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    logger.info(<span class="string">"Initialized"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启动eureka集群，这个集群是每个eureka server节点都维护的一组内存对象。</li><li>他的作用是每当本节点发生变更，比如有服务实例注册、下线、心跳续约等事件发生时，会修改这组对象</li><li>然后这组对象负责将修改同步到对应的eureka server节点上去。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class: PeerEurekaNodes</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 搞了一个单线程的线程池 用来跑eureka集群节点的更新任务</span></span><br><span class="line">    taskExecutor = Executors.newSingleThreadScheduledExecutor(</span><br><span class="line">        <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                Thread thread = <span class="keyword">new</span> Thread(r, <span class="string">"Eureka-PeerNodesUpdater"</span>);</span><br><span class="line">                thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">return</span> thread;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这里是更新自己内存中的eureka集群，</span></span><br><span class="line">        <span class="comment">// 对新的eureka节点进行创建实例，然后添加到集群进去</span></span><br><span class="line">        <span class="comment">// 对已经无效的eureka 节点清除出这个集群中</span></span><br><span class="line">        <span class="comment">// 这里被Spring Cloud Netflix Eureka拿来做eureka集群的在线扩缩容</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新eureka server集群信息</span></span><br><span class="line">        updatePeerEurekaNodes(resolvePeerUrls());</span><br><span class="line">        Runnable peersUpdateTask = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    updatePeerEurekaNodes(resolvePeerUrls());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    logger.error(<span class="string">"Cannot update the replica Nodes"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        taskExecutor.scheduleWithFixedDelay(</span><br><span class="line">            peersUpdateTask,</span><br><span class="line">            serverConfig.getPeerEurekaNodesUpdateIntervalMs(),</span><br><span class="line">            serverConfig.getPeerEurekaNodesUpdateIntervalMs(),</span><br><span class="line">            TimeUnit.MILLISECONDS</span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (PeerEurekaNode node : peerEurekaNodes) &#123;</span><br><span class="line">        logger.info(<span class="string">"Replica node URL:  &#123;&#125;"</span>, node.getServiceUrl());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建一个线程池</li><li>解析配置文件中配置的eureka server地址列表</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class: PeerEurekaNodes</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">updatePeerEurekaNodes</span><span class="params">(List&lt;String&gt; newPeerUrls)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里toShutdown就是需要缩容的eureka server节点</span></span><br><span class="line">    <span class="comment">// 实现很简单，就是以最新的服务地址列表为准，除此之外的都需要干掉</span></span><br><span class="line">    Set&lt;String&gt; toShutdown = <span class="keyword">new</span> HashSet&lt;&gt;(peerEurekaNodeUrls);</span><br><span class="line">    toShutdown.removeAll(newPeerUrls);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里toAdd就是需要扩容的eureka server节点</span></span><br><span class="line">    <span class="comment">// 实现很简单，就是拿新增的服务地址列表</span></span><br><span class="line">    Set&lt;String&gt; toAdd = <span class="keyword">new</span> HashSet&lt;&gt;(newPeerUrls);</span><br><span class="line">    toAdd.removeAll(peerEurekaNodeUrls);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove peers no long available</span></span><br><span class="line">    List&lt;PeerEurekaNode&gt; newNodeList = <span class="keyword">new</span> ArrayList&lt;&gt;(peerEurekaNodes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里处理缩容的逻辑</span></span><br><span class="line">    <span class="comment">// 遍历现在的集群里的节点，删除缩容的节点，并且关停缩容的节点</span></span><br><span class="line">    <span class="comment">// 关停缩容的节点 其实没啥特别的 就是释放一些线程池资源而已</span></span><br><span class="line">    <span class="keyword">if</span> (!toShutdown.isEmpty()) &#123;</span><br><span class="line">        logger.info(<span class="string">"Removing no longer available peer nodes &#123;&#125;"</span>, toShutdown);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; newNodeList.size()) &#123;</span><br><span class="line">            PeerEurekaNode eurekaNode = newNodeList.get(i);</span><br><span class="line">            <span class="keyword">if</span> (toShutdown.contains(eurekaNode.getServiceUrl())) &#123;</span><br><span class="line">                newNodeList.remove(i);</span><br><span class="line">                eurekaNode.shutDown();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里处理扩容的逻辑</span></span><br><span class="line">    <span class="comment">// 遍历需要扩容的节点，创建之，加入集群</span></span><br><span class="line">    <span class="comment">// Add new peers</span></span><br><span class="line">    <span class="keyword">if</span> (!toAdd.isEmpty()) &#123;</span><br><span class="line">        logger.info(<span class="string">"Adding new peer nodes &#123;&#125;"</span>, toAdd);</span><br><span class="line">        <span class="keyword">for</span> (String peerUrl : toAdd) &#123;</span><br><span class="line">            newNodeList.add(createPeerEurekaNode(peerUrl));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.peerEurekaNodes = newNodeList;</span><br><span class="line">    <span class="keyword">this</span>.peerEurekaNodeUrls = <span class="keyword">new</span> HashSet&lt;&gt;(newPeerUrls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>集群的扩容和缩容</p><p>扩容</p><ul><li>根据最新的eureka server地址列表</li><li>与老的服务列表做比对，算出新增的服务地址，这里就是需要扩容的节点</li><li>创建节点，加入集群</li></ul><p>缩容</p><ul><li>根据最新的eureka server地址列表</li><li>与老的服务列表做比对，算出待删除的服务地址，这里就是需要缩容的节点</li><li>从集群中剔除节点，释放节点的线程池资源</li></ul></blockquote></li><li><p>集群同步机制怎么实现的？</p><p>每当服务注册、下线、取消、状态变更时，都会执行PeerAwareInstanceRegistryImpl的replicateToPeers的方法，这个方法会将这些动作同步到内存集群的队列中，然后有定时任务，会分派这些动作，将这些动作打成一批批的包，分批请求对应的eureka server。</p><p>在内存集群中，复制任务的接收、分派、消费这套流程采用了三层队列来实现，下面我们分析一下这个机制</p><ul><li><p>每个内存集群中的节点都有两个任务分派器TaskDispatcher</p></li><li><p>每个TaskDispatcher有两个执行器组成</p><ul><li>一个acceptorExecutor，负责接收任务<ul><li>如果重新处理队列、接收队列、待处理任务任意一个不为空，就执行如下逻辑；否则就睡10秒钟<ul><li>任务先进接收队列（acceptorQueue） </li><li>有个叫AcceptorRunner的后台线程不断的消费接收队列<ul><li>不断拉取重新处理队列（reprocessQueue）<ul><li>如果不为空，将里面的任务放到待执行任务（pendingTasks）中去； 插入处理顺序队列（processingOrder）</li><li>如果满了，累加重新处理队列已经清除的任务个数；清空重新处理队列</li></ul></li><li>不断拉取接收队列<ul><li>如果待执行任务满了，处理顺序队列里删除这个任务</li><li>如果没满，就放入待执行任务中去</li><li>如果刚才放入待执行任务中的那个任务是新任务，就将这个任务加入处理顺序队列中去</li></ul></li></ul></li></ul></li><li>分派批处理任务<ul><li>积攒到一批或者待执行任务中最老的任务已经延时超过500毫秒，就将待执行任务任务打成一批，放到批处理任务工作队列里</li></ul></li><li>分派单项处理任务</li></ul></li><li>一个taskExecutor，负责执行任务<ul><li>这里会从批处理任务队列里，一批批的消费，将一批任务一次请求发送到对应的eureka server节点</li></ul></li></ul></li><li><p>总结</p><p><img src="/2020/03/18/服务注册发现：Eureka源码剖析（11）核心机制之EurekaServer集群机制/eureka-server%E5%90%8C%E6%AD%A5%E4%BB%BB%E5%8A%A1%E6%89%B9%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6(1).png" alt="eureka server同步任务批处理机制(1)"></p></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;什么是eureka集群？&lt;br&gt;一组互相复制数据，完全对等的eureka节点。通过配置文件指定，也可以热刷新（扩容缩容）&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Eureka" scheme="http://houqian.github.io/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>服务注册发现：Eureka源码剖析（10）核心机制之Eureka Server网络故障时的自我保护机制</title>
    <link href="http://houqian.github.io/2020/03/09/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%8810%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8BEureka-Server%E7%BD%91%E7%BB%9C%E6%95%85%E9%9A%9C%E6%97%B6%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"/>
    <id>http://houqian.github.io/2020/03/09/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%8810%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8BEureka-Server%E7%BD%91%E7%BB%9C%E6%95%85%E9%9A%9C%E6%97%B6%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</id>
    <published>2020-03-09T11:19:15.000Z</published>
    <updated>2021-06-05T15:24:29.588Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li>自我保护机制是什么？<br>在eureka server中，他假定正常情况下肯定有大于85%的服务实例能够保持正常的心跳，最近1分钟内少于85%的服务实例心跳成功，eureka开发团队认为，此时大概率是eureka server自己的网络故障了，此时再进行过期实例剔除都会是误伤，于是就不再对故障实例剔除。这就叫进入了自我保护机制。</li></ul><a id="more"></a><ul><li><p>自我保护的实现原理</p><p>eureka自我保护机制的代码实现比较零散，逻辑分散的各处，需要仔细翻阅源码才能找到，笔者也是花了几个小时（一个开源项目里的代码质量还真是参差不齐。。。）</p><ul><li><p>在上篇文章讲解的自动摘除服务实例的实现方法evit中，在最开始进行了当前是否进入自我保护状态的判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeaseExpirationEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!isSelfPreservationModeEnabled()) &#123;</span><br><span class="line">           <span class="comment">// The self preservation mode is disabled, hence allowing the instances to expire.</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">       <span class="comment">// 如果开启自我保护机制 就会走下面的逻辑</span></span><br><span class="line">    </span><br><span class="line">       <span class="comment">// numberOfRenewsPerMinThreshold = 服务实例数量 * 2 * 0.85 期望值，最少有85%的实例发送心跳 心跳30秒1次，于是就 *2</span></span><br><span class="line">    </span><br><span class="line">       <span class="comment">// getNumOfRenewsInLastMin() 返回的就是 最近1分钟实际心跳成功的服务实例数</span></span><br><span class="line">       <span class="comment">// 是通过 MeasuredRate 组件 + renew时触发来实现的</span></span><br><span class="line">    </span><br><span class="line">       <span class="comment">// 这个判断的意思也就明了了，最近1分钟实际心跳成功的服务实例数 &gt; 要大于85% ，这个时候才会允许处理过期服务实例</span></span><br><span class="line">    </span><br><span class="line">       <span class="comment">// 为啥这么做？</span></span><br><span class="line">       <span class="comment">// 这也就是eureka所谓的自我保护机制的实现了。他假定正常情况下肯定会有超过85%的服务实例能够心跳成功成功的</span></span><br><span class="line">       <span class="comment">// 如果小于85%，那么就有可能是eureka server自己的网络出现故障了，此时就不能再剔除过期实例了，因为可能是误伤</span></span><br><span class="line">       <span class="comment">// 这种状态下不剔除服务实例，这个操作，就是进入自我保护模式这个动作，达到了自我保护这个状态和效果，此时eureka控制台里也会显示出那行红字</span></span><br><span class="line">    </span><br><span class="line">       <span class="comment">// 为什么测试环境非常容易触发自我保护机制呢？</span></span><br><span class="line">       <span class="comment">// 测试环境频繁的有服务实例注册、销毁，生命周期非常的短，可能连第二次心跳都没进行，这就导致最近一分钟内的服务实例心跳成功数大大降低</span></span><br><span class="line">       <span class="comment">// 非常有可能低于85%，一旦低于85%就会进入自我保护模式。</span></span><br><span class="line">       <span class="comment">// 测试环境这种情况是持续存在的，所以就会显示出eureka持续进入自我保护模式了</span></span><br><span class="line">    </span><br><span class="line">       <span class="comment">// 这个方法 返回true，说明正常；返回false，就是进入了自我保护模式了</span></span><br><span class="line">       <span class="comment">// 这点儿注意，与Spring cloud netflix eureka的实现方式相同，但返回值的含义是相反的</span></span><br><span class="line">       <span class="keyword">return</span> numberOfRenewsPerMinThreshold &gt; <span class="number">0</span> &amp;&amp; getNumOfRenewsInLastMin() &gt; numberOfRenewsPerMinThreshold;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li><p>numberOfRenewsPerMinThreshold 服务实例数量 * 2 * 0.85 期望值，最少有85%的实例发送心跳 心跳30秒1次，于是就 *2</p></li><li><p>getNumOfRenewsInLastMin()  返回的就是 最近1分钟实际心跳成功的服务实例数<br>是通过 MeasuredRate 组件 + renew时触发来实现的<br>也就是每次心跳成功都会对MeasuredRate 内的数值加1，而每隔1分钟，MeasuredRate 组件会把自己的数值清零</p></li><li><p>如果 getNumOfRenewsInLastMin() &gt; numberOfRenewsPerMinThreshold，也就是最近1分钟，少于85%的服务实例心跳成功，就意味着进入了自我保护状态了</p><blockquote><p>这个方法 返回true，说明正常；返回false，就是进入了自我保护模式了</p><p>注意，与Spring cloud netflix eureka的实现方式相同，但返回值的含义是相反的</p></blockquote></li></ul></li></ul></li><li><p>为什么测试环境非常容易触发自我保护机制呢？<br>测试环境频繁的有服务实例注册、销毁，生命周期非常的短，可能连第二次心跳都没进行，这就导致最近一分钟内的服务实例心跳成功数大大降低，非常有可能低于85%，一旦低于85%就会进入自我保护模式。 测试环境这种情况是持续存在的，所以就会显示出eureka持续进入自我保护模式了</p></li></ul><blockquote><p>注意</p><p>自我保护机制的实现，采用了硬编码的方式强制指定了30秒的心跳周期，所以在实际生产中，我们要么不用这个自我保护模式，要么就不要修改心跳间隔，否则逻辑就错乱了</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/2020/03/09/服务注册发现：Eureka源码剖析（10）核心机制之Eureka-Server网络故障时的自我保护机制/eureka%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6.png" alt="eureka自我保护机制"></p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;自我保护机制是什么？&lt;br&gt;在eureka server中，他假定正常情况下肯定有大于85%的服务实例能够保持正常的心跳，最近1分钟内少于85%的服务实例心跳成功，eureka开发团队认为，此时大概率是eureka server自己的网络故障了，此时再进行过期实例剔除都会是误伤，于是就不再对故障实例剔除。这就叫进入了自我保护机制。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Eureka" scheme="http://houqian.github.io/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>服务注册发现：Eureka源码剖析（9）核心机制之服务实例的自动故障感知及自动摘除机制</title>
    <link href="http://houqian.github.io/2020/03/03/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%889%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8B%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B%E7%9A%84%E8%87%AA%E5%8A%A8%E6%95%85%E9%9A%9C%E6%84%9F%E7%9F%A5%E5%8F%8A%E8%87%AA%E5%8A%A8%E6%91%98%E9%99%A4%E6%9C%BA%E5%88%B6/"/>
    <id>http://houqian.github.io/2020/03/03/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%889%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8B%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B%E7%9A%84%E8%87%AA%E5%8A%A8%E6%95%85%E9%9A%9C%E6%84%9F%E7%9F%A5%E5%8F%8A%E8%87%AA%E5%8A%A8%E6%91%98%E9%99%A4%E6%9C%BA%E5%88%B6/</id>
    <published>2020-03-03T11:26:18.000Z</published>
    <updated>2021-06-05T15:24:32.945Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li>故障感知和摘除指的是什么？<br>正常下线，会通过eureka client的shutdown方法进行，走下线流程。<br>当因为一些原因，没有通过正常下线的方式，服务实例却下线了，这种异常情况，成为故障。<br>感知，eureka server会通过定时检查多久没心跳了，感知到这种故障服务实例，并自动从注册表中把这个服务实例摘除。</li></ul><a id="more"></a><ul><li><p>eureka的自动故障感知和自动摘除机制</p><p>在eureka server启动的最后一步，openForTraffic中，最后一步super.postInit()方法里，启动了一个定时过期任务evictionTask</p><ul><li>定时过期任务延迟1分钟开始执行，然后每间隔1分钟执行一次</li><li>该任务会遍历本地注册表里，所有超过3分钟没有心跳的服务实例，将这些服务实例收集起来，这一步算是完成了<strong>自动感知机制</strong></li><li>默认情况下，一次性最多只会过期15%的服务实例</li><li>每个服务实例的剔除，是从收集到的过期服务实例列表里<strong>随机</strong>选择的，最多选择15%个</li><li>接着正式执行每个服务实例的剔除操作<ul><li>从本地注册表里摘除这个故障实例（这一步算是完成了<strong>自动摘除机制</strong>了）</li><li>将这个实例放到最近下线队列里</li><li>从overriddenInstanceStatusMap中移除</li><li>将这个实例放到最近变更队列里</li><li>失效响应缓存（就是那个注册表多级缓存）</li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;故障感知和摘除指的是什么？&lt;br&gt;正常下线，会通过eureka client的shutdown方法进行，走下线流程。&lt;br&gt;当因为一些原因，没有通过正常下线的方式，服务实例却下线了，这种异常情况，成为故障。&lt;br&gt;感知，eureka server会通过定时检查多久没心跳了，感知到这种故障服务实例，并自动从注册表中把这个服务实例摘除。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Eureka" scheme="http://houqian.github.io/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>服务注册发现：Eureka源码剖析（8）核心机制之服务下线与实例摘除</title>
    <link href="http://houqian.github.io/2020/02/25/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%888%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8B%E6%9C%8D%E5%8A%A1%E4%B8%8B%E7%BA%BF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E6%91%98%E9%99%A4/"/>
    <id>http://houqian.github.io/2020/02/25/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%888%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8B%E6%9C%8D%E5%8A%A1%E4%B8%8B%E7%BA%BF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E6%91%98%E9%99%A4/</id>
    <published>2020-02-25T11:11:11.000Z</published>
    <updated>2021-06-05T15:24:36.144Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li>当调用eureka client的shutdown方法时，会走服务下线流程。（这个shutdown方法会在Spring Cloud Netflix中spring上下文关闭时调用）<ul><li>触发下线监听器</li><li>停止调度任务（心跳、拉取注册表）</li><li>调用eureka server的 DELETA /v2/apps/APP_NAME/服务实例ID 接口</li><li>释放一系列jersey client的网络资源</li><li>注销监控<ul><li>心跳监控</li><li>注册表监控</li></ul></li></ul></li></ul><a id="more"></a><ul><li>eureka server的InstanceResource的cancelLease方法接收请求<ul><li>本节点下线<ul><li>把下线的服务实例放入最近下线队列里</li><li>从overriddenInstanceStatusMap中删除这个服务实例</li><li>把下线的服务实例放入最近变更队列里</li><li>失效响应缓存（那个注册表多级缓存）</li></ul></li><li>复制服务实例下线到集群</li></ul></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/2020/02/25/服务注册发现：Eureka源码剖析（8）核心机制之服务下线与实例摘除/%E6%9C%8D%E5%8A%A1%E4%B8%8B%E7%BA%BF%E7%9A%84%E9%80%BB%E8%BE%91(1).png" alt="服务下线的逻辑(1)"></p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;当调用eureka client的shutdown方法时，会走服务下线流程。（这个shutdown方法会在Spring Cloud Netflix中spring上下文关闭时调用）&lt;ul&gt;
&lt;li&gt;触发下线监听器&lt;/li&gt;
&lt;li&gt;停止调度任务（心跳、拉取注册表）&lt;/li&gt;
&lt;li&gt;调用eureka server的 DELETA /v2/apps/APP_NAME/服务实例ID 接口&lt;/li&gt;
&lt;li&gt;释放一系列jersey client的网络资源&lt;/li&gt;
&lt;li&gt;注销监控&lt;ul&gt;
&lt;li&gt;心跳监控&lt;/li&gt;
&lt;li&gt;注册表监控&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Eureka" scheme="http://houqian.github.io/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>服务注册发现：Eureka源码剖析（7）核心机制之Eureka Clien与Eureka Server之间的心跳机制</title>
    <link href="http://houqian.github.io/2020/02/18/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%887%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8BEureka-Clien%E4%B8%8EEureka-Server%E4%B9%8B%E9%97%B4%E7%9A%84%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6/"/>
    <id>http://houqian.github.io/2020/02/18/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%887%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8BEureka-Clien%E4%B8%8EEureka-Server%E4%B9%8B%E9%97%B4%E7%9A%84%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6/</id>
    <published>2020-02-18T11:30:11.000Z</published>
    <updated>2021-06-05T15:24:38.765Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li>当eureka client启动时，会有一个定时任务每隔30秒向eureka server发送心跳<ul><li>心跳会将服务实例信息带上</li><li>请求的eureka server的  PUT /v2/apps/APP_NAME/服务实例ID</li><li>根据响应做如下处理<ul><li>如果返回状态码为404<br>说明eureka server没有这个服务实例，此时会走服务注册流程</li><li>如果返回状态码200，说明心跳成功了，会更新本地的最近一次成功心跳时间戳</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;ul&gt;
&lt;li&gt;当eureka client启动时，会有一个定时任务每隔30秒向</summary>
      
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Eureka" scheme="http://houqian.github.io/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>服务注册发现：Eureka源码剖析（6）核心机制之Eureka Client间隔30s增量抓取</title>
    <link href="http://houqian.github.io/2020/02/16/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%886%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8BEureka-Client%E9%97%B4%E9%9A%9430s%E5%A2%9E%E9%87%8F%E6%8A%93%E5%8F%96/"/>
    <id>http://houqian.github.io/2020/02/16/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%886%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8BEureka-Client%E9%97%B4%E9%9A%9430s%E5%A2%9E%E9%87%8F%E6%8A%93%E5%8F%96/</id>
    <published>2020-02-16T14:10:13.000Z</published>
    <updated>2021-06-05T15:24:41.755Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li><p>eureka client启动后，每隔30秒会有一个定时任务抓取增量注册表</p><ul><li>请求的eureka server的 GET v2/apps/delta 接口</li><li>会根据返回的服务实例的类型，比如新增、修改、删除来分别处理<ul><li>新增、修改  直接添加到本地注册表（添加操作实际上是幂等的，会先删除，再添加）</li><li>删除  直接从本地注册表删除</li></ul></li></ul></li></ul><a id="more"></a><ul><li><p>eureka server的ApplicationsResource.getContainerDifferential方法会收到客户端的增量抓取请求</p><ul><li>从响应缓存中 以ALL_APPS_DELTA为key获取数据，返回给客户端</li></ul></li><li><p>eureka server中的ALL_APPS_DELTA的数据是从哪里来的呢？</p><p>从recentChangedQueue中获取的</p></li><li><p>recentChangedQueue是什么？</p><ul><li>最近变更的服务实例队列，默认存储最近3分钟的。其有一个定时任务每隔30秒检查一次队列，将3分钟以前的服务实例从队列里删除</li><li>数据来源<br>每当服务实例注册、下线、取消、变更时，都会将服务实例写到最近变更队列中去</li></ul></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/2020/02/16/服务注册发现：Eureka源码剖析（6）核心机制之Eureka-Client间隔30s增量抓取/eureka-client%E5%A2%9E%E9%87%8F%E6%8A%93%E5%8F%96%E6%B3%A8%E5%86%8C%E8%A1%A8.png" alt="eureka client增量抓取注册表"></p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;eureka client启动后，每隔30秒会有一个定时任务抓取增量注册表&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请求的eureka server的 GET v2/apps/delta 接口&lt;/li&gt;
&lt;li&gt;会根据返回的服务实例的类型，比如新增、修改、删除来分别处理&lt;ul&gt;
&lt;li&gt;新增、修改  直接添加到本地注册表（添加操作实际上是幂等的，会先删除，再添加）&lt;/li&gt;
&lt;li&gt;删除  直接从本地注册表删除&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Eureka" scheme="http://houqian.github.io/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>服务注册发现：Eureka源码剖析（5）核心机制之Eureka Server的注册表多级缓存</title>
    <link href="http://houqian.github.io/2020/02/08/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%885%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8BEureka-Server%E7%9A%84%E6%B3%A8%E5%86%8C%E8%A1%A8%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/"/>
    <id>http://houqian.github.io/2020/02/08/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%885%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8BEureka-Server%E7%9A%84%E6%B3%A8%E5%86%8C%E8%A1%A8%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/</id>
    <published>2020-02-08T11:20:19.000Z</published>
    <updated>2021-06-05T15:24:45.077Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>注册表多级缓存（就是那个ResponseCache）的原理如下：</p><ul><li>第一级缓存 readOnlyCacheMap，所有的读请求都会先走这一层</li><li>第二级缓存是一个基于Guava Cache的 readWriteCacheMap 当第一层获取不到数据时，会走这一层<ul><li>数据加载 将自己的本地注册表数据以key为ALL_APPS填充到第二级缓存中去</li></ul></li></ul><a id="more"></a><ul><li>缓存失效时机<ul><li>二级缓存失效时机<ul><li>当服务注册、服务下线、服务状态变更、服务剔除时会触发缓存失效</li></ul></li><li>默认的写入二级缓存的数据 180秒后会过期</li></ul></li><li>缓存同步<ul><li>有一个定时任务，每隔30秒，比对一二级缓存的数据，如果不一致，就用二级缓存的数据覆盖一级缓存的，回写到一级缓存中去</li></ul></li></ul><blockquote><p>问题</p><p>由于缓存同步有30秒的间隔，因此最差情况下，我们得到最新注册表需要30秒。</p><p>也就意味着，当有服务注册、下线、故障时，可能得30秒后才能感知到。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/2020/02/08/服务注册发现：Eureka源码剖析（5）核心机制之Eureka-Server的注册表多级缓存/eureka-server%E7%9A%84%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%E8%BF%87%E6%9C%9F%E6%9C%BA%E5%88%B6.png" alt="eureka-server的多级缓存过期机制"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;注册表多级缓存（就是那个ResponseCache）的原理如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一级缓存 readOnlyCacheMap，所有的读请求都会先走这一层&lt;/li&gt;
&lt;li&gt;第二级缓存是一个基于Guava Cache的 readWriteCacheMap 当第一层获取不到数据时，会走这一层&lt;ul&gt;
&lt;li&gt;数据加载 将自己的本地注册表数据以key为ALL_APPS填充到第二级缓存中去&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Eureka" scheme="http://houqian.github.io/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>服务注册发现：Eureka源码剖析（4）核心机制之Eureka Client首次启动抓取全量注册表</title>
    <link href="http://houqian.github.io/2020/02/03/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%884%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8BEureka-Client%E9%A6%96%E6%AC%A1%E5%90%AF%E5%8A%A8%E6%8A%93%E5%8F%96%E5%85%A8%E9%87%8F%E6%B3%A8%E5%86%8C%E8%A1%A8/"/>
    <id>http://houqian.github.io/2020/02/03/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%884%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8BEureka-Client%E9%A6%96%E6%AC%A1%E5%90%AF%E5%8A%A8%E6%8A%93%E5%8F%96%E5%85%A8%E9%87%8F%E6%B3%A8%E5%86%8C%E8%A1%A8/</id>
    <published>2020-02-03T11:10:11.000Z</published>
    <updated>2021-06-05T15:24:47.833Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li>Eureka Client首次抓取是在启动时进行的</li><li>通过eurekaTransport.queryClient这个jersey客户端,请求eureka server的 GET /v2/apps/APP_NAME 接口</li><li>拿到响应的Applications后会将顺序打乱，然后存到本地</li></ul><hr><ul><li><p>eureka server的ApplicationsResource.getContainers方法会收到请求</p></li><li><p>从响应缓存中把key为ALL_APPS的数据数据返回给客户端</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;ul&gt;
&lt;li&gt;Eureka Client首次抓取是在启动时进行的&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Eureka" scheme="http://houqian.github.io/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>服务注册发现：Eureka源码剖析（3）服务注册</title>
    <link href="http://houqian.github.io/2019/12/13/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%883%EF%BC%89%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/"/>
    <id>http://houqian.github.io/2019/12/13/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%883%EF%BC%89%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/</id>
    <published>2019-12-13T11:30:22.000Z</published>
    <updated>2021-06-05T15:24:51.946Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Eureka-Client启动流程"><a href="#Eureka-Client启动流程" class="headerlink" title="Eureka Client启动流程"></a>Eureka Client启动流程</h1><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleEurekaClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        ExampleEurekaClient sampleClient = <span class="keyword">new</span> ExampleEurekaClient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个new MyDataCenterInstanceConfig()，其实主要就是读取eureka-client.properties，然后构建一个服务实例配置</span></span><br><span class="line">        ApplicationInfoManager applicationInfoManager = initializeApplicationInfoManager(<span class="keyword">new</span> MyDataCenterInstanceConfig());</span><br><span class="line">        <span class="comment">// 这个new DefaultEurekaClient(),其实就是读取eureka-client.properties构造一个eureka客户端配置</span></span><br><span class="line">        <span class="comment">// 基于接口对外提供eureka-client的配置读取</span></span><br><span class="line">        EurekaClient client = initializeEurekaClient(applicationInfoManager, <span class="keyword">new</span> DefaultEurekaClientConfig());</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 用eureka客户端向eureka server发送请求</span></span><br><span class="line">        sampleClient.sendRequestToServiceUsingEureka(client);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 关闭eureka客户端</span></span><br><span class="line">        eurekaClient.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 这里就是根据服务实例配置，初始化服务信息管理器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> ApplicationInfoManager <span class="title">initializeApplicationInfoManager</span><span class="params">(EurekaInstanceConfig instanceConfig)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (applicationInfoManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 1. 根据服务实例配置，构造一个服务实例</span></span><br><span class="line">            InstanceInfo instanceInfo = <span class="keyword">new</span> EurekaConfigBasedInstanceInfoProvider(instanceConfig).get();</span><br><span class="line">            <span class="comment">// 2. 根据服务实例和配置，构造一个应用信息管理器</span></span><br><span class="line">            applicationInfoManager = <span class="keyword">new</span> ApplicationInfoManager(instanceConfig, instanceInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> applicationInfoManager;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 根据应用信息管理器和eureka-client配置，构造出EurekaClient</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> EurekaClient <span class="title">initializeEurekaClient</span><span class="params">(ApplicationInfoManager applicationInfoManager, EurekaClientConfig clientConfig)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (eurekaClient == <span class="keyword">null</span>) &#123;</span><br><span class="line">            eurekaClient = <span class="keyword">new</span> DiscoveryClient(applicationInfoManager, clientConfig);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> eurekaClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这部分已经在上篇文章剖析过了，这里直接出总结</p><p><img src="/2019/12/13/服务注册发现：Eureka源码剖析（3）服务注册/03-eureka-client%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.jpg" alt="03-eureka client启动流程"></p><h1 id="Eureka-Client是如何进行服务注册的"><a href="#Eureka-Client是如何进行服务注册的" class="headerlink" title="Eureka Client是如何进行服务注册的"></a>Eureka Client是如何进行服务注册的</h1><ul><li>在eureka-client实例化的最后一步，启动了一个实例信息复制器，默认40秒之后开始执行，这个定时任务逻辑如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> initialDelayMs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (started.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        <span class="comment">// 先将代表自己的这个服务实例状态设置为dirty</span></span><br><span class="line">        <span class="comment">// 其实，标记为dirty就是为了在下一次服务心跳时将实例信息发给eureka server</span></span><br><span class="line">        instanceInfo.setIsDirty();  <span class="comment">// for initial register</span></span><br><span class="line">        Future next = scheduler.schedule(<span class="keyword">this</span>, initialDelayMs, TimeUnit.SECONDS);</span><br><span class="line">        scheduledPeriodicRef.set(next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 先刷新一下实例信息</span></span><br><span class="line">        discoveryClient.refreshInstanceInfo();</span><br><span class="line"></span><br><span class="line">        Long dirtyTimestamp = instanceInfo.isDirtyWithTime();</span><br><span class="line">        <span class="keyword">if</span> (dirtyTimestamp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里才是真正的服务注册</span></span><br><span class="line">            <span class="comment">// 这里其实就是调用网络通信组件的服务注册客户端向eureka server的POST /apps 接口发起服务注册</span></span><br><span class="line">            discoveryClient.register();</span><br><span class="line">            <span class="comment">// 注册完成了，就不需要在心跳里发送这个服务实例了</span></span><br><span class="line">            instanceInfo.unsetIsDirty(dirtyTimestamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.warn(<span class="string">"There was a problem with the instance info replicator"</span>, t);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 这个replicationIntervalSeconds 默认是40秒</span></span><br><span class="line">        <span class="comment">// 也就是说eureka client启动时，延迟40秒才进行服务注册，这点儿非常坑，在Spring Cloud Netflix中已被修复（马上注册）</span></span><br><span class="line">        Future next = scheduler.schedule(<span class="keyword">this</span>, replicationIntervalSeconds, TimeUnit.SECONDS);</span><br><span class="line">        scheduledPeriodicRef.set(next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Eureka-Server是如何完成服务注册的"><a href="#Eureka-Server是如何完成服务注册的" class="headerlink" title="Eureka Server是如何完成服务注册的"></a>Eureka Server是如何完成服务注册的</h1><ul><li>上一步客户端发起服务注册后，ApplicationResource#addInstance 会接收到请求，最终将请求转给PeerAwareInstanceRegistry.register</li><li>进行注册<ul><li>将请求送上来的实例信息放到自己的服务注册表中<code>ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt; registry</code></li><li>将服务实例放到最近注册队列（recentRegisteredQueue）中去</li><li>将服务实例放到最近变更队列（recentlyChangedQueue）中去</li><li>过期ResponseCache</li></ul></li><li>同步注册到其他节点</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/2019/12/13/服务注册发现：Eureka源码剖析（3）服务注册/eureka%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E7%9A%84%E6%B5%81%E7%A8%8B.png" alt="eureka的服务注册的流程"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Eureka-Client启动流程&quot;&gt;&lt;a href=&quot;#Eureka-Client启动流程&quot; class=&quot;headerlink&quot; title=&quot;Eureka Client启动流程&quot;&gt;&lt;/a&gt;Eureka Client启动流程&lt;/h1&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Eureka" scheme="http://houqian.github.io/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>服务注册发现：Eureka源码剖析（2）Eureka Server启动</title>
    <link href="http://houqian.github.io/2019/12/09/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%882%EF%BC%89Eureka-Server%E5%90%AF%E5%8A%A8/"/>
    <id>http://houqian.github.io/2019/12/09/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%882%EF%BC%89Eureka-Server%E5%90%AF%E5%8A%A8/</id>
    <published>2019-12-09T11:15:13.000Z</published>
    <updated>2021-06-05T15:24:55.071Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Eureka-Server模块分析"><a href="#Eureka-Server模块分析" class="headerlink" title="Eureka Server模块分析"></a>Eureka Server模块分析</h1><h2 id="1、Eureka-Server原来是一个简单的Servlet应用"><a href="#1、Eureka-Server原来是一个简单的Servlet应用" class="headerlink" title="1、Eureka Server原来是一个简单的Servlet应用"></a>1、Eureka Server原来是一个简单的Servlet应用</h2><a id="more"></a><p>Eureka Server模块非常简单，有价值的就一个web.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这个EurekaBootStrap 就是Eureka Server的入口代码，我们从这个类开始分析就对了 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.netflix.eureka.EurekaBootStrap<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>jersey<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.sun.jersey.spi.container.servlet.ServletContainer<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>com.sun.jersey.config.property.WebPageContentRegex<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/(flex|images|js|css|jsp)/.*<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>com.sun.jersey.config.property.packages<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.sun.jersey;com.netflix<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- GZIP content encoding/decoding --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>com.sun.jersey.spi.container.ContainerRequestFilters<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.sun.jersey.api.container.filter.GZIPContentEncodingFilter<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>com.sun.jersey.spi.container.ContainerResponseFilters<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.sun.jersey.api.container.filter.GZIPContentEncodingFilter<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>statusFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>requestAuthFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Uncomment this to enable rate limiter filter.</span></span><br><span class="line"><span class="comment">&lt;filter-mapping&gt;</span></span><br><span class="line"><span class="comment">  &lt;filter-name&gt;rateLimitingFilter&lt;/filter-name&gt;</span></span><br><span class="line"><span class="comment">  &lt;url-pattern&gt;/v2/apps&lt;/url-pattern&gt;</span></span><br><span class="line"><span class="comment">  &lt;url-pattern&gt;/v2/apps/*&lt;/url-pattern&gt;</span></span><br><span class="line"><span class="comment">&lt;/filter-mapping&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>gzipEncodingEnforcingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/v2/apps<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/v2/apps/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>jersey<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>jsp/status.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br></pre></td></tr></table></figure><p>看到这个，一下子回想起多年以前，我们打war包部署到Tomcat中发布应用的时候。可以看到web.xml定义了各种Listener、filter、filter-mapping，比如Listener就是在Servlet容器启动时跟随着初始化，做一些事情。原来，Eureka Server是用最传统的Servlet那种方式开发的一个简单web应用。<br>在test目录下，发现有一个<code>EurekaClientServerRestIntegrationTest</code>单元测试类，里面的<code>setUp()</code>方法验证了我们的猜想：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BeforeClass</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 注入一些Eureka配置数据（这是为了测试而mock的配置）</span></span><br><span class="line">    injectEurekaConfiguration();</span><br><span class="line">    <span class="comment">// 启动服务</span></span><br><span class="line">    startServer();</span><br><span class="line">    createEurekaServerConfig();</span><br><span class="line"></span><br><span class="line">    httpClientFactory = JerseyEurekaHttpClientFactory.newBuilder()</span><br><span class="line">            .withClientName(<span class="string">"testEurekaClient"</span>)</span><br><span class="line">            .withConnectionTimeout(<span class="number">1000</span>)</span><br><span class="line">            .withReadTimeout(<span class="number">1000</span>)</span><br><span class="line">            .withMaxConnectionsPerHost(<span class="number">1</span>)</span><br><span class="line">            .withMaxTotalConnections(<span class="number">1</span>)</span><br><span class="line">            .withConnectionIdleTimeout(<span class="number">1000</span>)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    jerseyEurekaClient = httpClientFactory.newClient(<span class="keyword">new</span> DefaultEndpoint(eurekaServiceUrl));</span><br><span class="line"></span><br><span class="line">    ServerCodecs serverCodecs = <span class="keyword">new</span> DefaultServerCodecs(eurekaServerConfig);</span><br><span class="line">    jerseyReplicationClient = JerseyReplicationClient.createReplicationClient(</span><br><span class="line">            eurekaServerConfig,</span><br><span class="line">            serverCodecs,</span><br><span class="line">            eurekaServiceUrl</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>startServer()</code>方法显式的证明了我们的猜想。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startServer</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 找到本地打好的Eureka server的war包</span></span><br><span class="line">    File warFile = findWar();</span><br><span class="line">  <span class="comment">// 启动一个jetty server用于测试</span></span><br><span class="line">    server = <span class="keyword">new</span> Server(<span class="number">8080</span>);</span><br><span class="line">  <span class="comment">// 设置jetty的一些配置，比如webapp上下文之类的东西</span></span><br><span class="line">    WebAppContext webapp = <span class="keyword">new</span> WebAppContext();</span><br><span class="line">    webapp.setContextPath(<span class="string">"/"</span>);</span><br><span class="line">    webapp.setWar(warFile.getAbsolutePath());</span><br><span class="line">    server.setHandler(webapp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动jetty</span></span><br><span class="line">    server.start();</span><br><span class="line"></span><br><span class="line">    eurekaServiceUrl = <span class="string">"http://localhost:8080/v2"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、找到了入口代码com-netflix-eureka-EurekaBootStrap"><a href="#2、找到了入口代码com-netflix-eureka-EurekaBootStrap" class="headerlink" title="2、找到了入口代码com.netflix.eureka.EurekaBootStrap"></a>2、找到了入口代码<code>com.netflix.eureka.EurekaBootStrap</code></h2><p><img src="/2019/12/09/服务注册发现：Eureka源码剖析（2）Eureka-Server启动/EurekaServer%E5%90%AF%E5%8A%A8%E6%A0%B8%E5%BF%83%E6%AD%A5%E9%AA%A4.png" alt="EurekaServer启动核心步骤"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaBootStrap</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            initEurekaEnvironment();</span><br><span class="line">            initEurekaServerContext();</span><br><span class="line"></span><br><span class="line">            ServletContext sc = event.getServletContext();</span><br><span class="line">            sc.setAttribute(EurekaServerContext.class.getName(), serverContext);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            logger.error(<span class="string">"Cannot bootstrap eureka server :"</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot bootstrap eureka server :"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.info(<span class="string">"&#123;&#125; Shutting down Eureka Server.."</span>, <span class="keyword">new</span> Date());</span><br><span class="line">            ServletContext sc = event.getServletContext();</span><br><span class="line">            sc.removeAttribute(EurekaServerContext.class.getName());</span><br><span class="line"></span><br><span class="line">            destroyEurekaServerContext();</span><br><span class="line">            destroyEurekaEnvironment();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            logger.error(<span class="string">"Error shutting down eureka"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">"&#123;&#125; Eureka Service is now shutdown..."</span>, <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来EurekaBootStrap实现了ServletContextListener接口，那么Servlet容器会在初始化ServletContext时，先调用contextInitialized方法。我们接下来重点分析这个方法。</p><h1 id="环境初始化-amp-基于单例模式的配置管理器"><a href="#环境初始化-amp-基于单例模式的配置管理器" class="headerlink" title="环境初始化 &amp; 基于单例模式的配置管理器"></a>环境初始化 &amp; 基于单例模式的配置管理器</h1><p><img src="/2019/12/09/服务注册发现：Eureka源码剖析（2）Eureka-Server启动/EurekaServer%E5%90%AF%E5%8A%A8%E4%B9%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E5%99%A8.png" alt="EurekaServer启动之初始化配置管理器"></p><p>首先，Eureka Server会初始化类似于环境变量这样的一些列配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initEurekaEnvironment</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String dataCenter = ConfigurationManager.getConfigInstance().getString(EUREKA_DATACENTER);</span><br><span class="line">    <span class="keyword">if</span> (dataCenter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ConfigurationManager.getConfigInstance().setProperty(ARCHAIUS_DEPLOYMENT_DATACENTER, DEFAULT);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ConfigurationManager.getConfigInstance().setProperty(ARCHAIUS_DEPLOYMENT_DATACENTER, dataCenter);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    String environment = ConfigurationManager.getConfigInstance().getString(EUREKA_ENVIRONMENT);</span><br><span class="line">    <span class="keyword">if</span> (environment == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ConfigurationManager.getConfigInstance().setProperty(ARCHAIUS_DEPLOYMENT_ENVIRONMENT, TEST);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ConfigurationManager.getConfigInstance() 这个就是初始化配置管理器</li><li>读取<code>eureka.datacenter</code>和<code>eureka.environment</code>配置，如果用户没有自定义就给一个默认值。数据中心的默认名称为default，eureka默认是test环境</li></ul><blockquote><p><code>ConfigurationManager</code>隶属于Netflix Archaius项目，这是一个配置增强库，不仅提供了读取本地配置文件、环境变量等基础功能，还提供了定时拉取远程配置数据源到本地等高级功能。在这里我们可以简单理解为就是一个读取本地配置的工具类就可以了。</p><p>有关Archaius的更多信息请参考：<a href="https://github.com/Netflix/archaius" target="_blank" rel="noopener">https://github.com/Netflix/archaius</a></p></blockquote><p>Eureka Server内大量运用了Archaius的ConfigurationManager，这个组件被设计成了单例的，这也符合我们的直觉。他的单例模式采用了double check + volatile来实现，这种方式在开源项目里算是常客了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> AbstractConfiguration instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractConfiguration <span class="title">getConfigInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (ConfigurationManager.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                instance = getConfigInstance(Boolean.getBoolean(DynamicPropertyFactory.DISABLE_DEFAULT_CONFIG));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>有关double check + volatile的单例模式实现，他的来龙去脉可以在这里看到<a href="https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html" target="_blank" rel="noopener">https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html</a></p></blockquote><h1 id="配置文件加载以及面向接口的配置项读取"><a href="#配置文件加载以及面向接口的配置项读取" class="headerlink" title="配置文件加载以及面向接口的配置项读取"></a>配置文件加载以及面向接口的配置项读取</h1><p><strong>设计亮点：</strong>面向接口的配置文件读取，DefaultEurekaServerConfig实现了EurekaServerConfig接口，EurekaServerConfig定义了大量配置获取的方法，这种实现方式让使用方非常清晰明了，通过方法名就获取到自己想要的配置，而且返回值还是类型友好的。</p><p><img src="/2019/12/09/服务注册发现：Eureka源码剖析（2）Eureka-Server启动/Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt="Eureka注册中心默认配置继承关系"></p><p>Eureka注册中心默认配置组件的实例化过程，本质是读取classpath下的eureka-server.properties文件内容</p><p><img src="/2019/12/09/服务注册发现：Eureka源码剖析（2）Eureka-Server启动/%E8%AF%BB%E5%8F%96eureka-server%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6.png" alt="读取eureka-server属性文件"></p><p>实质上，Eureka注册中心默认配置组件是对配置管理器的一层很薄的封装，他每个获取配置的方法都是委托给配置管理器处理的。</p><p><img src="/2019/12/09/服务注册发现：Eureka源码剖析（2）Eureka-Server启动/eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%93%E6%9E%84.png" alt="eureka注册中心默认配置的核心结构"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initEurekaServerContext</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    EurekaServerConfig eurekaServerConfig = <span class="keyword">new</span> DefaultEurekaServerConfig();</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultEurekaServerConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DynamicStringProperty EUREKA_PROPS_FILE = DynamicPropertyFactory</span><br><span class="line">        .getInstance().getStringProperty(<span class="string">"eureka.server.props"</span>,</span><br><span class="line">                                         <span class="string">"eureka-server"</span>);    </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String eurekaPropsFile = EUREKA_PROPS_FILE.get();</span><br><span class="line">        ConfigurationManager.loadCascadedPropertiesFromResources(eurekaPropsFile);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用配置管理器加载eureka-server.proerties配置文件</li><li>loadCascadedPropertiesFromResources这步拼接了<code>eureka.server.props</code>配置得到的文件名 + <code>.properties</code>后缀，得到一个完整的eureka server配置文件名，然后读取到配置管理器中。</li></ul><h1 id="基于构造器模式的服务实例构造"><a href="#基于构造器模式的服务实例构造" class="headerlink" title="基于构造器模式的服务实例构造"></a>基于构造器模式的服务实例构造</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ApplicationInfoManager applicationInfoManager = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (eurekaClient == <span class="keyword">null</span>) &#123;</span><br><span class="line">    EurekaInstanceConfig instanceConfig = isCloud(ConfigurationManager.getDeploymentContext())</span><br><span class="line">            ? <span class="keyword">new</span> CloudInstanceConfig()</span><br><span class="line">            : <span class="keyword">new</span> MyDataCenterInstanceConfig(); <span class="comment">// 默认就是走这个</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PropertiesInstanceConfig</span><span class="params">(String namespace, DataCenterInfo info)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(info);</span><br><span class="line">    <span class="comment">// 这步其实就是去加载 eureka-client.properties配置文件，这个配置文件名可用eureka.client.props配置指定</span></span><br><span class="line">    <span class="keyword">this</span>.configInstance = Archaius1Utils.initConfig(CommonConstants.CONFIG_FILE_NAME);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处使用构造器模式构建<code>InstanceInfo</code>，可以看到数据都来自<code>EurekaInstanceConfig</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EurekaConfigBasedInstanceInfoProvider</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">synchronized</span> <span class="title">InstanceInfo</span> <span class="title">get</span>() </span>&#123;</span><br><span class="line">    <span class="comment">// 主要就是从eureka实例配置中读取数据，构建服务实例信息对象（InstanceInfo），一个服务实例里面包含一个租约信息对象（LeaseInfo，也就是心跳信息）</span></span><br><span class="line">    <span class="keyword">if</span> (instanceInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 续约 心跳信息</span></span><br><span class="line">        LeaseInfo.Builder leaseInfoBuilder = LeaseInfo.Builder.newBuilder()</span><br><span class="line">                .setRenewalIntervalInSecs(config.getLeaseRenewalIntervalInSeconds())</span><br><span class="line">                .setDurationInSecs(config.getLeaseExpirationDurationInSeconds());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 服务实例信息</span></span><br><span class="line">        InstanceInfo.Builder builder = InstanceInfo.Builder.newBuilder(vipAddressResolver);</span><br><span class="line"></span><br><span class="line">        builder.setNamespace(config.getNamespace())</span><br><span class="line">                .setInstanceId(instanceId)</span><br><span class="line">                .setAppName(config.getAppname())</span><br><span class="line">                .setAppGroupName(config.getAppGroupName())</span><br><span class="line">                .setDataCenterInfo(config.getDataCenterInfo())</span><br><span class="line">                .setIPAddr(config.getIpAddress())</span><br><span class="line">                .setHostName(defaultAddress)</span><br><span class="line">                .setPort(config.getNonSecurePort())</span><br><span class="line">                .enablePort(PortType.UNSECURE, config.isNonSecurePortEnabled())</span><br><span class="line">                .setSecurePort(config.getSecurePort())</span><br><span class="line">                .enablePort(PortType.SECURE, config.getSecurePortEnabled())</span><br><span class="line">                .setVIPAddress(config.getVirtualHostName())</span><br><span class="line">                .setSecureVIPAddress(config.getSecureVirtualHostName())</span><br><span class="line">                .setHomePageUrl(config.getHomePageUrlPath(), config.getHomePageUrl())</span><br><span class="line">                .setStatusPageUrl(config.getStatusPageUrlPath(), config.getStatusPageUrl())</span><br><span class="line">                .setASGName(config.getASGName())</span><br><span class="line">                .setHealthCheckUrls(config.getHealthCheckUrlPath(),</span><br><span class="line">                        config.getHealthCheckUrl(), config.getSecureHealthCheckUrl());</span><br><span class="line"></span><br><span class="line">        instanceInfo = builder.build();</span><br><span class="line">        instanceInfo.setLeaseInfo(leaseInfoBuilder.build());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instanceInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="将自己作为Eureka-Client完成复杂构造"><a href="#将自己作为Eureka-Client完成复杂构造" class="headerlink" title="将自己作为Eureka Client完成复杂构造"></a>将自己作为Eureka Client完成复杂构造</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initEurekaServerContext</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// // 1、读取eureka client配置：这步其实就是去加载 eureka-client.properties配置文件，这个配置文件名可用eureka.client.props配置指定</span></span><br><span class="line">    EurekaClientConfig eurekaClientConfig = <span class="keyword">new</span> DefaultEurekaClientConfig();</span><br><span class="line">    <span class="comment">// eureka server把自己也当做是一个eureka-client，也是一个服务实例，向其他的eureka-server注册</span></span><br><span class="line">    eurekaClient = <span class="keyword">new</span> DiscoveryClient(applicationInfoManager, eurekaClientConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Eureka客户端的复杂实例化过程</p><ol><li>保存EurekaClientConfig和TransportConfig</li><li>处理是否要拉取注册表和是否要将自己作为Eureka Client注册到eureka</li><li>支持调度的线程池</li><li>支持心跳的线程池</li><li>支持缓存刷新的线程池</li><li>实例化一个EurekaTransport，支持eureka client和eureka server底层网络通信的组件</li><li>如果需要抓取注册表，这里就会尝试抓取增量注册表，如果抓取失败则从备份里获取注册表</li><li>初始化调度任务<ol><li>抓取服务注册表 默认间隔是 30秒 搞了一个CachedRefreshThread</li><li>向eureka server注册 心跳定时任务 默认间隔30秒; 服务实例复制器 默认40秒后开始执行 每次间隔30秒</li><li>服务状态变更监听器 如果开启，每次服务状态发生变更，就会通知远程的eureka server</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args,</span><br><span class="line">                    Provider&lt;BackupRegistry&gt; backupRegistryProvider, EndpointRandomizer endpointRandomizer) &#123;</span><br><span class="line">    <span class="comment">// 1. 保存EurekaClientConfig和TransportConfig</span></span><br><span class="line">    clientConfig = config;</span><br><span class="line">    staticClientConfig = clientConfig;</span><br><span class="line">    transportConfig = config.getTransportConfig();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 处理是否要拉取注册表和是否要将自己作为Eureka Client注册到eureka</span></span><br><span class="line">    <span class="keyword">if</span> (config.shouldFetchRegistry()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.registryStalenessMonitor = <span class="keyword">new</span> ThresholdLevelsMetric(<span class="keyword">this</span>, METRIC_REGISTRY_PREFIX + <span class="string">"lastUpdateSec_"</span>, <span class="keyword">new</span> <span class="keyword">long</span>[]&#123;<span class="number">15L</span>, <span class="number">30L</span>, <span class="number">60L</span>, <span class="number">120L</span>, <span class="number">240L</span>, <span class="number">480L</span>&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.registryStalenessMonitor = ThresholdLevelsMetric.NO_OP_METRIC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (config.shouldRegisterWithEureka()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.heartbeatStalenessMonitor = <span class="keyword">new</span> ThresholdLevelsMetric(<span class="keyword">this</span>, METRIC_REGISTRATION_PREFIX + <span class="string">"lastHeartbeatSec_"</span>, <span class="keyword">new</span> <span class="keyword">long</span>[]&#123;<span class="number">15L</span>, <span class="number">30L</span>, <span class="number">60L</span>, <span class="number">120L</span>, <span class="number">240L</span>, <span class="number">480L</span>&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.heartbeatStalenessMonitor = ThresholdLevelsMetric.NO_OP_METRIC;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 支持调度的线程池</span></span><br><span class="line">    <span class="comment">// default size of 2 - 1 each for heartbeat and cacheRefresh</span></span><br><span class="line">    scheduler = Executors.newScheduledThreadPool(<span class="number">2</span>,</span><br><span class="line">                                                 <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">                                                 .setNameFormat(<span class="string">"DiscoveryClient-%d"</span>)</span><br><span class="line">                                                 .setDaemon(<span class="keyword">true</span>)</span><br><span class="line">                                                 .build());    </span><br><span class="line">    <span class="comment">// 4. 支持心跳的线程池</span></span><br><span class="line">    heartbeatExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">        <span class="number">1</span>, clientConfig.getHeartbeatExecutorThreadPoolSize(), <span class="number">0</span>, TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">        <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">        .setNameFormat(<span class="string">"DiscoveryClient-HeartbeatExecutor-%d"</span>)</span><br><span class="line">        .setDaemon(<span class="keyword">true</span>)</span><br><span class="line">        .build()</span><br><span class="line">    );  <span class="comment">// use direct handoff</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 支持缓存刷新的线程池</span></span><br><span class="line">    cacheRefreshExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">        <span class="number">1</span>, clientConfig.getCacheRefreshExecutorThreadPoolSize(), <span class="number">0</span>, TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">        <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">        .setNameFormat(<span class="string">"DiscoveryClient-CacheRefreshExecutor-%d"</span>)</span><br><span class="line">        .setDaemon(<span class="keyword">true</span>)</span><br><span class="line">        .build()</span><br><span class="line">    );  <span class="comment">// use direct handoff</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 实例化一个EurekaTransport，支持eureka client和eureka server底层网络通信的组件</span></span><br><span class="line">    eurekaTransport = <span class="keyword">new</span> EurekaTransport();</span><br><span class="line">    <span class="comment">// 初始化eurekaTransport内的组件</span></span><br><span class="line">    scheduleServerEndpointTask(eurekaTransport, args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 如果需要抓取注册表，这里就会尝试抓取增量注册表，如果抓取失败则从备份里获取注册表</span></span><br><span class="line">    <span class="keyword">if</span> (clientConfig.shouldFetchRegistry() &amp;&amp; !fetchRegistry(<span class="keyword">false</span>)) &#123;</span><br><span class="line">        fetchRegistryFromBackup();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化调度任务</span></span><br><span class="line">    <span class="comment">// 1. 抓取服务注册表 默认间隔是 30秒 搞了一个CachedRefreshThread</span></span><br><span class="line">    <span class="comment">// 2. 向eureka server注册 心跳定时任务 默认间隔30秒; 服务实例复制器 默认40秒后开始执行 每次间隔30秒</span></span><br><span class="line">    <span class="comment">// 3. 服务状态变更监听器 如果开启，每次服务状态发生变更，就会通知远程的eureka server</span></span><br><span class="line">    <span class="comment">// finally, init the schedule tasks (e.g. cluster resolvers, heartbeat, instanceInfo replicator, fetch</span></span><br><span class="line">    initScheduledTasks();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="服务上下文构造以及初始化"><a href="#服务上下文构造以及初始化" class="headerlink" title="服务上下文构造以及初始化"></a>服务上下文构造以及初始化</h1><ul><li><p>实例化一个 可以感知eureka server集群的服务实例注册表</p></li><li><p>构造了一个Eureka集群的节点（eureka集群中每个节点是一模一样的，完全对等的，因其采用peer to peer的复制方式）</p></li><li><p>构造了一个EurekaServerContext（这个服务器上下文就是将上述所有构造好的东西都打包到这个对象里，包含了服务器需要的所有东西。然后这个Context被丢入了一个Holder中，以后需要使用的时候可以直接从Holder取）</p></li><li><p>初始化注册中心服务器上下文（<code>EurekaServerConetxt.initialize()</code>）</p><ul><li><p>启动eureka集群（<code>peerEurekaNodes.start</code>）<br>这里说一下，这里的集群是指每个eureka server中的一组节点对象，eureka的设计理念是通过维护这么一组对象，每当自己这个节点发生变化时，就修改自己内存中的这组对象，然后这组对象会负责将变更同步到对应的Eureka Server节点中去</p></li><li><p>初始化服务注册表(<code>registry.init</code>)<br>猜测：将集群中每个节点的注册表都拿过来，合并后发到自己本地的注册表里去。</p><blockquote><p>这里得说一下eureka同步的模型，采用的是push模式，即每个节点的收到的写请求（注册、下线）或自己发出的写请求（心跳）都会主动push到别的节点。<br>所以此处的<code>将每个节点的注册表都拿过来</code>，这里的数据是来自于其他节点主动推过来的数据</p></blockquote></li><li><p>从相邻的节点拷贝注册表信息，如果拷贝失败就找下一个（<code>registr.syncUp</code>）</p></li></ul></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Eureka Server的启动流成发生在EurekaBootStrap中，这个监听器配置到了web.xml中，会被servlet容器初始化。</p><p>启动流程总结：</p><ul><li>初始化环境</li><li>读取eureka-properties配置文件</li><li>将自己作为服务实例<code>InstanceInfo</code>进行实例化，数据从eureka-client.properties中读取，同时构建了服务实例信息管理器<code>ApplicationInfoManager</code></li><li>将自己作为eureka-client，从eureka-client中读取eureka client配置，基于服务实例和eureka-client配置构造了<code>DiscoveryEurekaClient</code></li><li>构造感知eureka-server集群的注册表<code>PeerAwareInstanceRegistry</code></li><li>构造一个eureka集群的信息PeerEurekaNodes</li><li>基于eureka server配置，注册表，eureka server集群、服务实例，来构造了一个eureka server上下文<code>EurekaServerContext</code></li><li><code>EurekaServerContext</code>初始化<ul><li>更新eureka server集群信息（节点新增、删除）</li><li>基于eureka server集群信息初始化注册表</li></ul></li><li>从相邻的eureka server节点拷贝注册表</li><li>注册监控</li></ul><p><img src="/2019/12/09/服务注册发现：Eureka源码剖析（2）Eureka-Server启动/eureka-server%E5%90%AF%E5%8A%A8%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="eureka server启动的流程图"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Eureka-Server模块分析&quot;&gt;&lt;a href=&quot;#Eureka-Server模块分析&quot; class=&quot;headerlink&quot; title=&quot;Eureka Server模块分析&quot;&gt;&lt;/a&gt;Eureka Server模块分析&lt;/h1&gt;&lt;h2 id=&quot;1、Eureka-Server原来是一个简单的Servlet应用&quot;&gt;&lt;a href=&quot;#1、Eureka-Server原来是一个简单的Servlet应用&quot; class=&quot;headerlink&quot; title=&quot;1、Eureka Server原来是一个简单的Servlet应用&quot;&gt;&lt;/a&gt;1、Eureka Server原来是一个简单的Servlet应用&lt;/h2&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Eureka" scheme="http://houqian.github.io/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>服务注册发现：Eureka源码剖析（1）源码阅读环境搭建</title>
    <link href="http://houqian.github.io/2019/12/08/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%881%EF%BC%89%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://houqian.github.io/2019/12/08/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%881%EF%BC%89%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2019-12-08T14:10:13.000Z</published>
    <updated>2021-06-05T15:24:58.136Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="源码阅读环境搭建"><a href="#源码阅读环境搭建" class="headerlink" title="源码阅读环境搭建"></a>源码阅读环境搭建</h1><ul><li>ide：IntelliJ IDEA</li><li>包管理：gradle</li><li>eureka版本：1.9.13</li><li>源码下载：<a href="https://github.com/Netflix/eureka/archive/refs/tags/v1.9.13.zip" target="_blank" rel="noopener">https://github.com/Netflix/eureka/archive/refs/tags/v1.9.13.zip</a></li></ul><a id="more"></a><p>将build.gradle中的如下插件版本改一下，否则导入idea会报错：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">'nebula.netflixoss'</span> version <span class="string">'5.1.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>有兴趣的同学可参照 <a href="https://github.com/nebula-plugins/gradle-netflixoss-project-plugin" target="_blank" rel="noopener">https://github.com/nebula-plugins/gradle-netflixoss-project-plugin</a> 查看详情，笔者也是从这里找到能够编译通过的版本的</p></blockquote><p>导入IDEA，等待几分钟，然后编译完成。可能需要手动设置一下各个模块的jdk，大家随便搞一个JDK8就可以。</p><h1 id="工程结构速览"><a href="#工程结构速览" class="headerlink" title="工程结构速览"></a>工程结构速览</h1><p>我们此次分析源码，不是从Spring cloud Netflix eureka开始的。</p><p>Spring cloud eureka server和client是对Netflix的eureka的封装，加了一些注解，对spring boot进行支持。所以如果上来就看eureka的源码，先从Netflix eureka开始看起，结束后再吧spring cloud Netflix eureka server和client这两个项目看一下就可以了。</p><blockquote><p><a href="https://github.com/spring-cloud/spring-cloud-netflix" target="_blank" rel="noopener">https://github.com/spring-cloud/spring-cloud-netflix</a></p><p><a href="https://github.com/Netflix/eureka" target="_blank" rel="noopener">https://github.com/Netflix/eureka</a></p><p>以上是两个项目的地址，实际上，spring cloud Netflix这个项目就是对Netflix的几个组件进行了一层很薄的封装。</p><p>spring cloud Hoxton.RELEASE对应的是Netflix eureka的1.9.13版本</p></blockquote><ul><li>eureka-client：这个就是指eureka的客户端，注册到eureka上面去的一个服务，就是一个eureka client。无论你要注册，还是要发现别的服务，无论你是服务提供者还是服务消费者，都是一个eureka 客户端</li><li>eureka-core：这个就是指的eureka的服务端，其实就是eureka的注册中心</li><li>eureka-resources：这个是基于jsp开发的eureka控制台，web页面，上面你可以看到各种注册的服务实例等信息</li><li>eureka-server：这是把eureka-client、eureka-core、eureka-resources打包成一个war包，也就是说eureka-server自己本身也是一个eureka client，同时也是注册中心，同时也提供eureka控制台。这个是我们真正使用的注册中心</li><li>eureka-example：eureka提供的使用示例</li><li>eureka-test-utils：eureka的单元测试工具</li></ul><p>我们逐一阅读，首先先剖析eureka-server，因为就是用eureka-server先启动注册中心的，然后客户端才能来注册服务和发现服务。</p><blockquote><p>如果出现了IDEA控制台乱码可以参考这篇文章解决<a href="https://blog.csdn.net/m0_37893932/article/details/78280663" target="_blank" rel="noopener">https://blog.csdn.net/m0_37893932/article/details/78280663</a></p></blockquote><h1 id="调试须知"><a href="#调试须知" class="headerlink" title="调试须知"></a>调试须知</h1><ul><li>eureka-server工程的单元测试依赖war包，需要先把eureka server的gradle的war指令执行以下，得到一个war包，就可以调试了</li><li>eureka-example 工程提供了很多实例，如果想调试eureka 客户端的逻辑可在此处找</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;源码阅读环境搭建&quot;&gt;&lt;a href=&quot;#源码阅读环境搭建&quot; class=&quot;headerlink&quot; title=&quot;源码阅读环境搭建&quot;&gt;&lt;/a&gt;源码阅读环境搭建&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;ide：IntelliJ IDEA&lt;/li&gt;
&lt;li&gt;包管理：gradle&lt;/li&gt;
&lt;li&gt;eureka版本：1.9.13&lt;/li&gt;
&lt;li&gt;源码下载：&lt;a href=&quot;https://github.com/Netflix/eureka/archive/refs/tags/v1.9.13.zip&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/Netflix/eureka/archive/refs/tags/v1.9.13.zip&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Eureka" scheme="http://houqian.github.io/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>服务注册发现：Eureka 入门</title>
    <link href="http://houqian.github.io/2019/12/08/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka-%E5%85%A5%E9%97%A8/"/>
    <id>http://houqian.github.io/2019/12/08/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka-%E5%85%A5%E9%97%A8/</id>
    <published>2019-12-08T12:32:21.000Z</published>
    <updated>2021-06-05T15:25:14.805Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Eureka解决了什么问题"><a href="#Eureka解决了什么问题" class="headerlink" title="Eureka解决了什么问题"></a>Eureka解决了什么问题</h1><p>这个问题本质是问服务注册中心的价值。很多年前，那个时候微服务还没有兴起，大家用Nginx+Tomcat就搞定了，加机器加Tomcat时候，直接在线改Nginx配置就搞定，这叫手动服务注册。但是在现今的微服务架构中，服务可能动不动就几十个，上百个，算上冗余就几百个，而且微服务的发布很频繁，不断有新的服务加入进来；在应对大流量场景时，还需要扩容缩容。这如果还依靠Nginx那种原始的手工配置方式，是不可行的，成本太高了。所以，就出现了服务注册发现，即服务实例自己会在启动后注册到服务注册中心，这叫服务注册，然后每个服务实例又从服务注册中心拉取服务注册表，动态的感知到服务的上下线，这叫服务发现。所以，服务注册中心这种技术是在微服务架构中自然而然就过渡过来的，并不突兀。eureka作为Netflix全家桶中的服务注册中心实现，其意义也就不言自明了。</p><a id="more"></a><h1 id="快速体验Eureka"><a href="#快速体验Eureka" class="headerlink" title="快速体验Eureka"></a>快速体验Eureka</h1><h2 id="1、构建一个Eureka-Server"><a href="#1、构建一个Eureka-Server" class="headerlink" title="1、构建一个Eureka Server"></a>1、构建一个Eureka Server</h2><p>创建一个maven工程，加入如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.cloud-version</span>&gt;</span>Hoxton.RELEASE<span class="tag">&lt;/<span class="name">spring.cloud-version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.cloud-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建一个<code>application.yml</code>文件，配置如下内容:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8761</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">false</span> <span class="comment">#1</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">false</span>       <span class="comment">#2</span></span><br></pre></td></tr></table></figure><blockquote><p>#1 不要将此服务注册到eureka。因为当前服务已经是eureka server了</p><p>#2 不要拉取服务注册表。</p></blockquote><p>创建一个启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaServer.class, args);</span><br><span class="line">        log.info(<span class="string">"eureka server 启动成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动后，见到如下输出即为成功:</p><p><img src="/2019/12/08/服务注册发现：Eureka-入门/eureka-server%E5%90%AF%E5%8A%A8%E6%88%90%E5%8A%9F.png" alt="eureka server启动成功"></p><h2 id="2、开发一个服务提供者"><a href="#2、开发一个服务提供者" class="headerlink" title="2、开发一个服务提供者"></a>2、开发一个服务提供者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceAController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/sayHello/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(@PathVariable(<span class="string">"name"</span>)</span> String name) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello,"</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceAApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ServiceAApplication.class, args);</span><br><span class="line">        log.info(<span class="string">"ServiceA 启动成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个<code>application.yml</code>文件，配置如下内容:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">serviceA</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># eureka client config</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">loacalhost</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka</span></span><br></pre></td></tr></table></figure><p><img src="/2019/12/08/服务注册发现：Eureka-入门/%E6%9C%8D%E5%8A%A1A%E5%90%AF%E5%8A%A8%E6%88%90%E5%8A%9F.png" alt="服务A启动成功"></p><h2 id="3、开发一个服务调用者"><a href="#3、开发一个服务调用者" class="headerlink" title="3、开发一个服务调用者"></a>3、开发一个服务调用者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/greeting/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">greeting</span><span class="params">(@PathVariable(<span class="string">"name"</span>)</span> String name) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://serviceA/sayHello/"</span> + name, String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ServiceBApplication.class, args);</span><br><span class="line">        log.info(<span class="string">"ServiceB 启动成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个<code>application.yml</code>文件，配置如下内容:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">9000</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: serviceB</span><br><span class="line"></span><br><span class="line"># eureka client config</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: loacalhost</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:<span class="comment">//localhost:8761/eureka</span></span><br></pre></td></tr></table></figure><p>启动服务</p><p><img src="/2019/12/08/服务注册发现：Eureka-入门/serviceB%E5%90%AF%E5%8A%A8%E6%88%90%E5%8A%9F.png" alt="serviceB启动成功"></p><h2 id="4、进行实验"><a href="#4、进行实验" class="headerlink" title="4、进行实验"></a>4、进行实验</h2><p>浏览器访问<code>localhost:8761</code>打开Eureka注册服务控制台，可发现ServiceA和B都注册到Eureka Server上了</p><p><img src="/2019/12/08/服务注册发现：Eureka-入门/eureka%E6%8E%A7%E5%88%B6%E5%8F%B0-1622475201958.png" alt="eureka控制台"></p><p>在浏览器访问<code>http://localhost:9000/greeting/jack</code>,就可以看到结果了</p><p><img src="/2019/12/08/服务注册发现：Eureka-入门/%E7%BB%93%E6%9E%9C.png" alt="结果"></p><h2 id="5、画图讲解Hello-Word原理"><a href="#5、画图讲解Hello-Word原理" class="headerlink" title="5、画图讲解Hello Word原理"></a>5、画图讲解Hello Word原理</h2><ul><li>服务A和B的启动类上都有<code>@EnableEurekaClient</code>注解，此注解会将服务变为Eureka客户端应用，将自己注册到Eureka Server上</li><li>服务B和服务A都会从Eureka Server拉取服务注册表</li><li>服务B发起调用服务A的请求时，Ribbon根据拉取到本地的服务注册表，将服务名替换为hostname+port并发起服务调用</li></ul><p><img src="/2019/12/08/服务注册发现：Eureka-入门/eureka-helloword%E5%8E%9F%E7%90%86.jpg" alt="eureka helloword原理"></p><h1 id="Eureka集群实战"><a href="#Eureka集群实战" class="headerlink" title="Eureka集群实战"></a>Eureka集群实战</h1><h2 id="1、eureka注册中心集群"><a href="#1、eureka注册中心集群" class="headerlink" title="1、eureka注册中心集群"></a>1、eureka注册中心集群</h2><p>eureka如此重要的服务注册中心，肯定不可能是单点的。下面我们来构建一个eureka server集群。</p><p>分别使用如下配置各启动一个eureka server，组成一个集群。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8762</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://peer2:8761/eureka</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">peer2</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8761</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: false</span><br><span class="line">    fetch-registry: false</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://peer2:8762/eureka</span><br><span class="line">  instance:</span><br><span class="line">    hostname: peer1</span><br></pre></td></tr></table></figure><blockquote><p>小技巧：可以同一个工程，分别启动一次即可。</p><p>如果是<code>IDEA</code>的话，可能不让你同时启动两个，按照如下配置一下即可，在<code>Allow parallel run</code>前打上勾即可</p></blockquote><p><img src="/2019/12/08/服务注册发现：Eureka-入门/idea%E5%90%AF%E5%8A%A8%E5%A4%9A%E4%B8%AA%E5%AE%9E%E4%BE%8B.png" alt="idea启动多个实例"></p><p>随意访问一个eureka控制台，可发现两个节点已经组成集群。DS Replicas指的是当前eureka server的副本</p><p><img src="/2019/12/08/服务注册发现：Eureka-入门/eureka%E9%9B%86%E7%BE%A4.png" alt="eureka集群"></p><blockquote><p>小提示：假如访问peer2节点，会发现没有服务实例。不用着急，下面我们改造后就OK了。</p></blockquote><h2 id="2、将服务改造为注册到eureka-server集群"><a href="#2、将服务改造为注册到eureka-server集群" class="headerlink" title="2、将服务改造为注册到eureka server集群"></a>2、将服务改造为注册到eureka server集群</h2><p>分别将服务A和B的配置改为如下这样，变更部分为最后一行</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka,http://localhost:8762/eureka</span></span><br></pre></td></tr></table></figure><p>改完重启后访问eureka控制台页面即可看到都有服务实例了。</p><h1 id="服务健康自检机制"><a href="#服务健康自检机制" class="headerlink" title="服务健康自检机制"></a>服务健康自检机制</h1><p>默认情况下，你的所有服务，比如服务A和服务B，都会自动给eureka注册中心同步心跳，续约。如果eureka server一段时间内没有感知到某个服务的心跳，就会把那个服务下线。</p><h2 id="1、基于spring-boot-actuator的服务健康检查"><a href="#1、基于spring-boot-actuator的服务健康检查" class="headerlink" title="1、基于spring-boot-actuator的服务健康检查"></a>1、基于<code>spring-boot-actuator</code>的服务健康检查</h2><p>服务加入如下依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重启后访问<code>http://localhost:port/actuator/health</code>可以看到返回的服务状态，默认是<code>UP</code></p><h2 id="2、spring-cloud-eureka整合spring-boot-actuator实现自定义服务健康检查"><a href="#2、spring-cloud-eureka整合spring-boot-actuator实现自定义服务健康检查" class="headerlink" title="2、spring-cloud-eureka整合spring-boot-actuator实现自定义服务健康检查"></a>2、<code>spring-cloud-eureka</code>整合<code>spring-boot-actuator</code>实现自定义服务健康检查</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义健康检查器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceAHealthIndicator</span> <span class="keyword">implements</span> <span class="title">HealthIndicator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Health <span class="title">health</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此处可以加上一些失败条件判断，符合这些条件就返回Status.DOWN即可</span></span><br><span class="line">        <span class="comment">// 主要是自己依赖的一些基础设施，看他们是否挂了或者自己连不上他们了，来决定自己是否健康</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Health.Builder(Status.UP).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * eureka整合actuator实现自定义健康检查器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceAHealthCheckHandler</span> <span class="keyword">implements</span> <span class="title">HealthCheckHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ServiceAHealthIndicator indicator;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> InstanceInfo.<span class="function">InstanceStatus <span class="title">getStatus</span><span class="params">(InstanceInfo.InstanceStatus currentStatus)</span> </span>&#123;</span><br><span class="line">        Status status = indicator.health().getStatus();</span><br><span class="line">        <span class="comment">// 可以根据status来决定返回什么实例状态</span></span><br><span class="line">        <span class="keyword">return</span> InstanceInfo.InstanceStatus.UP;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>eureka client会定时调用<code>getStatus</code>方法来判断服务实例的状态，如果状态变化了，就会通知eureka server。当服务实例挂掉了，那么eureka server就会感知到，然后下线这个服务实例。</p><h2 id="3、生产经验分享"><a href="#3、生产经验分享" class="headerlink" title="3、生产经验分享"></a>3、生产经验分享</h2><p>一般情况下很少使用这第二种方式自定义健康状态检查器，原因如下：</p><ul><li>对于eureka<br>eureka默认是client通过心跳与eureka server保持心跳通信，如果心跳不及时或者没有心跳了，那么就说明那个服务挂了，然后eureka server就会摘除这个服务实例，这个机制足够用了</li><li>对于服务<br>在大规模部署中，每个服务都很复杂，不可能去一个个搞一堆健康检查的。大部分情况下，我们就是会对外暴露一个/health接口，然后专门外部定时调用各个服务的/health接口来判断当前这个服务状态就足够了。</li></ul><h1 id="Eureka常见配置"><a href="#Eureka常见配置" class="headerlink" title="Eureka常见配置"></a>Eureka常见配置</h1><h2 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h2><p>eureka客户端，默认每隔30秒发送一次心跳到eureka server（以后简称注册中心）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    # 配置eureka client与注册中心心跳间隔时间，默认是30秒。在eureka中，心跳被称为续约（renew）</span><br><span class="line">    lease-renewal-interval-in-seconds: </span><br><span class="line">    # 配置如果多少秒内没有收到一个服务实例的心跳，就摘除（expiration 失效）这个服务，默认是90秒。</span><br><span class="line">    lease-expiration-duration-in-seconds:</span><br></pre></td></tr></table></figure><blockquote><p>一般情况下，这俩参数建议不要修改</p></blockquote><h2 id="注册表抓取"><a href="#注册表抓取" class="headerlink" title="注册表抓取"></a>注册表抓取</h2><p>默认情况下，客户端每隔30秒去注册中心抓取最新的注册表，然后缓存到本地。通过下面参数可修改时间间隔</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line">    <span class="comment"># 客户端每隔多少秒去注册中心抓取最新注册表，默认30秒</span></span><br><span class="line"><span class="attr">    registry-fetch-interval-seconds:</span></span><br></pre></td></tr></table></figure><h2 id="自定义元数据"><a href="#自定义元数据" class="headerlink" title="自定义元数据"></a>自定义元数据</h2><p>通过下面的metadata-map定义服务的元数据，反正就是你自己需要的一些东西，不过一般挺少使用的</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    metadata-map:</span></span><br></pre></td></tr></table></figure><h2 id="自我保护模式"><a href="#自我保护模式" class="headerlink" title="自我保护模式"></a>自我保护模式</h2><p>如果在eureka控制台看到下面这样的东西：</p><p><img src="/2019/12/08/服务注册发现：Eureka-入门/eureka%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6.png" alt="eureka自我保护机制"></p><p>这就是eureka进入了自我保护模式。如果客户端的心跳失败超过了一定的比例，或者说在一定时间内（默认15分钟）接收到的服务续约低于85%，那么就会认为是自己网络故障了，这个时候会导致人家client无法发送心跳，如果不加以控制，eureka服务实例摘除机制会将实例一个个的下掉。为了避免这种情况的发生，eureka这个时候会一种保护模式，保护服务注册表，不会立即把失效的服务实例摘除。在测试的时候一般会<strong>关闭</strong>这个自我保护模式：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  server:</span></span><br><span class="line"><span class="attr">    enable-self-preservation:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇博客，我们已经初步体会如何使用eureka，剖析了eureka的常见配置，后续我们马上进入源码剖析环节。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Eureka解决了什么问题&quot;&gt;&lt;a href=&quot;#Eureka解决了什么问题&quot; class=&quot;headerlink&quot; title=&quot;Eureka解决了什么问题&quot;&gt;&lt;/a&gt;Eureka解决了什么问题&lt;/h1&gt;&lt;p&gt;这个问题本质是问服务注册中心的价值。很多年前，那个时候微服务还没有兴起，大家用Nginx+Tomcat就搞定了，加机器加Tomcat时候，直接在线改Nginx配置就搞定，这叫手动服务注册。但是在现今的微服务架构中，服务可能动不动就几十个，上百个，算上冗余就几百个，而且微服务的发布很频繁，不断有新的服务加入进来；在应对大流量场景时，还需要扩容缩容。这如果还依靠Nginx那种原始的手工配置方式，是不可行的，成本太高了。所以，就出现了服务注册发现，即服务实例自己会在启动后注册到服务注册中心，这叫服务注册，然后每个服务实例又从服务注册中心拉取服务注册表，动态的感知到服务的上下线，这叫服务发现。所以，服务注册中心这种技术是在微服务架构中自然而然就过渡过来的，并不突兀。eureka作为Netflix全家桶中的服务注册中心实现，其意义也就不言自明了。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="Eureka" scheme="http://houqian.github.io/tags/Eureka/"/>
    
  </entry>
  
</feed>
