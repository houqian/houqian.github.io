<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>且听风吟</title>
  
  <subtitle>647 号小宇宙</subtitle>
  <link href="http://houqian.github.io/atom.xml" rel="self"/>
  
  <link href="http://houqian.github.io/"/>
  <updated>2021-06-05T15:24:17.204Z</updated>
  <id>http://houqian.github.io/</id>
  
  <author>
    <name>侯乾</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>服务注册发现：Eureka源码剖析（13）Spring Cloud Eureka源码剖析</title>
    <link href="http://houqian.github.io/2020/03/28/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%8813%EF%BC%89Spring-Cloud-Eureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <id>http://houqian.github.io/2020/03/28/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%8813%EF%BC%89Spring-Cloud-Eureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</id>
    <published>2020-03-28T12:26:51.000Z</published>
    <updated>2021-06-05T15:24:17.204Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Spring Cloud Netflix Eureka对eureka原生项目做了一点儿轻量级的封装。</p><a id="more"></a><p>下面通过几个Spring Cloud Netflix Eureka的核心注解来分析</p><ul><li><p><code>@EnableEurekaClient</code> 在Spring cloud Netflix eureka-client工程里<br>这个注解会将当前spring boot应用作为eureka client进行启动。他的处理类是<code>EurekaClientAutoConfiguration</code></p><ul><li>EurekaClientConfigBean 这个是Spring自己实现EurekaClient接口搞的一个配置类，主要内容和原版Eureka的DefaultEurekaClientConfig作用是一样的，只不过提供了Spring方式的外部配置方式。</li><li>EurekaInstanceConfigBean 这个是Spring自己实现EurekaInstanceConfig接口搞的一个配置类，作用和原版差不多</li><li>EurekaServiceRegistry 是Spring自定义的服务注册中心，主要有注册、下线方法，这个类其实主要做心跳</li><li>EurekaAutoServiceRegistration 这个是Spring对原生Eureka 的一个优化，会在服务启动时马上执行服务注册（原版需要等待40秒）</li><li>CloudEurekaClient 继承了DiscoveryClient，主要是提供了一个onCacheRefreshed方法，这个拓展就是为了在EurekaClient拉取服务注册表时，更新一下Ribbon的ServerList。还有通过@Bean(destroyMethod = “shutdown”) 指定了Spring容器销毁时调用eureka client的服务下线方法进行下线</li><li>ApplicationInfoManager 服务信息管理器，原版组件，没啥好说的</li><li>EurekaRegistration 是ServiceInstance的子类，没啥特别的</li><li>EurekaHealthIndicator Spring自定义了Eureka的HealthIndicator，边缘代码，不用看了</li></ul></li><li><p><code>@EnableEurekaServer</code> 在Spring cloud Netflix eureka-server工程里</p><ul><li>EurekaController 这是Spring根据原生eureka控制台的Controller写的控制器，因为Spring重写了控制台，所以也配套搞了个Controller，没啥可说的</li><li>InstanceRegistry我们的老朋友，原生的PeerAwareInstanceRegistryImpl的子类，主要是扩展了当发生注册、下线等等这些东西时，发布对应的Spring事件，算是Spring老生常谈的扩展方式了</li><li>RefreshablePeerEurekaNodes 继承了原生的PeerEurekaNodes，主要是对接了Spring的配置体系，当涉及到eureka server地址列表的配置变更时，就可以联动PeerEurekaNodes，搞在线扩容缩容了。</li><li>DefaultEurekaServerContext 老朋友，原生的，代表一个eureka服务器的上下文，里面包含了所有的组件资源</li><li>EurekaServerBootstrap 这个是Spring把原生的同名类代码拷贝了过来，由于使用了Spring的@Bean装配，这个类的代码享受到了依赖注入的好处，清爽了不少，但功能没变。还是启动eureka server</li></ul></li></ul><p>可以看到，Spring对eureka的扩展主要是对接Spring，都是一些胶水代码，没啥可说的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Spring Cloud Netflix Eureka对eureka原生项目做了一点儿轻量级的封装。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="Eureka" scheme="http://houqian.github.io/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>服务注册发现：Eureka源码剖析（12）核心机制源码剖析总结</title>
    <link href="http://houqian.github.io/2020/03/25/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%8812%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E6%80%BB%E7%BB%93/"/>
    <id>http://houqian.github.io/2020/03/25/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%8812%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E6%80%BB%E7%BB%93/</id>
    <published>2020-03-25T13:13:56.000Z</published>
    <updated>2021-06-05T15:24:21.053Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li>eureka 客户端会在启动时，从eureka server抓取全量注册表到本地</li></ul><a id="more"></a><ul><li><p>eureka server的维护了一个注册表多级缓存，所有外部对eureka server的注册表查询都会走这个缓存机制。这个二级缓存有30秒的同步间隔，也就意味着服务注册、下线、取消、状态变更，可能得等30秒才能生效</p></li><li><p>eureka client会每隔30秒，从eureka server抓取增量注册表，这个增量注册表也是放到注册表缓存里的</p></li><li><p>eureka client和eureka server之间通过心跳机制来完成健康检查</p></li><li><p>当eureka server发现最近1分钟内有低于85%的服务实例心跳成功，就会将自己置为自我保护模式。这个模式下，eureka server不会剔除过期服务实例。由于实现代码的问题，导致我么生产环境要么不用自我保护机制，要么就不能调整心跳时间间隔。</p></li><li><p>当eureka server不在自我保护模式时，会每隔1分钟，自动剔除最近3分钟内没有发送心跳的服务实例</p></li><li><p>eureka 集群节点之间是首次全量不同注册表，随后服务实例的变更是通过异步批量复制的，每当服务注册、下线、取消、状态变更时，会把这种动作通过三层队列机制，最终一次发送一批的方式同步到其他eureka 节点</p></li></ul><p><img src="/2020/03/25/服务注册发现：Eureka源码剖析（12）核心机制源码剖析总结/eureka%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93-(3).png" alt="eureka核心机制总结 (3)"></p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;eureka 客户端会在启动时，从eureka server抓取全量注册表到本地&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="Eureka" scheme="http://houqian.github.io/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>服务注册发现：Eureka源码剖析（11）核心机制之Eureka Server集群机制</title>
    <link href="http://houqian.github.io/2020/03/18/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%8811%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8BEurekaServer%E9%9B%86%E7%BE%A4%E6%9C%BA%E5%88%B6/"/>
    <id>http://houqian.github.io/2020/03/18/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%8811%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8BEurekaServer%E9%9B%86%E7%BE%A4%E6%9C%BA%E5%88%B6/</id>
    <published>2020-03-18T11:22:56.000Z</published>
    <updated>2021-06-05T15:24:24.794Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li>什么是eureka集群？<br>一组互相复制数据，完全对等的eureka节点。通过配置文件指定，也可以热刷新（扩容缩容）</li></ul><a id="more"></a><ul><li><p>集群机制的实现？</p><p>在eureka server启动的时候，初始化服务器上下文阶段，会启动eureka集群信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class: DefaultEurekaServerContext</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="string">"Initializing ..."</span>);</span><br><span class="line">    <span class="comment">// 启动eureka集群，这个集群是每个eureka server节点都维护的一组内存对象。</span></span><br><span class="line">    <span class="comment">// 他的作用是每当本节点发生变更，比如有服务实例注册、下线、心跳续约等事件发生时，会修改这组对象</span></span><br><span class="line">    <span class="comment">// 然后这组对象负责将修改同步到对应的eureka server节点上去。</span></span><br><span class="line">    peerEurekaNodes.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化服务注册表</span></span><br><span class="line">        <span class="comment">// 这里其实是将所有的eureka server节点上的注册表都抓取过来，合并一下</span></span><br><span class="line">        <span class="comment">// 然后存放到自己的本地注册表中去</span></span><br><span class="line">        registry.init(peerEurekaNodes);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    logger.info(<span class="string">"Initialized"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启动eureka集群，这个集群是每个eureka server节点都维护的一组内存对象。</li><li>他的作用是每当本节点发生变更，比如有服务实例注册、下线、心跳续约等事件发生时，会修改这组对象</li><li>然后这组对象负责将修改同步到对应的eureka server节点上去。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class: PeerEurekaNodes</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 搞了一个单线程的线程池 用来跑eureka集群节点的更新任务</span></span><br><span class="line">    taskExecutor = Executors.newSingleThreadScheduledExecutor(</span><br><span class="line">        <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                Thread thread = <span class="keyword">new</span> Thread(r, <span class="string">"Eureka-PeerNodesUpdater"</span>);</span><br><span class="line">                thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">return</span> thread;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这里是更新自己内存中的eureka集群，</span></span><br><span class="line">        <span class="comment">// 对新的eureka节点进行创建实例，然后添加到集群进去</span></span><br><span class="line">        <span class="comment">// 对已经无效的eureka 节点清除出这个集群中</span></span><br><span class="line">        <span class="comment">// 这里被Spring Cloud Netflix Eureka拿来做eureka集群的在线扩缩容</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新eureka server集群信息</span></span><br><span class="line">        updatePeerEurekaNodes(resolvePeerUrls());</span><br><span class="line">        Runnable peersUpdateTask = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    updatePeerEurekaNodes(resolvePeerUrls());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    logger.error(<span class="string">"Cannot update the replica Nodes"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        taskExecutor.scheduleWithFixedDelay(</span><br><span class="line">            peersUpdateTask,</span><br><span class="line">            serverConfig.getPeerEurekaNodesUpdateIntervalMs(),</span><br><span class="line">            serverConfig.getPeerEurekaNodesUpdateIntervalMs(),</span><br><span class="line">            TimeUnit.MILLISECONDS</span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (PeerEurekaNode node : peerEurekaNodes) &#123;</span><br><span class="line">        logger.info(<span class="string">"Replica node URL:  &#123;&#125;"</span>, node.getServiceUrl());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建一个线程池</li><li>解析配置文件中配置的eureka server地址列表</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class: PeerEurekaNodes</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">updatePeerEurekaNodes</span><span class="params">(List&lt;String&gt; newPeerUrls)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里toShutdown就是需要缩容的eureka server节点</span></span><br><span class="line">    <span class="comment">// 实现很简单，就是以最新的服务地址列表为准，除此之外的都需要干掉</span></span><br><span class="line">    Set&lt;String&gt; toShutdown = <span class="keyword">new</span> HashSet&lt;&gt;(peerEurekaNodeUrls);</span><br><span class="line">    toShutdown.removeAll(newPeerUrls);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里toAdd就是需要扩容的eureka server节点</span></span><br><span class="line">    <span class="comment">// 实现很简单，就是拿新增的服务地址列表</span></span><br><span class="line">    Set&lt;String&gt; toAdd = <span class="keyword">new</span> HashSet&lt;&gt;(newPeerUrls);</span><br><span class="line">    toAdd.removeAll(peerEurekaNodeUrls);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove peers no long available</span></span><br><span class="line">    List&lt;PeerEurekaNode&gt; newNodeList = <span class="keyword">new</span> ArrayList&lt;&gt;(peerEurekaNodes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里处理缩容的逻辑</span></span><br><span class="line">    <span class="comment">// 遍历现在的集群里的节点，删除缩容的节点，并且关停缩容的节点</span></span><br><span class="line">    <span class="comment">// 关停缩容的节点 其实没啥特别的 就是释放一些线程池资源而已</span></span><br><span class="line">    <span class="keyword">if</span> (!toShutdown.isEmpty()) &#123;</span><br><span class="line">        logger.info(<span class="string">"Removing no longer available peer nodes &#123;&#125;"</span>, toShutdown);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; newNodeList.size()) &#123;</span><br><span class="line">            PeerEurekaNode eurekaNode = newNodeList.get(i);</span><br><span class="line">            <span class="keyword">if</span> (toShutdown.contains(eurekaNode.getServiceUrl())) &#123;</span><br><span class="line">                newNodeList.remove(i);</span><br><span class="line">                eurekaNode.shutDown();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里处理扩容的逻辑</span></span><br><span class="line">    <span class="comment">// 遍历需要扩容的节点，创建之，加入集群</span></span><br><span class="line">    <span class="comment">// Add new peers</span></span><br><span class="line">    <span class="keyword">if</span> (!toAdd.isEmpty()) &#123;</span><br><span class="line">        logger.info(<span class="string">"Adding new peer nodes &#123;&#125;"</span>, toAdd);</span><br><span class="line">        <span class="keyword">for</span> (String peerUrl : toAdd) &#123;</span><br><span class="line">            newNodeList.add(createPeerEurekaNode(peerUrl));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.peerEurekaNodes = newNodeList;</span><br><span class="line">    <span class="keyword">this</span>.peerEurekaNodeUrls = <span class="keyword">new</span> HashSet&lt;&gt;(newPeerUrls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>集群的扩容和缩容</p><p>扩容</p><ul><li>根据最新的eureka server地址列表</li><li>与老的服务列表做比对，算出新增的服务地址，这里就是需要扩容的节点</li><li>创建节点，加入集群</li></ul><p>缩容</p><ul><li>根据最新的eureka server地址列表</li><li>与老的服务列表做比对，算出待删除的服务地址，这里就是需要缩容的节点</li><li>从集群中剔除节点，释放节点的线程池资源</li></ul></blockquote></li><li><p>集群同步机制怎么实现的？</p><p>每当服务注册、下线、取消、状态变更时，都会执行PeerAwareInstanceRegistryImpl的replicateToPeers的方法，这个方法会将这些动作同步到内存集群的队列中，然后有定时任务，会分派这些动作，将这些动作打成一批批的包，分批请求对应的eureka server。</p><p>在内存集群中，复制任务的接收、分派、消费这套流程采用了三层队列来实现，下面我们分析一下这个机制</p><ul><li><p>每个内存集群中的节点都有两个任务分派器TaskDispatcher</p></li><li><p>每个TaskDispatcher有两个执行器组成</p><ul><li>一个acceptorExecutor，负责接收任务<ul><li>如果重新处理队列、接收队列、待处理任务任意一个不为空，就执行如下逻辑；否则就睡10秒钟<ul><li>任务先进接收队列（acceptorQueue）</li><li>有个叫AcceptorRunner的后台线程不断的消费接收队列<ul><li>不断拉取重新处理队列（reprocessQueue）<ul><li>如果不为空，将里面的任务放到待执行任务（pendingTasks）中去； 插入处理顺序队列（processingOrder）</li><li>如果满了，累加重新处理队列已经清除的任务个数；清空重新处理队列</li></ul></li><li>不断拉取接收队列<ul><li>如果待执行任务满了，处理顺序队列里删除这个任务</li><li>如果没满，就放入待执行任务中去</li><li>如果刚才放入待执行任务中的那个任务是新任务，就将这个任务加入处理顺序队列中去</li></ul></li></ul></li></ul></li><li>分派批处理任务<ul><li>积攒到一批或者待执行任务中最老的任务已经延时超过500毫秒，就将待执行任务任务打成一批，放到批处理任务工作队列里</li></ul></li><li>分派单项处理任务</li></ul></li><li>一个taskExecutor，负责执行任务<ul><li>这里会从批处理任务队列里，一批批的消费，将一批任务一次请求发送到对应的eureka server节点</li></ul></li></ul></li><li><p>总结</p><p><img src="/2020/03/18/服务注册发现：Eureka源码剖析（11）核心机制之EurekaServer集群机制/eureka-server%E5%90%8C%E6%AD%A5%E4%BB%BB%E5%8A%A1%E6%89%B9%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6(1).png" alt="eureka server同步任务批处理机制(1)"></p></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;什么是eureka集群？&lt;br&gt;
一组互相复制数据，完全对等的eureka节点。通过配置文件指定，也可以热刷新（扩容缩容）&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="Eureka" scheme="http://houqian.github.io/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>服务注册发现：Eureka源码剖析（10）核心机制之Eureka Server网络故障时的自我保护机制</title>
    <link href="http://houqian.github.io/2020/03/09/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%8810%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8BEureka-Server%E7%BD%91%E7%BB%9C%E6%95%85%E9%9A%9C%E6%97%B6%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"/>
    <id>http://houqian.github.io/2020/03/09/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%8810%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8BEureka-Server%E7%BD%91%E7%BB%9C%E6%95%85%E9%9A%9C%E6%97%B6%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</id>
    <published>2020-03-09T11:19:15.000Z</published>
    <updated>2021-06-05T15:24:29.588Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li>自我保护机制是什么？<br>在eureka server中，他假定正常情况下肯定有大于85%的服务实例能够保持正常的心跳，最近1分钟内少于85%的服务实例心跳成功，eureka开发团队认为，此时大概率是eureka server自己的网络故障了，此时再进行过期实例剔除都会是误伤，于是就不再对故障实例剔除。这就叫进入了自我保护机制。</li></ul><a id="more"></a><ul><li><p>自我保护的实现原理</p><p>eureka自我保护机制的代码实现比较零散，逻辑分散的各处，需要仔细翻阅源码才能找到，笔者也是花了几个小时（一个开源项目里的代码质量还真是参差不齐。。。）</p><ul><li><p>在上篇文章讲解的自动摘除服务实例的实现方法evit中，在最开始进行了当前是否进入自我保护状态的判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeaseExpirationEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!isSelfPreservationModeEnabled()) &#123;</span><br><span class="line">           <span class="comment">// The self preservation mode is disabled, hence allowing the instances to expire.</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">       <span class="comment">// 如果开启自我保护机制 就会走下面的逻辑</span></span><br><span class="line">    </span><br><span class="line">       <span class="comment">// numberOfRenewsPerMinThreshold = 服务实例数量 * 2 * 0.85 期望值，最少有85%的实例发送心跳 心跳30秒1次，于是就 *2</span></span><br><span class="line">    </span><br><span class="line">       <span class="comment">// getNumOfRenewsInLastMin() 返回的就是 最近1分钟实际心跳成功的服务实例数</span></span><br><span class="line">       <span class="comment">// 是通过 MeasuredRate 组件 + renew时触发来实现的</span></span><br><span class="line">    </span><br><span class="line">       <span class="comment">// 这个判断的意思也就明了了，最近1分钟实际心跳成功的服务实例数 &gt; 要大于85% ，这个时候才会允许处理过期服务实例</span></span><br><span class="line">    </span><br><span class="line">       <span class="comment">// 为啥这么做？</span></span><br><span class="line">       <span class="comment">// 这也就是eureka所谓的自我保护机制的实现了。他假定正常情况下肯定会有超过85%的服务实例能够心跳成功成功的</span></span><br><span class="line">       <span class="comment">// 如果小于85%，那么就有可能是eureka server自己的网络出现故障了，此时就不能再剔除过期实例了，因为可能是误伤</span></span><br><span class="line">       <span class="comment">// 这种状态下不剔除服务实例，这个操作，就是进入自我保护模式这个动作，达到了自我保护这个状态和效果，此时eureka控制台里也会显示出那行红字</span></span><br><span class="line">    </span><br><span class="line">       <span class="comment">// 为什么测试环境非常容易触发自我保护机制呢？</span></span><br><span class="line">       <span class="comment">// 测试环境频繁的有服务实例注册、销毁，生命周期非常的短，可能连第二次心跳都没进行，这就导致最近一分钟内的服务实例心跳成功数大大降低</span></span><br><span class="line">       <span class="comment">// 非常有可能低于85%，一旦低于85%就会进入自我保护模式。</span></span><br><span class="line">       <span class="comment">// 测试环境这种情况是持续存在的，所以就会显示出eureka持续进入自我保护模式了</span></span><br><span class="line">    </span><br><span class="line">       <span class="comment">// 这个方法 返回true，说明正常；返回false，就是进入了自我保护模式了</span></span><br><span class="line">       <span class="comment">// 这点儿注意，与Spring cloud netflix eureka的实现方式相同，但返回值的含义是相反的</span></span><br><span class="line">       <span class="keyword">return</span> numberOfRenewsPerMinThreshold &gt; <span class="number">0</span> &amp;&amp; getNumOfRenewsInLastMin() &gt; numberOfRenewsPerMinThreshold;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li><p>numberOfRenewsPerMinThreshold 服务实例数量 * 2 * 0.85 期望值，最少有85%的实例发送心跳 心跳30秒1次，于是就 *2</p></li><li><p>getNumOfRenewsInLastMin()  返回的就是 最近1分钟实际心跳成功的服务实例数<br>是通过 MeasuredRate 组件 + renew时触发来实现的<br>也就是每次心跳成功都会对MeasuredRate 内的数值加1，而每隔1分钟，MeasuredRate 组件会把自己的数值清零</p></li><li><p>如果 getNumOfRenewsInLastMin() &gt; numberOfRenewsPerMinThreshold，也就是最近1分钟，少于85%的服务实例心跳成功，就意味着进入了自我保护状态了</p><blockquote><p>这个方法 返回true，说明正常；返回false，就是进入了自我保护模式了</p><p>注意，与Spring cloud netflix eureka的实现方式相同，但返回值的含义是相反的</p></blockquote></li></ul></li></ul></li><li><p>为什么测试环境非常容易触发自我保护机制呢？<br>测试环境频繁的有服务实例注册、销毁，生命周期非常的短，可能连第二次心跳都没进行，这就导致最近一分钟内的服务实例心跳成功数大大降低，非常有可能低于85%，一旦低于85%就会进入自我保护模式。 测试环境这种情况是持续存在的，所以就会显示出eureka持续进入自我保护模式了</p></li></ul><blockquote><p>注意</p><p>自我保护机制的实现，采用了硬编码的方式强制指定了30秒的心跳周期，所以在实际生产中，我们要么不用这个自我保护模式，要么就不要修改心跳间隔，否则逻辑就错乱了</p></blockquote><h1 id="总结"><a class="header-anchor" href="#总结"></a>总结</h1><p><img src="/2020/03/09/服务注册发现：Eureka源码剖析（10）核心机制之Eureka-Server网络故障时的自我保护机制/eureka%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6.png" alt="eureka自我保护机制"></p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;自我保护机制是什么？&lt;br&gt;
在eureka server中，他假定正常情况下肯定有大于85%的服务实例能够保持正常的心跳，最近1分钟内少于85%的服务实例心跳成功，eureka开发团队认为，此时大概率是eureka server自己的网络故障了，此时再进行过期实例剔除都会是误伤，于是就不再对故障实例剔除。这就叫进入了自我保护机制。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="Eureka" scheme="http://houqian.github.io/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>服务注册发现：Eureka源码剖析（9）核心机制之服务实例的自动故障感知及自动摘除机制</title>
    <link href="http://houqian.github.io/2020/03/03/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%889%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8B%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B%E7%9A%84%E8%87%AA%E5%8A%A8%E6%95%85%E9%9A%9C%E6%84%9F%E7%9F%A5%E5%8F%8A%E8%87%AA%E5%8A%A8%E6%91%98%E9%99%A4%E6%9C%BA%E5%88%B6/"/>
    <id>http://houqian.github.io/2020/03/03/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%889%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8B%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B%E7%9A%84%E8%87%AA%E5%8A%A8%E6%95%85%E9%9A%9C%E6%84%9F%E7%9F%A5%E5%8F%8A%E8%87%AA%E5%8A%A8%E6%91%98%E9%99%A4%E6%9C%BA%E5%88%B6/</id>
    <published>2020-03-03T11:26:18.000Z</published>
    <updated>2021-06-05T15:24:32.945Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li>故障感知和摘除指的是什么？<br>正常下线，会通过eureka client的shutdown方法进行，走下线流程。<br>当因为一些原因，没有通过正常下线的方式，服务实例却下线了，这种异常情况，成为故障。<br>感知，eureka server会通过定时检查多久没心跳了，感知到这种故障服务实例，并自动从注册表中把这个服务实例摘除。</li></ul><a id="more"></a><ul><li><p>eureka的自动故障感知和自动摘除机制</p><p>在eureka server启动的最后一步，openForTraffic中，最后一步super.postInit()方法里，启动了一个定时过期任务evictionTask</p><ul><li>定时过期任务延迟1分钟开始执行，然后每间隔1分钟执行一次</li><li>该任务会遍历本地注册表里，所有超过3分钟没有心跳的服务实例，将这些服务实例收集起来，这一步算是完成了<strong>自动感知机制</strong></li><li>默认情况下，一次性最多只会过期15%的服务实例</li><li>每个服务实例的剔除，是从收集到的过期服务实例列表里<strong>随机</strong>选择的，最多选择15%个</li><li>接着正式执行每个服务实例的剔除操作<ul><li>从本地注册表里摘除这个故障实例（这一步算是完成了<strong>自动摘除机制</strong>了）</li><li>将这个实例放到最近下线队列里</li><li>从overriddenInstanceStatusMap中移除</li><li>将这个实例放到最近变更队列里</li><li>失效响应缓存（就是那个注册表多级缓存）</li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;故障感知和摘除指的是什么？&lt;br&gt;
正常下线，会通过eureka client的shutdown方法进行，走下线流程。&lt;br&gt;
当因为一些原因，没有通过正常下线的方式，服务实例却下线了，这种异常情况，成为故障。&lt;br&gt;
感知，eureka server会通过定时检查多久没心跳了，感知到这种故障服务实例，并自动从注册表中把这个服务实例摘除。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="Eureka" scheme="http://houqian.github.io/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>服务注册发现：Eureka源码剖析（8）核心机制之服务下线与实例摘除</title>
    <link href="http://houqian.github.io/2020/02/25/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%888%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8B%E6%9C%8D%E5%8A%A1%E4%B8%8B%E7%BA%BF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E6%91%98%E9%99%A4/"/>
    <id>http://houqian.github.io/2020/02/25/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%888%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8B%E6%9C%8D%E5%8A%A1%E4%B8%8B%E7%BA%BF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E6%91%98%E9%99%A4/</id>
    <published>2020-02-25T11:11:11.000Z</published>
    <updated>2021-06-05T15:24:36.144Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li>当调用eureka client的shutdown方法时，会走服务下线流程。（这个shutdown方法会在Spring Cloud Netflix中spring上下文关闭时调用）<ul><li>触发下线监听器</li><li>停止调度任务（心跳、拉取注册表）</li><li>调用eureka server的 DELETA /v2/apps/APP_NAME/服务实例ID 接口</li><li>释放一系列jersey client的网络资源</li><li>注销监控<ul><li>心跳监控</li><li>注册表监控</li></ul></li></ul></li></ul><a id="more"></a><ul><li>eureka server的InstanceResource的cancelLease方法接收请求<ul><li>本节点下线<ul><li>把下线的服务实例放入最近下线队列里</li><li>从overriddenInstanceStatusMap中删除这个服务实例</li><li>把下线的服务实例放入最近变更队列里</li><li>失效响应缓存（那个注册表多级缓存）</li></ul></li><li>复制服务实例下线到集群</li></ul></li></ul><h1 id="总结"><a class="header-anchor" href="#总结"></a>总结</h1><p><img src="/2020/02/25/服务注册发现：Eureka源码剖析（8）核心机制之服务下线与实例摘除/%E6%9C%8D%E5%8A%A1%E4%B8%8B%E7%BA%BF%E7%9A%84%E9%80%BB%E8%BE%91(1).png" alt="服务下线的逻辑(1)"></p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;当调用eureka client的shutdown方法时，会走服务下线流程。（这个shutdown方法会在Spring Cloud Netflix中spring上下文关闭时调用）
&lt;ul&gt;
&lt;li&gt;触发下线监听器&lt;/li&gt;
&lt;li&gt;停止调度任务（心跳、拉取注册表）&lt;/li&gt;
&lt;li&gt;调用eureka server的 DELETA /v2/apps/APP_NAME/服务实例ID 接口&lt;/li&gt;
&lt;li&gt;释放一系列jersey client的网络资源&lt;/li&gt;
&lt;li&gt;注销监控
&lt;ul&gt;
&lt;li&gt;心跳监控&lt;/li&gt;
&lt;li&gt;注册表监控&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="Eureka" scheme="http://houqian.github.io/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>服务注册发现：Eureka源码剖析（7）核心机制之Eureka Clien与Eureka Server之间的心跳机制</title>
    <link href="http://houqian.github.io/2020/02/18/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%887%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8BEureka-Clien%E4%B8%8EEureka-Server%E4%B9%8B%E9%97%B4%E7%9A%84%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6/"/>
    <id>http://houqian.github.io/2020/02/18/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%887%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8BEureka-Clien%E4%B8%8EEureka-Server%E4%B9%8B%E9%97%B4%E7%9A%84%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6/</id>
    <published>2020-02-18T11:30:11.000Z</published>
    <updated>2021-06-05T15:24:38.765Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li>当eureka client启动时，会有一个定时任务每隔30秒向eureka server发送心跳<ul><li>心跳会将服务实例信息带上</li><li>请求的eureka server的  PUT /v2/apps/APP_NAME/服务实例ID</li><li>根据响应做如下处理<ul><li>如果返回状态码为404<br>说明eureka server没有这个服务实例，此时会走服务注册流程</li><li>如果返回状态码200，说明心跳成功了，会更新本地的最近一次成功心跳时间戳</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;ul&gt;
&lt;li&gt;当eureka client启动时，会有一个定时任务每隔30秒向</summary>
      
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="Eureka" scheme="http://houqian.github.io/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>服务注册发现：Eureka源码剖析（6）核心机制之Eureka Client间隔30s增量抓取</title>
    <link href="http://houqian.github.io/2020/02/16/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%886%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8BEureka-Client%E9%97%B4%E9%9A%9430s%E5%A2%9E%E9%87%8F%E6%8A%93%E5%8F%96/"/>
    <id>http://houqian.github.io/2020/02/16/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%886%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8BEureka-Client%E9%97%B4%E9%9A%9430s%E5%A2%9E%E9%87%8F%E6%8A%93%E5%8F%96/</id>
    <published>2020-02-16T14:10:13.000Z</published>
    <updated>2021-06-05T15:24:41.755Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li><p>eureka client启动后，每隔30秒会有一个定时任务抓取增量注册表</p><ul><li>请求的eureka server的 GET v2/apps/delta 接口</li><li>会根据返回的服务实例的类型，比如新增、修改、删除来分别处理<ul><li>新增、修改  直接添加到本地注册表（添加操作实际上是幂等的，会先删除，再添加）</li><li>删除  直接从本地注册表删除</li></ul></li></ul></li></ul><a id="more"></a><ul><li><p>eureka server的ApplicationsResource.getContainerDifferential方法会收到客户端的增量抓取请求</p><ul><li>从响应缓存中 以ALL_APPS_DELTA为key获取数据，返回给客户端</li></ul></li><li><p>eureka server中的ALL_APPS_DELTA的数据是从哪里来的呢？</p><p>从recentChangedQueue中获取的</p></li><li><p>recentChangedQueue是什么？</p><ul><li>最近变更的服务实例队列，默认存储最近3分钟的。其有一个定时任务每隔30秒检查一次队列，将3分钟以前的服务实例从队列里删除</li><li>数据来源<br>每当服务实例注册、下线、取消、变更时，都会将服务实例写到最近变更队列中去</li></ul></li></ul><h1 id="总结"><a class="header-anchor" href="#总结"></a>总结</h1><p><img src="/2020/02/16/服务注册发现：Eureka源码剖析（6）核心机制之Eureka-Client间隔30s增量抓取/eureka-client%E5%A2%9E%E9%87%8F%E6%8A%93%E5%8F%96%E6%B3%A8%E5%86%8C%E8%A1%A8.png" alt="eureka client增量抓取注册表"></p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;eureka client启动后，每隔30秒会有一个定时任务抓取增量注册表&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请求的eureka server的 GET v2/apps/delta 接口&lt;/li&gt;
&lt;li&gt;会根据返回的服务实例的类型，比如新增、修改、删除来分别处理
&lt;ul&gt;
&lt;li&gt;新增、修改  直接添加到本地注册表（添加操作实际上是幂等的，会先删除，再添加）&lt;/li&gt;
&lt;li&gt;删除  直接从本地注册表删除&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="Eureka" scheme="http://houqian.github.io/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>服务注册发现：Eureka源码剖析（5）核心机制之Eureka Server的注册表多级缓存</title>
    <link href="http://houqian.github.io/2020/02/08/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%885%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8BEureka-Server%E7%9A%84%E6%B3%A8%E5%86%8C%E8%A1%A8%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/"/>
    <id>http://houqian.github.io/2020/02/08/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%885%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8BEureka-Server%E7%9A%84%E6%B3%A8%E5%86%8C%E8%A1%A8%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/</id>
    <published>2020-02-08T11:20:19.000Z</published>
    <updated>2021-06-05T15:24:45.077Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>注册表多级缓存（就是那个ResponseCache）的原理如下：</p><ul><li>第一级缓存 readOnlyCacheMap，所有的读请求都会先走这一层</li><li>第二级缓存是一个基于Guava Cache的 readWriteCacheMap 当第一层获取不到数据时，会走这一层<ul><li>数据加载 将自己的本地注册表数据以key为ALL_APPS填充到第二级缓存中去</li></ul></li></ul><a id="more"></a><ul><li>缓存失效时机<ul><li>二级缓存失效时机<ul><li>当服务注册、服务下线、服务状态变更、服务剔除时会触发缓存失效</li></ul></li><li>默认的写入二级缓存的数据 180秒后会过期</li></ul></li><li>缓存同步<ul><li>有一个定时任务，每隔30秒，比对一二级缓存的数据，如果不一致，就用二级缓存的数据覆盖一级缓存的，回写到一级缓存中去</li></ul></li></ul><blockquote><p>问题</p><p>由于缓存同步有30秒的间隔，因此最差情况下，我们得到最新注册表需要30秒。</p><p>也就意味着，当有服务注册、下线、故障时，可能得30秒后才能感知到。</p></blockquote><h1 id="总结"><a class="header-anchor" href="#总结"></a>总结</h1><p><img src="/2020/02/08/服务注册发现：Eureka源码剖析（5）核心机制之Eureka-Server的注册表多级缓存/eureka-server%E7%9A%84%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%E8%BF%87%E6%9C%9F%E6%9C%BA%E5%88%B6.png" alt="eureka-server的多级缓存过期机制"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;注册表多级缓存（就是那个ResponseCache）的原理如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一级缓存 readOnlyCacheMap，所有的读请求都会先走这一层&lt;/li&gt;
&lt;li&gt;第二级缓存是一个基于Guava Cache的 readWriteCacheMap 当第一层获取不到数据时，会走这一层
&lt;ul&gt;
&lt;li&gt;数据加载 将自己的本地注册表数据以key为ALL_APPS填充到第二级缓存中去&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="Eureka" scheme="http://houqian.github.io/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>服务注册发现：Eureka源码剖析（4）核心机制之Eureka Client首次启动抓取全量注册表</title>
    <link href="http://houqian.github.io/2020/02/03/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%884%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8BEureka-Client%E9%A6%96%E6%AC%A1%E5%90%AF%E5%8A%A8%E6%8A%93%E5%8F%96%E5%85%A8%E9%87%8F%E6%B3%A8%E5%86%8C%E8%A1%A8/"/>
    <id>http://houqian.github.io/2020/02/03/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%884%EF%BC%89%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B9%8BEureka-Client%E9%A6%96%E6%AC%A1%E5%90%AF%E5%8A%A8%E6%8A%93%E5%8F%96%E5%85%A8%E9%87%8F%E6%B3%A8%E5%86%8C%E8%A1%A8/</id>
    <published>2020-02-03T11:10:11.000Z</published>
    <updated>2021-06-05T15:24:47.833Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li>Eureka Client首次抓取是在启动时进行的</li><li>通过eurekaTransport.queryClient这个jersey客户端,请求eureka server的 GET /v2/apps/APP_NAME 接口</li><li>拿到响应的Applications后会将顺序打乱，然后存到本地</li></ul><hr><ul><li><p>eureka server的ApplicationsResource.getContainers方法会收到请求</p></li><li><p>从响应缓存中把key为ALL_APPS的数据数据返回给客户端</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;ul&gt;
&lt;li&gt;Eureka Client首次抓取是在启动时进行的&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="Eureka" scheme="http://houqian.github.io/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>服务注册发现：Eureka源码剖析（3）服务注册</title>
    <link href="http://houqian.github.io/2019/12/13/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%883%EF%BC%89%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/"/>
    <id>http://houqian.github.io/2019/12/13/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%883%EF%BC%89%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/</id>
    <published>2019-12-13T11:30:22.000Z</published>
    <updated>2021-06-05T15:24:51.946Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="eureka-client启动流程"><a class="header-anchor" href="#eureka-client启动流程"></a>Eureka Client启动流程</h1><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleEurekaClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        ExampleEurekaClient sampleClient = <span class="keyword">new</span> ExampleEurekaClient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个new MyDataCenterInstanceConfig()，其实主要就是读取eureka-client.properties，然后构建一个服务实例配置</span></span><br><span class="line">        ApplicationInfoManager applicationInfoManager = initializeApplicationInfoManager(<span class="keyword">new</span> MyDataCenterInstanceConfig());</span><br><span class="line">        <span class="comment">// 这个new DefaultEurekaClient(),其实就是读取eureka-client.properties构造一个eureka客户端配置</span></span><br><span class="line">        <span class="comment">// 基于接口对外提供eureka-client的配置读取</span></span><br><span class="line">        EurekaClient client = initializeEurekaClient(applicationInfoManager, <span class="keyword">new</span> DefaultEurekaClientConfig());</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 用eureka客户端向eureka server发送请求</span></span><br><span class="line">        sampleClient.sendRequestToServiceUsingEureka(client);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 关闭eureka客户端</span></span><br><span class="line">        eurekaClient.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 这里就是根据服务实例配置，初始化服务信息管理器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> ApplicationInfoManager <span class="title">initializeApplicationInfoManager</span><span class="params">(EurekaInstanceConfig instanceConfig)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (applicationInfoManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 1. 根据服务实例配置，构造一个服务实例</span></span><br><span class="line">            InstanceInfo instanceInfo = <span class="keyword">new</span> EurekaConfigBasedInstanceInfoProvider(instanceConfig).get();</span><br><span class="line">            <span class="comment">// 2. 根据服务实例和配置，构造一个应用信息管理器</span></span><br><span class="line">            applicationInfoManager = <span class="keyword">new</span> ApplicationInfoManager(instanceConfig, instanceInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> applicationInfoManager;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 根据应用信息管理器和eureka-client配置，构造出EurekaClient</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> EurekaClient <span class="title">initializeEurekaClient</span><span class="params">(ApplicationInfoManager applicationInfoManager, EurekaClientConfig clientConfig)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (eurekaClient == <span class="keyword">null</span>) &#123;</span><br><span class="line">            eurekaClient = <span class="keyword">new</span> DiscoveryClient(applicationInfoManager, clientConfig);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> eurekaClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这部分已经在上篇文章剖析过了，这里直接出总结</p><p><img src="/2019/12/13/服务注册发现：Eureka源码剖析（3）服务注册/03-eureka-client%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.jpg" alt="03-eureka client启动流程"></p><h1 id="eureka-client是如何进行服务注册的"><a class="header-anchor" href="#eureka-client是如何进行服务注册的"></a>Eureka Client是如何进行服务注册的</h1><ul><li>在eureka-client实例化的最后一步，启动了一个实例信息复制器，默认40秒之后开始执行，这个定时任务逻辑如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> initialDelayMs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (started.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        <span class="comment">// 先将代表自己的这个服务实例状态设置为dirty</span></span><br><span class="line">        <span class="comment">// 其实，标记为dirty就是为了在下一次服务心跳时将实例信息发给eureka server</span></span><br><span class="line">        instanceInfo.setIsDirty();  <span class="comment">// for initial register</span></span><br><span class="line">        Future next = scheduler.schedule(<span class="keyword">this</span>, initialDelayMs, TimeUnit.SECONDS);</span><br><span class="line">        scheduledPeriodicRef.set(next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 先刷新一下实例信息</span></span><br><span class="line">        discoveryClient.refreshInstanceInfo();</span><br><span class="line"></span><br><span class="line">        Long dirtyTimestamp = instanceInfo.isDirtyWithTime();</span><br><span class="line">        <span class="keyword">if</span> (dirtyTimestamp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里才是真正的服务注册</span></span><br><span class="line">            <span class="comment">// 这里其实就是调用网络通信组件的服务注册客户端向eureka server的POST /apps 接口发起服务注册</span></span><br><span class="line">            discoveryClient.register();</span><br><span class="line">            <span class="comment">// 注册完成了，就不需要在心跳里发送这个服务实例了</span></span><br><span class="line">            instanceInfo.unsetIsDirty(dirtyTimestamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.warn(<span class="string">"There was a problem with the instance info replicator"</span>, t);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 这个replicationIntervalSeconds 默认是40秒</span></span><br><span class="line">        <span class="comment">// 也就是说eureka client启动时，延迟40秒才进行服务注册，这点儿非常坑，在Spring Cloud Netflix中已被修复（马上注册）</span></span><br><span class="line">        Future next = scheduler.schedule(<span class="keyword">this</span>, replicationIntervalSeconds, TimeUnit.SECONDS);</span><br><span class="line">        scheduledPeriodicRef.set(next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="eureka-server是如何完成服务注册的"><a class="header-anchor" href="#eureka-server是如何完成服务注册的"></a>Eureka Server是如何完成服务注册的</h1><ul><li>上一步客户端发起服务注册后，ApplicationResource#addInstance 会接收到请求，最终将请求转给PeerAwareInstanceRegistry.register</li><li>进行注册<ul><li>将请求送上来的实例信息放到自己的服务注册表中<code>ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt; registry</code></li><li>将服务实例放到最近注册队列（recentRegisteredQueue）中去</li><li>将服务实例放到最近变更队列（recentlyChangedQueue）中去</li><li>过期ResponseCache</li></ul></li><li>同步注册到其他节点</li></ul><h1 id="总结"><a class="header-anchor" href="#总结"></a>总结</h1><p><img src="/2019/12/13/服务注册发现：Eureka源码剖析（3）服务注册/eureka%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E7%9A%84%E6%B5%81%E7%A8%8B.png" alt="eureka的服务注册的流程"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;eureka-client启动流程&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#eureka-client启动流程&quot;&gt;&lt;/a&gt;Eureka Client启动流程&lt;/h1&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="Eureka" scheme="http://houqian.github.io/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>服务注册发现：Eureka源码剖析（2）Eureka Server启动</title>
    <link href="http://houqian.github.io/2019/12/09/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%882%EF%BC%89Eureka-Server%E5%90%AF%E5%8A%A8/"/>
    <id>http://houqian.github.io/2019/12/09/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%882%EF%BC%89Eureka-Server%E5%90%AF%E5%8A%A8/</id>
    <published>2019-12-09T11:15:13.000Z</published>
    <updated>2021-06-05T15:24:55.071Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="eureka-server模块分析"><a class="header-anchor" href="#eureka-server模块分析"></a>Eureka Server模块分析</h1><h2 id="1-eureka-server原来是一个简单的servlet应用"><a class="header-anchor" href="#1-eureka-server原来是一个简单的servlet应用"></a>1、Eureka Server原来是一个简单的Servlet应用</h2><a id="more"></a><p>Eureka Server模块非常简单，有价值的就一个web.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这个EurekaBootStrap 就是Eureka Server的入口代码，我们从这个类开始分析就对了 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.netflix.eureka.EurekaBootStrap<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>jersey<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.sun.jersey.spi.container.servlet.ServletContainer<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>com.sun.jersey.config.property.WebPageContentRegex<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/(flex|images|js|css|jsp)/.*<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>com.sun.jersey.config.property.packages<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.sun.jersey;com.netflix<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- GZIP content encoding/decoding --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>com.sun.jersey.spi.container.ContainerRequestFilters<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.sun.jersey.api.container.filter.GZIPContentEncodingFilter<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>com.sun.jersey.spi.container.ContainerResponseFilters<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.sun.jersey.api.container.filter.GZIPContentEncodingFilter<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>statusFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>requestAuthFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Uncomment this to enable rate limiter filter.</span></span><br><span class="line"><span class="comment">&lt;filter-mapping&gt;</span></span><br><span class="line"><span class="comment">  &lt;filter-name&gt;rateLimitingFilter&lt;/filter-name&gt;</span></span><br><span class="line"><span class="comment">  &lt;url-pattern&gt;/v2/apps&lt;/url-pattern&gt;</span></span><br><span class="line"><span class="comment">  &lt;url-pattern&gt;/v2/apps/*&lt;/url-pattern&gt;</span></span><br><span class="line"><span class="comment">&lt;/filter-mapping&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>gzipEncodingEnforcingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/v2/apps<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/v2/apps/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>jersey<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>jsp/status.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br></pre></td></tr></table></figure><p>看到这个，一下子回想起多年以前，我们打war包部署到Tomcat中发布应用的时候。可以看到web.xml定义了各种Listener、filter、filter-mapping，比如Listener就是在Servlet容器启动时跟随着初始化，做一些事情。原来，Eureka Server是用最传统的Servlet那种方式开发的一个简单web应用。<br>在test目录下，发现有一个<code>EurekaClientServerRestIntegrationTest</code>单元测试类，里面的<code>setUp()</code>方法验证了我们的猜想：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BeforeClass</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 注入一些Eureka配置数据（这是为了测试而mock的配置）</span></span><br><span class="line">    injectEurekaConfiguration();</span><br><span class="line">    <span class="comment">// 启动服务</span></span><br><span class="line">    startServer();</span><br><span class="line">    createEurekaServerConfig();</span><br><span class="line"></span><br><span class="line">    httpClientFactory = JerseyEurekaHttpClientFactory.newBuilder()</span><br><span class="line">            .withClientName(<span class="string">"testEurekaClient"</span>)</span><br><span class="line">            .withConnectionTimeout(<span class="number">1000</span>)</span><br><span class="line">            .withReadTimeout(<span class="number">1000</span>)</span><br><span class="line">            .withMaxConnectionsPerHost(<span class="number">1</span>)</span><br><span class="line">            .withMaxTotalConnections(<span class="number">1</span>)</span><br><span class="line">            .withConnectionIdleTimeout(<span class="number">1000</span>)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    jerseyEurekaClient = httpClientFactory.newClient(<span class="keyword">new</span> DefaultEndpoint(eurekaServiceUrl));</span><br><span class="line"></span><br><span class="line">    ServerCodecs serverCodecs = <span class="keyword">new</span> DefaultServerCodecs(eurekaServerConfig);</span><br><span class="line">    jerseyReplicationClient = JerseyReplicationClient.createReplicationClient(</span><br><span class="line">            eurekaServerConfig,</span><br><span class="line">            serverCodecs,</span><br><span class="line">            eurekaServiceUrl</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>startServer()</code>方法显式的证明了我们的猜想。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startServer</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 找到本地打好的Eureka server的war包</span></span><br><span class="line">    File warFile = findWar();</span><br><span class="line">  <span class="comment">// 启动一个jetty server用于测试</span></span><br><span class="line">    server = <span class="keyword">new</span> Server(<span class="number">8080</span>);</span><br><span class="line">  <span class="comment">// 设置jetty的一些配置，比如webapp上下文之类的东西</span></span><br><span class="line">    WebAppContext webapp = <span class="keyword">new</span> WebAppContext();</span><br><span class="line">    webapp.setContextPath(<span class="string">"/"</span>);</span><br><span class="line">    webapp.setWar(warFile.getAbsolutePath());</span><br><span class="line">    server.setHandler(webapp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动jetty</span></span><br><span class="line">    server.start();</span><br><span class="line"></span><br><span class="line">    eurekaServiceUrl = <span class="string">"http://localhost:8080/v2"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-找到了入口代码com-netflix-eureka-eurekabootstrap"><a class="header-anchor" href="#2-找到了入口代码com-netflix-eureka-eurekabootstrap"></a>2、找到了入口代码<code>com.netflix.eureka.EurekaBootStrap</code></h2><p><img src="/2019/12/09/服务注册发现：Eureka源码剖析（2）Eureka-Server启动/EurekaServer%E5%90%AF%E5%8A%A8%E6%A0%B8%E5%BF%83%E6%AD%A5%E9%AA%A4.png" alt="EurekaServer启动核心步骤"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaBootStrap</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            initEurekaEnvironment();</span><br><span class="line">            initEurekaServerContext();</span><br><span class="line"></span><br><span class="line">            ServletContext sc = event.getServletContext();</span><br><span class="line">            sc.setAttribute(EurekaServerContext.class.getName(), serverContext);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            logger.error(<span class="string">"Cannot bootstrap eureka server :"</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot bootstrap eureka server :"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.info(<span class="string">"&#123;&#125; Shutting down Eureka Server.."</span>, <span class="keyword">new</span> Date());</span><br><span class="line">            ServletContext sc = event.getServletContext();</span><br><span class="line">            sc.removeAttribute(EurekaServerContext.class.getName());</span><br><span class="line"></span><br><span class="line">            destroyEurekaServerContext();</span><br><span class="line">            destroyEurekaEnvironment();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            logger.error(<span class="string">"Error shutting down eureka"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">"&#123;&#125; Eureka Service is now shutdown..."</span>, <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来EurekaBootStrap实现了ServletContextListener接口，那么Servlet容器会在初始化ServletContext时，先调用contextInitialized方法。我们接下来重点分析这个方法。</p><h1 id="环境初始化-基于单例模式的配置管理器"><a class="header-anchor" href="#环境初始化-基于单例模式的配置管理器"></a>环境初始化 &amp; 基于单例模式的配置管理器</h1><p><img src="/2019/12/09/服务注册发现：Eureka源码剖析（2）Eureka-Server启动/EurekaServer%E5%90%AF%E5%8A%A8%E4%B9%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E5%99%A8.png" alt="EurekaServer启动之初始化配置管理器"></p><p>首先，Eureka Server会初始化类似于环境变量这样的一些列配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initEurekaEnvironment</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String dataCenter = ConfigurationManager.getConfigInstance().getString(EUREKA_DATACENTER);</span><br><span class="line">    <span class="keyword">if</span> (dataCenter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ConfigurationManager.getConfigInstance().setProperty(ARCHAIUS_DEPLOYMENT_DATACENTER, DEFAULT);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ConfigurationManager.getConfigInstance().setProperty(ARCHAIUS_DEPLOYMENT_DATACENTER, dataCenter);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    String environment = ConfigurationManager.getConfigInstance().getString(EUREKA_ENVIRONMENT);</span><br><span class="line">    <span class="keyword">if</span> (environment == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ConfigurationManager.getConfigInstance().setProperty(ARCHAIUS_DEPLOYMENT_ENVIRONMENT, TEST);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ConfigurationManager.getConfigInstance() 这个就是初始化配置管理器</li><li>读取<code>eureka.datacenter</code>和<code>eureka.environment</code>配置，如果用户没有自定义就给一个默认值。数据中心的默认名称为default，eureka默认是test环境</li></ul><blockquote><p><code>ConfigurationManager</code>隶属于Netflix Archaius项目，这是一个配置增强库，不仅提供了读取本地配置文件、环境变量等基础功能，还提供了定时拉取远程配置数据源到本地等高级功能。在这里我们可以简单理解为就是一个读取本地配置的工具类就可以了。</p><p>有关Archaius的更多信息请参考：<a href="https://github.com/Netflix/archaius" target="_blank" rel="noopener">https://github.com/Netflix/archaius</a></p></blockquote><p>Eureka Server内大量运用了Archaius的ConfigurationManager，这个组件被设计成了单例的，这也符合我们的直觉。他的单例模式采用了double check + volatile来实现，这种方式在开源项目里算是常客了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> AbstractConfiguration instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractConfiguration <span class="title">getConfigInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (ConfigurationManager.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                instance = getConfigInstance(Boolean.getBoolean(DynamicPropertyFactory.DISABLE_DEFAULT_CONFIG));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>有关double check + volatile的单例模式实现，他的来龙去脉可以在这里看到https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html</p></blockquote><h1 id="配置文件加载以及面向接口的配置项读取"><a class="header-anchor" href="#配置文件加载以及面向接口的配置项读取"></a>配置文件加载以及面向接口的配置项读取</h1><p>**设计亮点：**面向接口的配置文件读取，DefaultEurekaServerConfig实现了EurekaServerConfig接口，EurekaServerConfig定义了大量配置获取的方法，这种实现方式让使用方非常清晰明了，通过方法名就获取到自己想要的配置，而且返回值还是类型友好的。</p><p><img src="/2019/12/09/服务注册发现：Eureka源码剖析（2）Eureka-Server启动/Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt="Eureka注册中心默认配置继承关系"></p><p>Eureka注册中心默认配置组件的实例化过程，本质是读取classpath下的eureka-server.properties文件内容</p><p><img src="/2019/12/09/服务注册发现：Eureka源码剖析（2）Eureka-Server启动/%E8%AF%BB%E5%8F%96eureka-server%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6.png" alt="读取eureka-server属性文件"></p><p>实质上，Eureka注册中心默认配置组件是对配置管理器的一层很薄的封装，他每个获取配置的方法都是委托给配置管理器处理的。</p><p><img src="/2019/12/09/服务注册发现：Eureka源码剖析（2）Eureka-Server启动/eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%93%E6%9E%84.png" alt="eureka注册中心默认配置的核心结构"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initEurekaServerContext</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    EurekaServerConfig eurekaServerConfig = <span class="keyword">new</span> DefaultEurekaServerConfig();</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultEurekaServerConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DynamicStringProperty EUREKA_PROPS_FILE = DynamicPropertyFactory</span><br><span class="line">        .getInstance().getStringProperty(<span class="string">"eureka.server.props"</span>,</span><br><span class="line">                                         <span class="string">"eureka-server"</span>);    </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String eurekaPropsFile = EUREKA_PROPS_FILE.get();</span><br><span class="line">        ConfigurationManager.loadCascadedPropertiesFromResources(eurekaPropsFile);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用配置管理器加载eureka-server.proerties配置文件</li><li>loadCascadedPropertiesFromResources这步拼接了<code>eureka.server.props</code>配置得到的文件名 + <code>.properties</code>后缀，得到一个完整的eureka server配置文件名，然后读取到配置管理器中。</li></ul><h1 id="基于构造器模式的服务实例构造"><a class="header-anchor" href="#基于构造器模式的服务实例构造"></a>基于构造器模式的服务实例构造</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ApplicationInfoManager applicationInfoManager = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (eurekaClient == <span class="keyword">null</span>) &#123;</span><br><span class="line">    EurekaInstanceConfig instanceConfig = isCloud(ConfigurationManager.getDeploymentContext())</span><br><span class="line">            ? <span class="keyword">new</span> CloudInstanceConfig()</span><br><span class="line">            : <span class="keyword">new</span> MyDataCenterInstanceConfig(); <span class="comment">// 默认就是走这个</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PropertiesInstanceConfig</span><span class="params">(String namespace, DataCenterInfo info)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(info);</span><br><span class="line">    <span class="comment">// 这步其实就是去加载 eureka-client.properties配置文件，这个配置文件名可用eureka.client.props配置指定</span></span><br><span class="line">    <span class="keyword">this</span>.configInstance = Archaius1Utils.initConfig(CommonConstants.CONFIG_FILE_NAME);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处使用构造器模式构建<code>InstanceInfo</code>，可以看到数据都来自<code>EurekaInstanceConfig</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EurekaConfigBasedInstanceInfoProvider</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">synchronized</span> <span class="title">InstanceInfo</span> <span class="title">get</span>() </span>&#123;</span><br><span class="line">    <span class="comment">// 主要就是从eureka实例配置中读取数据，构建服务实例信息对象（InstanceInfo），一个服务实例里面包含一个租约信息对象（LeaseInfo，也就是心跳信息）</span></span><br><span class="line">    <span class="keyword">if</span> (instanceInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 续约 心跳信息</span></span><br><span class="line">        LeaseInfo.Builder leaseInfoBuilder = LeaseInfo.Builder.newBuilder()</span><br><span class="line">                .setRenewalIntervalInSecs(config.getLeaseRenewalIntervalInSeconds())</span><br><span class="line">                .setDurationInSecs(config.getLeaseExpirationDurationInSeconds());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 服务实例信息</span></span><br><span class="line">        InstanceInfo.Builder builder = InstanceInfo.Builder.newBuilder(vipAddressResolver);</span><br><span class="line"></span><br><span class="line">        builder.setNamespace(config.getNamespace())</span><br><span class="line">                .setInstanceId(instanceId)</span><br><span class="line">                .setAppName(config.getAppname())</span><br><span class="line">                .setAppGroupName(config.getAppGroupName())</span><br><span class="line">                .setDataCenterInfo(config.getDataCenterInfo())</span><br><span class="line">                .setIPAddr(config.getIpAddress())</span><br><span class="line">                .setHostName(defaultAddress)</span><br><span class="line">                .setPort(config.getNonSecurePort())</span><br><span class="line">                .enablePort(PortType.UNSECURE, config.isNonSecurePortEnabled())</span><br><span class="line">                .setSecurePort(config.getSecurePort())</span><br><span class="line">                .enablePort(PortType.SECURE, config.getSecurePortEnabled())</span><br><span class="line">                .setVIPAddress(config.getVirtualHostName())</span><br><span class="line">                .setSecureVIPAddress(config.getSecureVirtualHostName())</span><br><span class="line">                .setHomePageUrl(config.getHomePageUrlPath(), config.getHomePageUrl())</span><br><span class="line">                .setStatusPageUrl(config.getStatusPageUrlPath(), config.getStatusPageUrl())</span><br><span class="line">                .setASGName(config.getASGName())</span><br><span class="line">                .setHealthCheckUrls(config.getHealthCheckUrlPath(),</span><br><span class="line">                        config.getHealthCheckUrl(), config.getSecureHealthCheckUrl());</span><br><span class="line"></span><br><span class="line">        instanceInfo = builder.build();</span><br><span class="line">        instanceInfo.setLeaseInfo(leaseInfoBuilder.build());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instanceInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="将自己作为eureka-client完成复杂构造"><a class="header-anchor" href="#将自己作为eureka-client完成复杂构造"></a>将自己作为Eureka Client完成复杂构造</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initEurekaServerContext</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// // 1、读取eureka client配置：这步其实就是去加载 eureka-client.properties配置文件，这个配置文件名可用eureka.client.props配置指定</span></span><br><span class="line">    EurekaClientConfig eurekaClientConfig = <span class="keyword">new</span> DefaultEurekaClientConfig();</span><br><span class="line">    <span class="comment">// eureka server把自己也当做是一个eureka-client，也是一个服务实例，向其他的eureka-server注册</span></span><br><span class="line">    eurekaClient = <span class="keyword">new</span> DiscoveryClient(applicationInfoManager, eurekaClientConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Eureka客户端的复杂实例化过程</p><ol><li>保存EurekaClientConfig和TransportConfig</li><li>处理是否要拉取注册表和是否要将自己作为Eureka Client注册到eureka</li><li>支持调度的线程池</li><li>支持心跳的线程池</li><li>支持缓存刷新的线程池</li><li>实例化一个EurekaTransport，支持eureka client和eureka server底层网络通信的组件</li><li>如果需要抓取注册表，这里就会尝试抓取增量注册表，如果抓取失败则从备份里获取注册表</li><li>初始化调度任务<ol><li>抓取服务注册表 默认间隔是 30秒 搞了一个CachedRefreshThread</li><li>向eureka server注册 心跳定时任务 默认间隔30秒; 服务实例复制器 默认40秒后开始执行 每次间隔30秒</li><li>服务状态变更监听器 如果开启，每次服务状态发生变更，就会通知远程的eureka server</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args,</span><br><span class="line">                    Provider&lt;BackupRegistry&gt; backupRegistryProvider, EndpointRandomizer endpointRandomizer) &#123;</span><br><span class="line">    <span class="comment">// 1. 保存EurekaClientConfig和TransportConfig</span></span><br><span class="line">    clientConfig = config;</span><br><span class="line">    staticClientConfig = clientConfig;</span><br><span class="line">    transportConfig = config.getTransportConfig();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 处理是否要拉取注册表和是否要将自己作为Eureka Client注册到eureka</span></span><br><span class="line">    <span class="keyword">if</span> (config.shouldFetchRegistry()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.registryStalenessMonitor = <span class="keyword">new</span> ThresholdLevelsMetric(<span class="keyword">this</span>, METRIC_REGISTRY_PREFIX + <span class="string">"lastUpdateSec_"</span>, <span class="keyword">new</span> <span class="keyword">long</span>[]&#123;<span class="number">15L</span>, <span class="number">30L</span>, <span class="number">60L</span>, <span class="number">120L</span>, <span class="number">240L</span>, <span class="number">480L</span>&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.registryStalenessMonitor = ThresholdLevelsMetric.NO_OP_METRIC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (config.shouldRegisterWithEureka()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.heartbeatStalenessMonitor = <span class="keyword">new</span> ThresholdLevelsMetric(<span class="keyword">this</span>, METRIC_REGISTRATION_PREFIX + <span class="string">"lastHeartbeatSec_"</span>, <span class="keyword">new</span> <span class="keyword">long</span>[]&#123;<span class="number">15L</span>, <span class="number">30L</span>, <span class="number">60L</span>, <span class="number">120L</span>, <span class="number">240L</span>, <span class="number">480L</span>&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.heartbeatStalenessMonitor = ThresholdLevelsMetric.NO_OP_METRIC;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 支持调度的线程池</span></span><br><span class="line">    <span class="comment">// default size of 2 - 1 each for heartbeat and cacheRefresh</span></span><br><span class="line">    scheduler = Executors.newScheduledThreadPool(<span class="number">2</span>,</span><br><span class="line">                                                 <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">                                                 .setNameFormat(<span class="string">"DiscoveryClient-%d"</span>)</span><br><span class="line">                                                 .setDaemon(<span class="keyword">true</span>)</span><br><span class="line">                                                 .build());    </span><br><span class="line">    <span class="comment">// 4. 支持心跳的线程池</span></span><br><span class="line">    heartbeatExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">        <span class="number">1</span>, clientConfig.getHeartbeatExecutorThreadPoolSize(), <span class="number">0</span>, TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">        <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">        .setNameFormat(<span class="string">"DiscoveryClient-HeartbeatExecutor-%d"</span>)</span><br><span class="line">        .setDaemon(<span class="keyword">true</span>)</span><br><span class="line">        .build()</span><br><span class="line">    );  <span class="comment">// use direct handoff</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 支持缓存刷新的线程池</span></span><br><span class="line">    cacheRefreshExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">        <span class="number">1</span>, clientConfig.getCacheRefreshExecutorThreadPoolSize(), <span class="number">0</span>, TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">        <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">        .setNameFormat(<span class="string">"DiscoveryClient-CacheRefreshExecutor-%d"</span>)</span><br><span class="line">        .setDaemon(<span class="keyword">true</span>)</span><br><span class="line">        .build()</span><br><span class="line">    );  <span class="comment">// use direct handoff</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 实例化一个EurekaTransport，支持eureka client和eureka server底层网络通信的组件</span></span><br><span class="line">    eurekaTransport = <span class="keyword">new</span> EurekaTransport();</span><br><span class="line">    <span class="comment">// 初始化eurekaTransport内的组件</span></span><br><span class="line">    scheduleServerEndpointTask(eurekaTransport, args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 如果需要抓取注册表，这里就会尝试抓取增量注册表，如果抓取失败则从备份里获取注册表</span></span><br><span class="line">    <span class="keyword">if</span> (clientConfig.shouldFetchRegistry() &amp;&amp; !fetchRegistry(<span class="keyword">false</span>)) &#123;</span><br><span class="line">        fetchRegistryFromBackup();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化调度任务</span></span><br><span class="line">    <span class="comment">// 1. 抓取服务注册表 默认间隔是 30秒 搞了一个CachedRefreshThread</span></span><br><span class="line">    <span class="comment">// 2. 向eureka server注册 心跳定时任务 默认间隔30秒; 服务实例复制器 默认40秒后开始执行 每次间隔30秒</span></span><br><span class="line">    <span class="comment">// 3. 服务状态变更监听器 如果开启，每次服务状态发生变更，就会通知远程的eureka server</span></span><br><span class="line">    <span class="comment">// finally, init the schedule tasks (e.g. cluster resolvers, heartbeat, instanceInfo replicator, fetch</span></span><br><span class="line">    initScheduledTasks();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="服务上下文构造以及初始化"><a class="header-anchor" href="#服务上下文构造以及初始化"></a>服务上下文构造以及初始化</h1><ul><li><p>实例化一个 可以感知eureka server集群的服务实例注册表</p></li><li><p>构造了一个Eureka集群的节点（eureka集群中每个节点是一模一样的，完全对等的，因其采用peer to peer的复制方式）</p></li><li><p>构造了一个EurekaServerContext（这个服务器上下文就是将上述所有构造好的东西都打包到这个对象里，包含了服务器需要的所有东西。然后这个Context被丢入了一个Holder中，以后需要使用的时候可以直接从Holder取）</p></li><li><p>初始化注册中心服务器上下文（<code>EurekaServerConetxt.initialize()</code>）</p><ul><li><p>启动eureka集群（<code>peerEurekaNodes.start</code>）<br>这里说一下，这里的集群是指每个eureka server中的一组节点对象，eureka的设计理念是通过维护这么一组对象，每当自己这个节点发生变化时，就修改自己内存中的这组对象，然后这组对象会负责将变更同步到对应的Eureka Server节点中去</p></li><li><p>初始化服务注册表(<code>registry.init</code>)<br>猜测：将集群中每个节点的注册表都拿过来，合并后发到自己本地的注册表里去。</p><blockquote><p>这里得说一下eureka同步的模型，采用的是push模式，即每个节点的收到的写请求（注册、下线）或自己发出的写请求（心跳）都会主动push到别的节点。<br>所以此处的<code>将每个节点的注册表都拿过来</code>，这里的数据是来自于其他节点主动推过来的数据</p></blockquote></li><li><p>从相邻的节点拷贝注册表信息，如果拷贝失败就找下一个（<code>registr.syncUp</code>）</p></li></ul></li></ul><h1 id="总结"><a class="header-anchor" href="#总结"></a>总结</h1><p>Eureka Server的启动流成发生在EurekaBootStrap中，这个监听器配置到了web.xml中，会被servlet容器初始化。</p><p>启动流程总结：</p><ul><li>初始化环境</li><li>读取eureka-properties配置文件</li><li>将自己作为服务实例<code>InstanceInfo</code>进行实例化，数据从eureka-client.properties中读取，同时构建了服务实例信息管理器<code>ApplicationInfoManager</code></li><li>将自己作为eureka-client，从eureka-client中读取eureka client配置，基于服务实例和eureka-client配置构造了<code>DiscoveryEurekaClient</code></li><li>构造感知eureka-server集群的注册表<code>PeerAwareInstanceRegistry</code></li><li>构造一个eureka集群的信息PeerEurekaNodes</li><li>基于eureka server配置，注册表，eureka server集群、服务实例，来构造了一个eureka server上下文<code>EurekaServerContext</code></li><li><code>EurekaServerContext</code>初始化<ul><li>更新eureka server集群信息（节点新增、删除）</li><li>基于eureka server集群信息初始化注册表</li></ul></li><li>从相邻的eureka server节点拷贝注册表</li><li>注册监控</li></ul><p><img src="/2019/12/09/服务注册发现：Eureka源码剖析（2）Eureka-Server启动/eureka-server%E5%90%AF%E5%8A%A8%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="eureka server启动的流程图"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;eureka-server模块分析&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#eureka-server模块分析&quot;&gt;&lt;/a&gt;Eureka Server模块分析&lt;/h1&gt;
&lt;h2 id=&quot;1-eureka-server原来是一个简单的servlet应用&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#1-eureka-server原来是一个简单的servlet应用&quot;&gt;&lt;/a&gt;1、Eureka Server原来是一个简单的Servlet应用&lt;/h2&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="Eureka" scheme="http://houqian.github.io/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>服务注册发现：Eureka源码剖析（1）源码阅读环境搭建</title>
    <link href="http://houqian.github.io/2019/12/08/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%881%EF%BC%89%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://houqian.github.io/2019/12/08/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%881%EF%BC%89%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2019-12-08T14:10:13.000Z</published>
    <updated>2021-06-05T15:24:58.136Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="源码阅读环境搭建"><a class="header-anchor" href="#源码阅读环境搭建"></a>源码阅读环境搭建</h1><ul><li>ide：IntelliJ IDEA</li><li>包管理：gradle</li><li>eureka版本：1.9.13</li><li>源码下载：<a href="https://github.com/Netflix/eureka/archive/refs/tags/v1.9.13.zip" target="_blank" rel="noopener">https://github.com/Netflix/eureka/archive/refs/tags/v1.9.13.zip</a></li></ul><a id="more"></a><p>将build.gradle中的如下插件版本改一下，否则导入idea会报错：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">'nebula.netflixoss'</span> version <span class="string">'5.1.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>有兴趣的同学可参照 <a href="https://github.com/nebula-plugins/gradle-netflixoss-project-plugin" target="_blank" rel="noopener">https://github.com/nebula-plugins/gradle-netflixoss-project-plugin</a> 查看详情，笔者也是从这里找到能够编译通过的版本的</p></blockquote><p>导入IDEA，等待几分钟，然后编译完成。可能需要手动设置一下各个模块的jdk，大家随便搞一个JDK8就可以。</p><h1 id="工程结构速览"><a class="header-anchor" href="#工程结构速览"></a>工程结构速览</h1><p>我们此次分析源码，不是从Spring cloud Netflix eureka开始的。</p><p>Spring cloud eureka server和client是对Netflix的eureka的封装，加了一些注解，对spring boot进行支持。所以如果上来就看eureka的源码，先从Netflix eureka开始看起，结束后再吧spring cloud Netflix eureka server和client这两个项目看一下就可以了。</p><blockquote><p><a href="https://github.com/spring-cloud/spring-cloud-netflix" target="_blank" rel="noopener">https://github.com/spring-cloud/spring-cloud-netflix</a></p><p><a href="https://github.com/Netflix/eureka" target="_blank" rel="noopener">https://github.com/Netflix/eureka</a></p><p>以上是两个项目的地址，实际上，spring cloud Netflix这个项目就是对Netflix的几个组件进行了一层很薄的封装。</p><p>spring cloud Hoxton.RELEASE对应的是Netflix eureka的1.9.13版本</p></blockquote><ul><li>eureka-client：这个就是指eureka的客户端，注册到eureka上面去的一个服务，就是一个eureka client。无论你要注册，还是要发现别的服务，无论你是服务提供者还是服务消费者，都是一个eureka 客户端</li><li>eureka-core：这个就是指的eureka的服务端，其实就是eureka的注册中心</li><li>eureka-resources：这个是基于jsp开发的eureka控制台，web页面，上面你可以看到各种注册的服务实例等信息</li><li>eureka-server：这是把eureka-client、eureka-core、eureka-resources打包成一个war包，也就是说eureka-server自己本身也是一个eureka client，同时也是注册中心，同时也提供eureka控制台。这个是我们真正使用的注册中心</li><li>eureka-example：eureka提供的使用示例</li><li>eureka-test-utils：eureka的单元测试工具</li></ul><p>我们逐一阅读，首先先剖析eureka-server，因为就是用eureka-server先启动注册中心的，然后客户端才能来注册服务和发现服务。</p><blockquote><p>如果出现了IDEA控制台乱码可以参考这篇文章解决https://blog.csdn.net/m0_37893932/article/details/78280663</p></blockquote><h1 id="调试须知"><a class="header-anchor" href="#调试须知"></a>调试须知</h1><ul><li>eureka-server工程的单元测试依赖war包，需要先把eureka server的gradle的war指令执行以下，得到一个war包，就可以调试了</li><li>eureka-example 工程提供了很多实例，如果想调试eureka 客户端的逻辑可在此处找</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;源码阅读环境搭建&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#源码阅读环境搭建&quot;&gt;&lt;/a&gt;源码阅读环境搭建&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;ide：IntelliJ IDEA&lt;/li&gt;
&lt;li&gt;包管理：gradle&lt;/li&gt;
&lt;li&gt;eureka版本：1.9.13&lt;/li&gt;
&lt;li&gt;源码下载：&lt;a href=&quot;https://github.com/Netflix/eureka/archive/refs/tags/v1.9.13.zip&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/Netflix/eureka/archive/refs/tags/v1.9.13.zip&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="Eureka" scheme="http://houqian.github.io/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>服务注册发现：Eureka 入门</title>
    <link href="http://houqian.github.io/2019/12/08/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka-%E5%85%A5%E9%97%A8/"/>
    <id>http://houqian.github.io/2019/12/08/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%EF%BC%9AEureka-%E5%85%A5%E9%97%A8/</id>
    <published>2019-12-08T12:32:21.000Z</published>
    <updated>2021-06-05T15:25:14.805Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="eureka解决了什么问题"><a class="header-anchor" href="#eureka解决了什么问题"></a>Eureka解决了什么问题</h1><p>这个问题本质是问服务注册中心的价值。很多年前，那个时候微服务还没有兴起，大家用Nginx+Tomcat就搞定了，加机器加Tomcat时候，直接在线改Nginx配置就搞定，这叫手动服务注册。但是在现今的微服务架构中，服务可能动不动就几十个，上百个，算上冗余就几百个，而且微服务的发布很频繁，不断有新的服务加入进来；在应对大流量场景时，还需要扩容缩容。这如果还依靠Nginx那种原始的手工配置方式，是不可行的，成本太高了。所以，就出现了服务注册发现，即服务实例自己会在启动后注册到服务注册中心，这叫服务注册，然后每个服务实例又从服务注册中心拉取服务注册表，动态的感知到服务的上下线，这叫服务发现。所以，服务注册中心这种技术是在微服务架构中自然而然就过渡过来的，并不突兀。eureka作为Netflix全家桶中的服务注册中心实现，其意义也就不言自明了。</p><a id="more"></a><h1 id="快速体验eureka"><a class="header-anchor" href="#快速体验eureka"></a>快速体验Eureka</h1><h2 id="1-构建一个eureka-server"><a class="header-anchor" href="#1-构建一个eureka-server"></a>1、构建一个Eureka Server</h2><p>创建一个maven工程，加入如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.cloud-version</span>&gt;</span>Hoxton.RELEASE<span class="tag">&lt;/<span class="name">spring.cloud-version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.cloud-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建一个<code>application.yml</code>文件，配置如下内容:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8761</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">false</span> <span class="comment">#1</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">false</span>       <span class="comment">#2</span></span><br></pre></td></tr></table></figure><blockquote><p>#1 不要将此服务注册到eureka。因为当前服务已经是eureka server了</p><p>#2 不要拉取服务注册表。</p></blockquote><p>创建一个启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaServer.class, args);</span><br><span class="line">        log.info(<span class="string">"eureka server 启动成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动后，见到如下输出即为成功:</p><p><img src="/2019/12/08/服务注册发现：Eureka-入门/eureka-server%E5%90%AF%E5%8A%A8%E6%88%90%E5%8A%9F.png" alt="eureka server启动成功"></p><h2 id="2-开发一个服务提供者"><a class="header-anchor" href="#2-开发一个服务提供者"></a>2、开发一个服务提供者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceAController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/sayHello/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(@PathVariable(<span class="string">"name"</span>)</span> String name) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello,"</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceAApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ServiceAApplication.class, args);</span><br><span class="line">        log.info(<span class="string">"ServiceA 启动成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个<code>application.yml</code>文件，配置如下内容:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">serviceA</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># eureka client config</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">loacalhost</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka</span></span><br></pre></td></tr></table></figure><p><img src="/2019/12/08/服务注册发现：Eureka-入门/%E6%9C%8D%E5%8A%A1A%E5%90%AF%E5%8A%A8%E6%88%90%E5%8A%9F.png" alt="服务A启动成功"></p><h2 id="3-开发一个服务调用者"><a class="header-anchor" href="#3-开发一个服务调用者"></a>3、开发一个服务调用者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/greeting/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">greeting</span><span class="params">(@PathVariable(<span class="string">"name"</span>)</span> String name) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://serviceA/sayHello/"</span> + name, String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ServiceBApplication.class, args);</span><br><span class="line">        log.info(<span class="string">"ServiceB 启动成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个<code>application.yml</code>文件，配置如下内容:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">9000</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: serviceB</span><br><span class="line"></span><br><span class="line"># eureka client config</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: loacalhost</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:<span class="comment">//localhost:8761/eureka</span></span><br></pre></td></tr></table></figure><p>启动服务</p><p><img src="/2019/12/08/服务注册发现：Eureka-入门/serviceB%E5%90%AF%E5%8A%A8%E6%88%90%E5%8A%9F.png" alt="serviceB启动成功"></p><h2 id="4-进行实验"><a class="header-anchor" href="#4-进行实验"></a>4、进行实验</h2><p>浏览器访问<code>localhost:8761</code>打开Eureka注册服务控制台，可发现ServiceA和B都注册到Eureka Server上了</p><p><img src="/2019/12/08/服务注册发现：Eureka-入门/eureka%E6%8E%A7%E5%88%B6%E5%8F%B0-1622475201958.png" alt="eureka控制台"></p><p>在浏览器访问<code>http://localhost:9000/greeting/jack</code>,就可以看到结果了</p><p><img src="/2019/12/08/服务注册发现：Eureka-入门/%E7%BB%93%E6%9E%9C.png" alt="结果"></p><h2 id="5-画图讲解hello-word原理"><a class="header-anchor" href="#5-画图讲解hello-word原理"></a>5、画图讲解Hello Word原理</h2><ul><li>服务A和B的启动类上都有<code>@EnableEurekaClient</code>注解，此注解会将服务变为Eureka客户端应用，将自己注册到Eureka Server上</li><li>服务B和服务A都会从Eureka Server拉取服务注册表</li><li>服务B发起调用服务A的请求时，Ribbon根据拉取到本地的服务注册表，将服务名替换为hostname+port并发起服务调用</li></ul><p><img src="/2019/12/08/服务注册发现：Eureka-入门/eureka-helloword%E5%8E%9F%E7%90%86.jpg" alt="eureka helloword原理"></p><h1 id="eureka集群实战"><a class="header-anchor" href="#eureka集群实战"></a>Eureka集群实战</h1><h2 id="1-eureka注册中心集群"><a class="header-anchor" href="#1-eureka注册中心集群"></a>1、eureka注册中心集群</h2><p>eureka如此重要的服务注册中心，肯定不可能是单点的。下面我们来构建一个eureka server集群。</p><p>分别使用如下配置各启动一个eureka server，组成一个集群。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8762</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://peer2:8761/eureka</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">peer2</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8761</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: false</span><br><span class="line">    fetch-registry: false</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://peer2:8762/eureka</span><br><span class="line">  instance:</span><br><span class="line">    hostname: peer1</span><br></pre></td></tr></table></figure><blockquote><p>小技巧：可以同一个工程，分别启动一次即可。</p><p>如果是<code>IDEA</code>的话，可能不让你同时启动两个，按照如下配置一下即可，在<code>Allow parallel run</code>前打上勾即可</p></blockquote><p><img src="/2019/12/08/服务注册发现：Eureka-入门/idea%E5%90%AF%E5%8A%A8%E5%A4%9A%E4%B8%AA%E5%AE%9E%E4%BE%8B.png" alt="idea启动多个实例"></p><p>随意访问一个eureka控制台，可发现两个节点已经组成集群。DS Replicas指的是当前eureka server的副本</p><p><img src="/2019/12/08/服务注册发现：Eureka-入门/eureka%E9%9B%86%E7%BE%A4.png" alt="eureka集群"></p><blockquote><p>小提示：假如访问peer2节点，会发现没有服务实例。不用着急，下面我们改造后就OK了。</p></blockquote><h2 id="2-将服务改造为注册到eureka-server集群"><a class="header-anchor" href="#2-将服务改造为注册到eureka-server集群"></a>2、将服务改造为注册到eureka server集群</h2><p>分别将服务A和B的配置改为如下这样，变更部分为最后一行</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka,http://localhost:8762/eureka</span></span><br></pre></td></tr></table></figure><p>改完重启后访问eureka控制台页面即可看到都有服务实例了。</p><h1 id="服务健康自检机制"><a class="header-anchor" href="#服务健康自检机制"></a>服务健康自检机制</h1><p>默认情况下，你的所有服务，比如服务A和服务B，都会自动给eureka注册中心同步心跳，续约。如果eureka server一段时间内没有感知到某个服务的心跳，就会把那个服务下线。</p><h2 id="1-基于spring-boot-actuator的服务健康检查"><a class="header-anchor" href="#1-基于spring-boot-actuator的服务健康检查"></a>1、基于<code>spring-boot-actuator</code>的服务健康检查</h2><p>服务加入如下依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重启后访问<code>http://localhost:port/actuator/health</code>可以看到返回的服务状态，默认是<code>UP</code></p><h2 id="2-spring-cloud-eureka整合spring-boot-actuator实现自定义服务健康检查"><a class="header-anchor" href="#2-spring-cloud-eureka整合spring-boot-actuator实现自定义服务健康检查"></a>2、<code>spring-cloud-eureka</code>整合<code>spring-boot-actuator</code>实现自定义服务健康检查</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义健康检查器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceAHealthIndicator</span> <span class="keyword">implements</span> <span class="title">HealthIndicator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Health <span class="title">health</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此处可以加上一些失败条件判断，符合这些条件就返回Status.DOWN即可</span></span><br><span class="line">        <span class="comment">// 主要是自己依赖的一些基础设施，看他们是否挂了或者自己连不上他们了，来决定自己是否健康</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Health.Builder(Status.UP).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * eureka整合actuator实现自定义健康检查器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceAHealthCheckHandler</span> <span class="keyword">implements</span> <span class="title">HealthCheckHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ServiceAHealthIndicator indicator;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> InstanceInfo.<span class="function">InstanceStatus <span class="title">getStatus</span><span class="params">(InstanceInfo.InstanceStatus currentStatus)</span> </span>&#123;</span><br><span class="line">        Status status = indicator.health().getStatus();</span><br><span class="line">        <span class="comment">// 可以根据status来决定返回什么实例状态</span></span><br><span class="line">        <span class="keyword">return</span> InstanceInfo.InstanceStatus.UP;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>eureka client会定时调用<code>getStatus</code>方法来判断服务实例的状态，如果状态变化了，就会通知eureka server。当服务实例挂掉了，那么eureka server就会感知到，然后下线这个服务实例。</p><h2 id="3-生产经验分享"><a class="header-anchor" href="#3-生产经验分享"></a>3、生产经验分享</h2><p>一般情况下很少使用这第二种方式自定义健康状态检查器，原因如下：</p><ul><li>对于eureka<br>eureka默认是client通过心跳与eureka server保持心跳通信，如果心跳不及时或者没有心跳了，那么就说明那个服务挂了，然后eureka server就会摘除这个服务实例，这个机制足够用了</li><li>对于服务<br>在大规模部署中，每个服务都很复杂，不可能去一个个搞一堆健康检查的。大部分情况下，我们就是会对外暴露一个/health接口，然后专门外部定时调用各个服务的/health接口来判断当前这个服务状态就足够了。</li></ul><h1 id="eureka常见配置"><a class="header-anchor" href="#eureka常见配置"></a>Eureka常见配置</h1><h2 id="心跳检测"><a class="header-anchor" href="#心跳检测"></a>心跳检测</h2><p>eureka客户端，默认每隔30秒发送一次心跳到eureka server（以后简称注册中心）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    # 配置eureka client与注册中心心跳间隔时间，默认是30秒。在eureka中，心跳被称为续约（renew）</span><br><span class="line">    lease-renewal-interval-in-seconds: </span><br><span class="line">    # 配置如果多少秒内没有收到一个服务实例的心跳，就摘除（expiration 失效）这个服务，默认是90秒。</span><br><span class="line">    lease-expiration-duration-in-seconds:</span><br></pre></td></tr></table></figure><blockquote><p>一般情况下，这俩参数建议不要修改</p></blockquote><h2 id="注册表抓取"><a class="header-anchor" href="#注册表抓取"></a>注册表抓取</h2><p>默认情况下，客户端每隔30秒去注册中心抓取最新的注册表，然后缓存到本地。通过下面参数可修改时间间隔</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line">    <span class="comment"># 客户端每隔多少秒去注册中心抓取最新注册表，默认30秒</span></span><br><span class="line"><span class="attr">    registry-fetch-interval-seconds:</span></span><br></pre></td></tr></table></figure><h2 id="自定义元数据"><a class="header-anchor" href="#自定义元数据"></a>自定义元数据</h2><p>通过下面的metadata-map定义服务的元数据，反正就是你自己需要的一些东西，不过一般挺少使用的</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    metadata-map:</span></span><br></pre></td></tr></table></figure><h2 id="自我保护模式"><a class="header-anchor" href="#自我保护模式"></a>自我保护模式</h2><p>如果在eureka控制台看到下面这样的东西：</p><p><img src="/2019/12/08/服务注册发现：Eureka-入门/eureka%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6.png" alt="eureka自我保护机制"></p><p>这就是eureka进入了自我保护模式。如果客户端的心跳失败超过了一定的比例，或者说在一定时间内（默认15分钟）接收到的服务续约低于85%，那么就会认为是自己网络故障了，这个时候会导致人家client无法发送心跳，如果不加以控制，eureka服务实例摘除机制会将实例一个个的下掉。为了避免这种情况的发生，eureka这个时候会一种保护模式，保护服务注册表，不会立即把失效的服务实例摘除。在测试的时候一般会<strong>关闭</strong>这个自我保护模式：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  server:</span></span><br><span class="line"><span class="attr">    enable-self-preservation:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a class="header-anchor" href="#总结"></a>总结</h1><p>本篇博客，我们已经初步体会如何使用eureka，剖析了eureka的常见配置，后续我们马上进入源码剖析环节。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;eureka解决了什么问题&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#eureka解决了什么问题&quot;&gt;&lt;/a&gt;Eureka解决了什么问题&lt;/h1&gt;
&lt;p&gt;这个问题本质是问服务注册中心的价值。很多年前，那个时候微服务还没有兴起，大家用Nginx+Tomcat就搞定了，加机器加Tomcat时候，直接在线改Nginx配置就搞定，这叫手动服务注册。但是在现今的微服务架构中，服务可能动不动就几十个，上百个，算上冗余就几百个，而且微服务的发布很频繁，不断有新的服务加入进来；在应对大流量场景时，还需要扩容缩容。这如果还依靠Nginx那种原始的手工配置方式，是不可行的，成本太高了。所以，就出现了服务注册发现，即服务实例自己会在启动后注册到服务注册中心，这叫服务注册，然后每个服务实例又从服务注册中心拉取服务注册表，动态的感知到服务的上下线，这叫服务发现。所以，服务注册中心这种技术是在微服务架构中自然而然就过渡过来的，并不突兀。eureka作为Netflix全家桶中的服务注册中心实现，其意义也就不言自明了。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
    <category term="Eureka" scheme="http://houqian.github.io/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Netflix技术栈系列文章</title>
    <link href="http://houqian.github.io/2019/12/05/Spring-Cloud-Netflix%E6%8A%80%E6%9C%AF%E6%A0%88%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"/>
    <id>http://houqian.github.io/2019/12/05/Spring-Cloud-Netflix%E6%8A%80%E6%9C%AF%E6%A0%88%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/</id>
    <published>2019-12-05T11:51:52.000Z</published>
    <updated>2021-06-05T15:25:23.700Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="为什么写？"><a class="header-anchor" href="#为什么写？"></a>为什么写？</h1><p>时下Spring Cloud Netflix全家桶已经成为了事实上的微服务实践落地的不二选择，笔者在公司也负责、参与一系列的微服务改造项目，该系列文章涵盖了笔者从刚接触该技术栈的入门到实战，再到源码分析的整个过程，是对自己经历的一次梳理，希望对您也有所帮助。</p><a id="more"></a><h1 id="准备写哪些内容？"><a class="header-anchor" href="#准备写哪些内容？"></a>准备写哪些内容？</h1><p>主要针对Spring Cloud Netflix主要技术栈，包括：</p><ul><li>服务注册发现Eureka</li><li>负载均衡 Ribbon</li><li>声明式接口调用 Feign</li><li>资源隔离、限流、熔断、降级 Hystrix</li><li>网关 Zuul</li></ul><p>预计会按照此顺序进行撰写，每个技术点会从解决了什么问题、入门Demo、核心功能实战、核心机制源码剖析几个方面描述。</p><h1 id="spring-cloud基本常识"><a class="header-anchor" href="#spring-cloud基本常识"></a>Spring Cloud基本常识</h1><h2 id="如何找到指定时间发布的springcloud版本？"><a class="header-anchor" href="#如何找到指定时间发布的springcloud版本？"></a>如何找到指定时间发布的SpringCloud版本？</h2><p>去maven仓库找到对应的版本号<br><a href="https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-dependencies" target="_blank" rel="noopener">https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-dependencies</a></p><h2 id="如何找到与之兼容的springboot版本？"><a class="header-anchor" href="#如何找到与之兼容的springboot版本？"></a>如何找到与之兼容的SpringBoot版本？</h2><ol><li><p>Google搜索Spring Cloud ${版本名称} RELEASE 即可找到对应的发布页面，比如本次我们使用的就是刚发布的最新版HOXTON<br><a href="https://spring.io/blog/2019/11/28/spring-cloud-hoxton-released" target="_blank" rel="noopener">https://spring.io/blog/2019/11/28/spring-cloud-hoxton-released</a></p></li><li><p>然后注意 第二个标题 Notable Changes in the xxxxx Train，就可以找到对应的SpringBoot版本了。<br>Spring Cloud Hoxton.RELEASE is based on Spring Boot 2.2.1.RELEASE.</p></li></ol><h2 id="通用springcloud工程maven配置"><a class="header-anchor" href="#通用springcloud工程maven配置"></a>通用SpringCloud工程Maven配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>与SpringCloud兼容的SpringBoot版本<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">spring.cloud-version</span>&gt;</span>SpringCloud版本号<span class="tag">&lt;/<span class="name">spring.cloud-version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 你的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.cloud-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;为什么写？&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#为什么写？&quot;&gt;&lt;/a&gt;为什么写？&lt;/h1&gt;
&lt;p&gt;时下Spring Cloud Netflix全家桶已经成为了事实上的微服务实践落地的不二选择，笔者在公司也负责、参与一系列的微服务改造项目，该系列文章涵盖了笔者从刚接触该技术栈的入门到实战，再到源码分析的整个过程，是对自己经历的一次梳理，希望对您也有所帮助。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="Spring Cloud" scheme="http://houqian.github.io/tags/Spring-Cloud/"/>
    
    <category term="Spring Cloud Netflix" scheme="http://houqian.github.io/tags/Spring-Cloud-Netflix/"/>
    
  </entry>
  
  <entry>
    <title>使用vim的宏录制功能格式化注释文档</title>
    <link href="http://houqian.github.io/2019/07/18/%E4%BD%BF%E7%94%A8vim%E7%9A%84%E5%AE%8F%E5%BD%95%E5%88%B6%E5%8A%9F%E8%83%BD%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%B3%A8%E9%87%8A%E6%96%87%E6%A1%A3/"/>
    <id>http://houqian.github.io/2019/07/18/%E4%BD%BF%E7%94%A8vim%E7%9A%84%E5%AE%8F%E5%BD%95%E5%88%B6%E5%8A%9F%E8%83%BD%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%B3%A8%E9%87%8A%E6%96%87%E6%A1%A3/</id>
    <published>2019-07-18T03:56:00.000Z</published>
    <updated>2021-06-05T15:22:12.404Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="起因"><a class="header-anchor" href="#起因"></a>起因</h2><p>经常看各类 javadoc 发现有一类 doc 并没有被做成标准的 doc 格式，直接复制出来想翻译一下，需要做一些预处理，比如删除注释、合并断行，前者各种编辑器的列模式搞定，后者就坑爹了，之前是手工一行一行的删除换行符，然后加空格的，非常坑爹。对于这类重复性操作，使用 vim 的宏录制就再好不过了。</p><a id="more"></a><h2 id="vim-的宏录制"><a class="header-anchor" href="#vim-的宏录制"></a>vim 的宏录制</h2><p>宏录制是指将一个操作序列保存后重复回放的功能。分为启动宏录制、进行宏录制、结束宏录制、使用宏录制四个部分。</p><table><thead><tr><th>启动宏录制</th><th>进行宏录制</th><th>结束宏录制</th><th>使用宏录制</th></tr></thead><tbody><tr><td>normal 模式下，q+储存器名，比如按 qa</td><td>正常操作即可，需要注意可重复性</td><td>按 q</td><td>@+存储器名，比如@a，如果想重复多次，可以 count+@+存储器名，比如 100@a,就会将操作序列 a 重复 100 次</td></tr></tbody></table><h3 id="示例：预处理-completablefuture-的设计文档"><a class="header-anchor" href="#示例：预处理-completablefuture-的设计文档"></a>示例：预处理 CompletableFuture 的设计文档</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Overview:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A CompletableFuture may have dependent completion actions,</span></span><br><span class="line"><span class="comment"> * collected in a linked stack. It atomically completes by CASing</span></span><br><span class="line"><span class="comment"> * a result field, and then pops off and runs those actions. This</span></span><br><span class="line"><span class="comment"> * applies across normal vs exceptional outcomes, sync vs async</span></span><br><span class="line"><span class="comment"> * actions, binary triggers, and various forms of completions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Non-nullness of field result (set via CAS) indicates done.  An</span></span><br><span class="line"><span class="comment"> * AltResult is used to box null as a result, as well as to hold</span></span><br><span class="line"><span class="comment"> * exceptions.  Using a single field makes completion simple to</span></span><br><span class="line"><span class="comment"> * detect and trigger.  Encoding and decoding is straightforward</span></span><br><span class="line"><span class="comment"> * but adds to the sprawl of trapping and associating exceptions</span></span><br><span class="line"><span class="comment"> * with targets.  Minor simplifications rely on (static) NIL (to</span></span><br><span class="line"><span class="comment"> * box null results) being the only AltResult with a null</span></span><br><span class="line"><span class="comment"> * exception field, so we don't usually need explicit comparisons.</span></span><br><span class="line"><span class="comment"> * Even though some of the generics casts are unchecked (see</span></span><br><span class="line"><span class="comment"> * SuppressWarnings annotations), they are placed to be</span></span><br><span class="line"><span class="comment"> * appropriate even if checked.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Dependent actions are represented by Completion objects linked</span></span><br><span class="line"><span class="comment"> * as Treiber stacks headed by field "stack". There are Completion</span></span><br><span class="line"><span class="comment"> * classes for each kind of action, grouped into single-input</span></span><br><span class="line"><span class="comment"> * (UniCompletion), two-input (BiCompletion), projected</span></span><br><span class="line"><span class="comment"> * (BiCompletions using either (not both) of two inputs), shared</span></span><br><span class="line"><span class="comment"> * (CoCompletion, used by the second of two sources), zero-input</span></span><br><span class="line"><span class="comment"> * source actions, and Signallers that unblock waiters. Class</span></span><br><span class="line"><span class="comment"> * Completion extends ForkJoinTask to enable async execution</span></span><br><span class="line"><span class="comment"> * (adding no space overhead because we exploit its "tag" methods</span></span><br><span class="line"><span class="comment"> * to maintain claims). It is also declared as Runnable to allow</span></span><br><span class="line"><span class="comment"> * usage with arbitrary executors.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Support for each kind of CompletionStage relies on a separate</span></span><br><span class="line"><span class="comment"> * class, along with two CompletableFuture methods:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * * A Completion class with name X corresponding to function,</span></span><br><span class="line"><span class="comment"> *   prefaced with "Uni", "Bi", or "Or". Each class contains</span></span><br><span class="line"><span class="comment"> *   fields for source(s), actions, and dependent. They are</span></span><br><span class="line"><span class="comment"> *   boringly similar, differing from others only with respect to</span></span><br><span class="line"><span class="comment"> *   underlying functional forms. We do this so that users don't</span></span><br><span class="line"><span class="comment"> *   encounter layers of adaptors in common usages. We also</span></span><br><span class="line"><span class="comment"> *   include "Relay" classes/methods that don't correspond to user</span></span><br><span class="line"><span class="comment"> *   methods; they copy results from one stage to another.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * * Boolean CompletableFuture method x(...) (for example</span></span><br><span class="line"><span class="comment"> *   uniApply) takes all of the arguments needed to check that an</span></span><br><span class="line"><span class="comment"> *   action is triggerable, and then either runs the action or</span></span><br><span class="line"><span class="comment"> *   arranges its async execution by executing its Completion</span></span><br><span class="line"><span class="comment"> *   argument, if present. The method returns true if known to be</span></span><br><span class="line"><span class="comment"> *   complete.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * * Completion method tryFire(int mode) invokes the associated x</span></span><br><span class="line"><span class="comment"> *   method with its held arguments, and on success cleans up.</span></span><br><span class="line"><span class="comment"> *   The mode argument allows tryFire to be called twice (SYNC,</span></span><br><span class="line"><span class="comment"> *   then ASYNC); the first to screen and trap exceptions while</span></span><br><span class="line"><span class="comment"> *   arranging to execute, and the second when called from a</span></span><br><span class="line"><span class="comment"> *   task. (A few classes are not used async so take slightly</span></span><br><span class="line"><span class="comment"> *   different forms.)  The claim() callback suppresses function</span></span><br><span class="line"><span class="comment"> *   invocation if already claimed by another thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * * CompletableFuture method xStage(...) is called from a public</span></span><br><span class="line"><span class="comment"> *   stage method of CompletableFuture x. It screens user</span></span><br><span class="line"><span class="comment"> *   arguments and invokes and/or creates the stage object.  If</span></span><br><span class="line"><span class="comment"> *   not async and x is already complete, the action is run</span></span><br><span class="line"><span class="comment"> *   immediately.  Otherwise a Completion c is created, pushed to</span></span><br><span class="line"><span class="comment"> *   x's stack (unless done), and started or triggered via</span></span><br><span class="line"><span class="comment"> *   c.tryFire.  This also covers races possible if x completes</span></span><br><span class="line"><span class="comment"> *   while pushing.  Classes with two inputs (for example BiApply)</span></span><br><span class="line"><span class="comment"> *   deal with races across both while pushing actions.  The</span></span><br><span class="line"><span class="comment"> *   second completion is a CoCompletion pointing to the first,</span></span><br><span class="line"><span class="comment"> *   shared so that at most one performs the action.  The</span></span><br><span class="line"><span class="comment"> *   multiple-arity methods allOf and anyOf do this pairwise to</span></span><br><span class="line"><span class="comment"> *   form trees of completions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that the generic type parameters of methods vary according</span></span><br><span class="line"><span class="comment"> * to whether "this" is a source, dependent, or completion.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Method postComplete is called upon completion unless the target</span></span><br><span class="line"><span class="comment"> * is guaranteed not to be observable (i.e., not yet returned or</span></span><br><span class="line"><span class="comment"> * linked). Multiple threads can call postComplete, which</span></span><br><span class="line"><span class="comment"> * atomically pops each dependent action, and tries to trigger it</span></span><br><span class="line"><span class="comment"> * via method tryFire, in NESTED mode.  Triggering can propagate</span></span><br><span class="line"><span class="comment"> * recursively, so NESTED mode returns its completed dependent (if</span></span><br><span class="line"><span class="comment"> * one exists) for further processing by its caller (see method</span></span><br><span class="line"><span class="comment"> * postFire).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Blocking methods get() and join() rely on Signaller Completions</span></span><br><span class="line"><span class="comment"> * that wake up waiting threads.  The mechanics are similar to</span></span><br><span class="line"><span class="comment"> * Treiber stack wait-nodes used in FutureTask, Phaser, and</span></span><br><span class="line"><span class="comment"> * SynchronousQueue. See their internal documentation for</span></span><br><span class="line"><span class="comment"> * algorithmic details.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Without precautions, CompletableFutures would be prone to</span></span><br><span class="line"><span class="comment"> * garbage accumulation as chains of Completions build up, each</span></span><br><span class="line"><span class="comment"> * pointing back to its sources. So we null out fields as soon as</span></span><br><span class="line"><span class="comment"> * possible (see especially method Completion.detach). The</span></span><br><span class="line"><span class="comment"> * screening checks needed anyway harmlessly ignore null arguments</span></span><br><span class="line"><span class="comment"> * that may have been obtained during races with threads nulling</span></span><br><span class="line"><span class="comment"> * out fields.  We also try to unlink fired Completions from</span></span><br><span class="line"><span class="comment"> * stacks that might never be popped (see method postFire).</span></span><br><span class="line"><span class="comment"> * Completion fields need not be declared as final or volatile</span></span><br><span class="line"><span class="comment"> * because they are only visible to other threads upon safe</span></span><br><span class="line"><span class="comment"> * publication.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>原文档如上所示，为了翻译软件友好，我们需要去除注释/**/，将断行还原成一行。</p><h3 id="去除注释"><a class="header-anchor" href="#去除注释"></a>去除注释</h3><p>control + v 进入列模式，shift + G选至最后一行，方向键调节，d 删除（如果还发现有少量注释，如法炮制一并删除即可）</p><p><img src="/2019/07/18/使用vim的宏录制功能格式化注释文档/%E6%B8%85%E9%99%A4%E6%B3%A8%E9%87%8A.gif" alt="清除注释"></p><h3 id="断行还原成一行"><a class="header-anchor" href="#断行还原成一行"></a>断行还原成一行</h3><p>normal 模式qa, 定位到第二行，i 键进入插入模式，$定位到行首，backspace 删除，此时光标在首行末尾，空格一次（添加空格，防止连词），esc 键退出插入模式，q 键结束录制。此时操作序列已经录制完了，<s>待处理一共 105 行，那么执行 104 次重复即可，所以输入 104@a，</s>  因为有空行的存在，为了不破坏段的效果，这里需要计算好每段的行数-1 次重复，然后迅速定位到下一段（即 段行数-1@a），如法炮制即可。</p><p><img src="/2019/07/18/使用vim的宏录制功能格式化注释文档/%E6%96%AD%E8%A1%8C%E8%BF%98%E5%8E%9F%E6%88%90%E4%B8%80%E8%A1%8C.gif" alt="断行还原成一行"></p><h3 id="效果如下"><a class="header-anchor" href="#效果如下"></a>效果如下</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Overview:</span><br><span class="line"></span><br><span class="line">A CompletableFuture may have dependent completion actions, collected in a linked stack. It atomically completes by CASing a result field, and then pops off and runs those actions. This applies across normal vs exceptional outcomes, sync vs async actions, binary triggers, and various forms of completions.</span><br><span class="line">  </span><br><span class="line">Non-<span class="function">nullness of field <span class="title">result</span> <span class="params">(set via CAS)</span> indicates done. An AltResult is used to box <span class="keyword">null</span> as a result, as well as to hold exceptions. Using a single field makes completion simple to detect and trigger. Encoding and decoding is straightforward but adds to the sprawl of trapping and associating exceptions with targets. Minor simplifications rely <span class="title">on</span> <span class="params">(<span class="keyword">static</span>)</span> <span class="title">NIL</span> <span class="params">(to box <span class="keyword">null</span> results)</span> being the only AltResult with a <span class="keyword">null</span> exception field, so we don't usually need explicit comparisons. Even though some of the generics casts are <span class="title">unchecked</span> <span class="params">(see SuppressWarnings annotations)</span>, they are placed to be appropriate even <span class="keyword">if</span> checked.</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">Dependent actions are represented by Completion objects linked as Treiber stacks headed by field "stack". There are Completion classes <span class="keyword">for</span> each kind of action, grouped into single-<span class="title">input</span> <span class="params">(UniCompletion)</span>, two-<span class="title">input</span> <span class="params">(BiCompletion)</span>, <span class="title">projected</span> <span class="params">(BiCompletions using either (not both)</span> of two inputs), <span class="title">shared</span> <span class="params">(CoCompletion, used by the second of two sources)</span>, zero-input source actions, and Signallers that unblock waiters. Class Completion extends ForkJoinTask to enable async <span class="title">execution</span> <span class="params">(adding no space overhead because we exploit its <span class="string">"tag"</span> methods to maintain claims)</span>. It is also declared as Runnable to allow usage with arbitrary executors.</span></span><br><span class="line"><span class="function">Support <span class="keyword">for</span> each kind of CompletionStage relies on a separate class, along with two CompletableFuture methods:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">* A Completion class with name X corresponding to function, prefaced with "Uni", "Bi", or "Or". Each class contains fields <span class="keyword">for</span> <span class="title">source</span><span class="params">(s)</span>, actions, and dependent. They are boringly similar, differing from others only with respect to underlying functional forms. We <span class="keyword">do</span> <span class="keyword">this</span> so that users don't encounter layers of adaptors in common usages. We also include "Relay" classes/methods that don't correspond to user methods</span>; they copy results from one stage to another.</span><br><span class="line">  </span><br><span class="line">* <span class="function">Boolean CompletableFuture method <span class="title">x</span><span class="params">(...)</span> <span class="params">(<span class="keyword">for</span> example uniApply)</span> takes all of the arguments needed to check that an action is triggerable, and then either runs the action or arranges its async execution by executing its Completion argument, <span class="keyword">if</span> present. The method returns <span class="keyword">true</span> <span class="keyword">if</span> known to be complete.</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">* Completion method <span class="title">tryFire</span><span class="params">(<span class="keyword">int</span> mode)</span> invokes the associated x method with its held arguments, and on success cleans up. The mode argument allows tryFire to be called <span class="title">twice</span> <span class="params">(SYNC, then ASYNC)</span></span>; the first to screen and trap exceptions <span class="keyword">while</span> arranging to execute, and the second when called from a task. (A few classes are not used async so take slightly different forms.) <span class="function">The <span class="title">claim</span><span class="params">()</span> callback suppresses function invocation <span class="keyword">if</span> already claimed by another thread.</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">* CompletableFuture method <span class="title">xStage</span><span class="params">(...)</span> is called from a <span class="keyword">public</span> stage method of CompletableFuture x. It screens user arguments and invokes and/or creates the stage object. If not async and x is already complete, the action is run immediately. Otherwise a Completion c is created, pushed to x's <span class="title">stack</span> <span class="params">(unless done)</span>, and started or triggered via c.tryFire. This also covers races possible <span class="keyword">if</span> x completes <span class="keyword">while</span> pushing. Classes with two <span class="title">inputs</span> <span class="params">(<span class="keyword">for</span> example BiApply)</span> deal with races across both <span class="keyword">while</span> pushing actions. The second completion is a CoCompletion pointing to the first, shared so that at most one performs the action. The multiple-arity methods allOf and anyOf <span class="keyword">do</span> <span class="keyword">this</span> pairwise to form trees of completions.</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">Note that the generic type parameters of methods vary according to whether "<span class="keyword">this</span>" is a source, dependent, or completion.</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">Method postComplete is called upon completion unless the target is guaranteed not to be <span class="title">observable</span> <span class="params">(i.e., not yet returned or linked)</span>. Multiple threads can call postComplete, which atomically pops each dependent action, and tries to trigger it via method tryFire, in NESTED mode. Triggering can propagate recursively, so NESTED mode returns its completed <span class="title">dependent</span> <span class="params">(<span class="keyword">if</span> one exists)</span> <span class="keyword">for</span> further processing by its <span class="title">caller</span> <span class="params">(see method postFire)</span>.</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">Blocking methods <span class="title">get</span><span class="params">()</span> and <span class="title">join</span><span class="params">()</span> rely on Signaller Completions that wake up waiting threads. The mechanics are similar to Treiber stack wait-nodes used in FutureTask, Phaser, and SynchronousQueue. See their internal documentation <span class="keyword">for</span> algorithmic details.</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">Without precautions, CompletableFutures would be prone to garbage accumulation as chains of Completions build up, each pointing back to its sources. So we <span class="keyword">null</span> out fields as soon as <span class="title">possible</span> <span class="params">(see especially method Completion.detach)</span>. The screening checks needed anyway harmlessly ignore <span class="keyword">null</span> arguments that may have been obtained during races with threads nulling out fields. We also <span class="keyword">try</span> to unlink fired Completions from stacks that might never be <span class="title">popped</span> <span class="params">(see method postFire)</span>. Completion fields need not be declared as <span class="keyword">final</span> or <span class="keyword">volatile</span> because they are only visible to other threads upon safe publication</span></span><br></pre></td></tr></table></figure><p><strong>一个更骚的操作</strong></p><p>仔细观察发现，原文档和标准的 javadoc 非常相似，仅仅是开头少了一个*，如果在空行加上分段标签</p><p>，那岂不是直接可以使用 idea 渲染成标准 javadoc 了，美滋滋：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Overview:</span></span><br><span class="line"><span class="comment"> *&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * A CompletableFuture may have dependent completion actions,</span></span><br><span class="line"><span class="comment"> * collected in a linked stack. It atomically completes by CASing</span></span><br><span class="line"><span class="comment"> * a result field, and then pops off and runs those actions. This</span></span><br><span class="line"><span class="comment"> * applies across normal vs exceptional outcomes, sync vs async</span></span><br><span class="line"><span class="comment"> * actions, binary triggers, and various forms of completions.</span></span><br><span class="line"><span class="comment"> *&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Non-nullness of field result (set via CAS) indicates done.  An</span></span><br><span class="line"><span class="comment"> * AltResult is used to box null as a result, as well as to hold</span></span><br><span class="line"><span class="comment"> * exceptions.  Using a single field makes completion simple to</span></span><br><span class="line"><span class="comment"> * detect and trigger.  Encoding and decoding is straightforward</span></span><br><span class="line"><span class="comment"> * but adds to the sprawl of trapping and associating exceptions</span></span><br><span class="line"><span class="comment"> * with targets.  Minor simplifications rely on (static) NIL (to</span></span><br><span class="line"><span class="comment"> * box null results) being the only AltResult with a null</span></span><br><span class="line"><span class="comment"> * exception field, so we don't usually need explicit comparisons.</span></span><br><span class="line"><span class="comment"> * Even though some of the generics casts are unchecked (see</span></span><br><span class="line"><span class="comment"> * SuppressWarnings annotations), they are placed to be</span></span><br><span class="line"><span class="comment"> * appropriate even if checked.</span></span><br><span class="line"><span class="comment"> *&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Dependent actions are represented by Completion objects linked</span></span><br><span class="line"><span class="comment"> * as Treiber stacks headed by field "stack". There are Completion</span></span><br><span class="line"><span class="comment"> * classes for each kind of action, grouped into single-input</span></span><br><span class="line"><span class="comment"> * (UniCompletion), two-input (BiCompletion), projected</span></span><br><span class="line"><span class="comment"> * (BiCompletions using either (not both) of two inputs), shared</span></span><br><span class="line"><span class="comment"> * (CoCompletion, used by the second of two sources), zero-input</span></span><br><span class="line"><span class="comment"> * source actions, and Signallers that unblock waiters. Class</span></span><br><span class="line"><span class="comment"> * Completion extends ForkJoinTask to enable async execution</span></span><br><span class="line"><span class="comment"> * (adding no space overhead because we exploit its "tag" methods</span></span><br><span class="line"><span class="comment"> * to maintain claims). It is also declared as Runnable to allow</span></span><br><span class="line"><span class="comment"> * usage with arbitrary executors.</span></span><br><span class="line"><span class="comment"> *&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Support for each kind of CompletionStage relies on a separate</span></span><br><span class="line"><span class="comment"> * class, along with two CompletableFuture methods:</span></span><br><span class="line"><span class="comment"> *&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * * A Completion class with name X corresponding to function,</span></span><br><span class="line"><span class="comment"> *   prefaced with "Uni", "Bi", or "Or". Each class contains</span></span><br><span class="line"><span class="comment"> *   fields for source(s), actions, and dependent. They are</span></span><br><span class="line"><span class="comment"> *   boringly similar, differing from others only with respect to</span></span><br><span class="line"><span class="comment"> *   underlying functional forms. We do this so that users don't</span></span><br><span class="line"><span class="comment"> *   encounter layers of adaptors in common usages. We also</span></span><br><span class="line"><span class="comment"> *   include "Relay" classes/methods that don't correspond to user</span></span><br><span class="line"><span class="comment"> *   methods; they copy results from one stage to another.</span></span><br><span class="line"><span class="comment"> *&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * * Boolean CompletableFuture method x(...) (for example</span></span><br><span class="line"><span class="comment"> *   uniApply) takes all of the arguments needed to check that an</span></span><br><span class="line"><span class="comment"> *   action is triggerable, and then either runs the action or</span></span><br><span class="line"><span class="comment"> *   arranges its async execution by executing its Completion</span></span><br><span class="line"><span class="comment"> *   argument, if present. The method returns true if known to be</span></span><br><span class="line"><span class="comment"> *   complete.</span></span><br><span class="line"><span class="comment"> *&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * * Completion method tryFire(int mode) invokes the associated x</span></span><br><span class="line"><span class="comment"> *   method with its held arguments, and on success cleans up.</span></span><br><span class="line"><span class="comment"> *   The mode argument allows tryFire to be called twice (SYNC,</span></span><br><span class="line"><span class="comment"> *   then ASYNC); the first to screen and trap exceptions while</span></span><br><span class="line"><span class="comment"> *   arranging to execute, and the second when called from a</span></span><br><span class="line"><span class="comment"> *   task. (A few classes are not used async so take slightly</span></span><br><span class="line"><span class="comment"> *   different forms.)  The claim() callback suppresses function</span></span><br><span class="line"><span class="comment"> *   invocation if already claimed by another thread.</span></span><br><span class="line"><span class="comment"> *&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * * CompletableFuture method xStage(...) is called from a public</span></span><br><span class="line"><span class="comment"> *   stage method of CompletableFuture x. It screens user</span></span><br><span class="line"><span class="comment"> *   arguments and invokes and/or creates the stage object.  If</span></span><br><span class="line"><span class="comment"> *   not async and x is already complete, the action is run</span></span><br><span class="line"><span class="comment"> *   immediately.  Otherwise a Completion c is created, pushed to</span></span><br><span class="line"><span class="comment"> *   x's stack (unless done), and started or triggered via</span></span><br><span class="line"><span class="comment"> *   c.tryFire.  This also covers races possible if x completes</span></span><br><span class="line"><span class="comment"> *   while pushing.  Classes with two inputs (for example BiApply)</span></span><br><span class="line"><span class="comment"> *   deal with races across both while pushing actions.  The</span></span><br><span class="line"><span class="comment"> *   second completion is a CoCompletion pointing to the first,</span></span><br><span class="line"><span class="comment"> *   shared so that at most one performs the action.  The</span></span><br><span class="line"><span class="comment"> *   multiple-arity methods allOf and anyOf do this pairwise to</span></span><br><span class="line"><span class="comment"> *   form trees of completions.</span></span><br><span class="line"><span class="comment"> *&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Note that the generic type parameters of methods vary according</span></span><br><span class="line"><span class="comment"> * to whether "this" is a source, dependent, or completion.</span></span><br><span class="line"><span class="comment"> *&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Method postComplete is called upon completion unless the target</span></span><br><span class="line"><span class="comment"> * is guaranteed not to be observable (i.e., not yet returned or</span></span><br><span class="line"><span class="comment"> * linked). Multiple threads can call postComplete, which</span></span><br><span class="line"><span class="comment"> * atomically pops each dependent action, and tries to trigger it</span></span><br><span class="line"><span class="comment"> * via method tryFire, in NESTED mode.  Triggering can propagate</span></span><br><span class="line"><span class="comment"> * recursively, so NESTED mode returns its completed dependent (if</span></span><br><span class="line"><span class="comment"> * one exists) for further processing by its caller (see method</span></span><br><span class="line"><span class="comment"> * postFire).</span></span><br><span class="line"><span class="comment"> *&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Blocking methods get() and join() rely on Signaller Completions</span></span><br><span class="line"><span class="comment"> * that wake up waiting threads.  The mechanics are similar to</span></span><br><span class="line"><span class="comment"> * Treiber stack wait-nodes used in FutureTask, Phaser, and</span></span><br><span class="line"><span class="comment"> * SynchronousQueue. See their internal documentation for</span></span><br><span class="line"><span class="comment"> * algorithmic details.</span></span><br><span class="line"><span class="comment"> *&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Without precautions, CompletableFutures would be prone to</span></span><br><span class="line"><span class="comment"> * garbage accumulation as chains of Completions build up, each</span></span><br><span class="line"><span class="comment"> * pointing back to its sources. So we null out fields as soon as</span></span><br><span class="line"><span class="comment"> * possible (see especially method Completion.detach). The</span></span><br><span class="line"><span class="comment"> * screening checks needed anyway harmlessly ignore null arguments</span></span><br><span class="line"><span class="comment"> * that may have been obtained during races with threads nulling</span></span><br><span class="line"><span class="comment"> * out fields.  We also try to unlink fired Completions from</span></span><br><span class="line"><span class="comment"> * stacks that might never be popped (see method postFire).</span></span><br><span class="line"><span class="comment"> * Completion fields need not be declared as final or volatile</span></span><br><span class="line"><span class="comment"> * because they are only visible to other threads upon safe</span></span><br><span class="line"><span class="comment"> * publication.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后按control + j查看文档，哈哈：</p><p><img src="/2019/07/18/使用vim的宏录制功能格式化注释文档/%E6%B8%B2%E6%9F%93%E5%90%8E%E7%9A%84%E6%95%88%E6%9E%9C.png" alt="渲染后的效果"></p><h3 id="一个更骚的操作plus"><a class="header-anchor" href="#一个更骚的操作plus"></a>一个更骚的操作PLUS</h3><p>直接开头加上一个*，然后option + command + l 格式化文档，你会发现 idea 自动给你添加 p 标签，太爽了。</p><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>vim 操作更加灵活，适应不同的格式化文本需求，不过针对笔者的 case，最简单的方法是：idea 里，新建一个方法，把要格式化的注释拷贝过去，首行添加一个*，格式化文档即可。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;起因&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;
&lt;p&gt;经常看各类 javadoc 发现有一类 doc 并没有被做成标准的 doc 格式，直接复制出来想翻译一下，需要做一些预处理，比如删除注释、合并断行，前者各种编辑器的列模式搞定，后者就坑爹了，之前是手工一行一行的删除换行符，然后加空格的，非常坑爹。对于这类重复性操作，使用 vim 的宏录制就再好不过了。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="源码剖析" scheme="http://houqian.github.io/tags/源码剖析/"/>
    
    <category term="心得" scheme="http://houqian.github.io/tags/心得/"/>
    
  </entry>
  
  <entry>
    <title>一张图澄清架构设计模式</title>
    <link href="http://houqian.github.io/2019/06/01/%E4%B8%80%E5%BC%A0%E5%9B%BE%E6%BE%84%E6%B8%85%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://houqian.github.io/2019/06/01/%E4%B8%80%E5%BC%A0%E5%9B%BE%E6%BE%84%E6%B8%85%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2019-06-01T14:29:20.000Z</published>
    <updated>2019-06-19T14:37:22.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="/2019/06/01/一张图澄清架构设计模式/%E4%B8%80%E5%BC%A0%E5%9B%BE%E6%BE%84%E6%B8%85%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.svg" alt="一张图澄清架构设计模式"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;&lt;img src=&quot;/2019/06/01/一张图澄清架构设计模式/%E4%</summary>
      
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="设计" scheme="http://houqian.github.io/tags/设计/"/>
    
    <category term="架构模式" scheme="http://houqian.github.io/tags/架构模式/"/>
    
  </entry>
  
  <entry>
    <title>聊聊Kafka</title>
    <link href="http://houqian.github.io/2018/10/21/%E8%81%8A%E8%81%8AKafka/"/>
    <id>http://houqian.github.io/2018/10/21/%E8%81%8A%E8%81%8AKafka/</id>
    <published>2018-10-21T11:13:31.000Z</published>
    <updated>2021-06-03T15:19:18.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="/2018/10/21/聊聊Kafka/Canva-Latte-Art-and-Leaf-on-Brown-Surface.jpg" alt=""></p><h2 id="背景"><a class="header-anchor" href="#背景"></a>背景</h2><p>kafka 的诞生，是为了解决 linkedin 的数据管道问题，期初 linkedin 采用了 ActiveMQ 来进行数据交换，大约是在 2010 年前后，那时的 ActiveMQ 还远远无法满足 linkedin 对数据传递系统的要求，经常由于各种缺陷而导致消息阻塞或者服务无法正常访问，为了能够解决这个问题，linkedin 决定研发自己的消息传递系统，当时 linkedin 的首席架构师 jay kreps 便开始组织团队进行消息传递系统的研发；</p><a id="more"></a><h3 id="kafka-名字的由来"><a class="header-anchor" href="#kafka-名字的由来"></a>kafka 名字的由来</h3><p>kafka 的架构师 jay kreps 对于 kafka 的名称由来是这样讲的，由于 jay kreps 非常喜欢 franz kafka, 并且觉得 kafka 这个名字很酷，因此取了个和消息传递系统完全不相干的名称 kafka，取名字是并没有特别的含义。</p><h3 id="kafka-的设计目标"><a class="header-anchor" href="#kafka-的设计目标"></a>kafka 的设计目标</h3><p>使用推送和拉取模式 实现生产者和消费者的解耦；<br>微消息系统中的消息提供数据持久化，以便支持多个消费者；<br>系统可以随着数据流的增长进行横向扩展；<br>通过系统优化实现高吞吐量；</p><h3 id="kafka-历史"><a class="header-anchor" href="#kafka-历史"></a>kafka 历史</h3><p>2010 年底，开源到 github，初始版本为 0.7.0；<br>2011 年 7 月因为备受关注，被纳入 apache 孵化器项目；<br>2012 年 10 月，kafka 从 apache 孵化器项目毕业，成为 apache 顶级项目；<br>2014 年，jay kreps, neha narkhede, jun rao 离开 linkedin,  成立 confluent,  此后 linkedin 和 confluent 成为 kafka 的核心贡组织，致力于将 kafka 推广应用</p><h2 id="应用场景"><a class="header-anchor" href="#应用场景"></a>应用场景</h2><p><img src="/2018/10/21/聊聊Kafka/kafka-apis.png" alt="kafka-apis"></p><h3 id="消息系统"><a class="header-anchor" href="#消息系统"></a>消息系统</h3><p>Kafka 作为一款优秀的消息系统，具有高吞吐量、内置的分区、备份冗余分布式等特点，为大规模消息处理提供了一种很好的解决方案。</p><h3 id="应用监控"><a class="header-anchor" href="#应用监控"></a>应用监控</h3><p>利用 Kafka 采集应用程序和服务器健康相关的指标，如 CPU 占用率、IO、内存、连接数、TPS、QPS 等，然后将指标信息进行处理，从而构建一个具有监控仪表盘、曲线图等可视化监控系统。例如，很多公司采用 Kafka 与 ELK（ElasticSearch、Logstash 和 Kibana）整合构建应用服务监控系统。</p><h3 id="网站用户行为追踪"><a class="header-anchor" href="#网站用户行为追踪"></a>网站用户行为追踪</h3><p>为了更好地了解用户行为、操作习惯，改善用户体验，进而对产品升级改进，将用户操作轨迹、内容等信息发送到 Kafka 集群上，通过 Hadoop、Spark 或 Strom 等进行数据分析处理，生成相应的统计报告，为推荐系统推荐对象建模提供数据源，进而为每个用户进行个性化推荐。</p><h3 id="流处理"><a class="header-anchor" href="#流处理"></a>流处理</h3><p>需要将已收集的流数据提供给其他流式计算框架进行处理，用 Kafka 收集流数据是一个不错的选择，而且当前版本的 Kafka 提供了 Kafka Streams 支持对流数据的处理。</p><h3 id="持久性日志"><a class="header-anchor" href="#持久性日志"></a>持久性日志</h3><p>Kafka 可以为外部系统提供一种持久性日志的分布式系统。日志可以在多个节点间进行备份，Kafka 为故障节点数据恢复提供了一种重新同步的机制。同时，Kafka 很方便与 HDFS 和 Flume 进行整合，这样就方便将 Kafka 采集的数据持久化到其他外部系统。</p><h2 id="基本概念"><a class="header-anchor" href="#基本概念"></a>基本概念</h2><p>Kafka 是一种高效的分布式消息系统。在性能上，它具有内置的数据冗余度与弹性，也具有高吞吐能力和可扩展性。<br>在功能上，它支持自动化的数据保存限制，能够以 “流” 的方式为应用提供数据转换，以及按照 “键 - 值（key-value）” 的建模关系 “压缩” 数据流。</p><h3 id="message-消息"><a class="header-anchor" href="#message-消息"></a>Message（消息）</h3><p>Kafka 中的一条记录或数据单位。每条消息都有一个键和对应的一个值，有时还会有可选的消息头。</p><h3 id="producer-生产者"><a class="header-anchor" href="#producer-生产者"></a>Producer（生产者）</h3><p>Producer 将消息发布到 Kafka 的 topics 上。Producer 决定向 topic 分区的发布方式，如：轮询的随机方法、或基于消息键（key）的分区算法。</p><h3 id="broker-代理"><a class="header-anchor" href="#broker-代理"></a>Broker（代理）</h3><p>Kafka 以分布式系统或集群的方式运行。那么群集中的每个节点称为一个 Broker。</p><h3 id="topic-主题"><a class="header-anchor" href="#topic-主题"></a>Topic（主题）</h3><p>Topic 是那些被发布的数据记录或消息的一种类别。消费者通过订阅 Topic，来读取写给它们的数据。</p><h3 id="topic-partition-主题分区"><a class="header-anchor" href="#topic-partition-主题分区"></a>Topic Partition（主题分区）</h3><p>不同的 Topic 被分为不同的分区，而每一条消息都会被分配一个 Offset，通常每个分区都会被复制至少一到两次。<br>每个分区都有一个 Leader 和存放在各个 Follower 上的一到多个副本（即：数据的副本），此法可防止某个 Broker 的失效。<br>群集中的所有 Broker 都可以作为 Leader 和 Follower，但是一个 Broker 最多只能有一个 Topic Partition 的副本。Leader 可被用来进行所有的读写操作。</p><h3 id="offset-偏移量"><a class="header-anchor" href="#offset-偏移量"></a>Offset（偏移量）</h3><p>单个分区中的每一条消息都被分配一个 Offset，它是一个单调递增的整型数，可用来作为分区中消息的唯一标识符。</p><h3 id="consumer-消费者"><a class="header-anchor" href="#consumer-消费者"></a>Consumer（消费者）</h3><p>Consumer 通过订阅 Topic partition，来读取 Kafka 的各种 Topic 消息。然后，消费类应用处理会收到消息，以完成指定的工作。</p><h3 id="consumer-group-消费组"><a class="header-anchor" href="#consumer-group-消费组"></a>Consumer group（消费组）</h3><p>Consumer 可以按照 Consumer group 进行逻辑划分。Topic Partition 被均衡地分配给组中的所有Consumers。因此，在同一个 Consumer group 中，所有的 Consumer 都以负载均衡的方式运作。换言之，同一组中的每一个 Consumer 都能看到每一条消息。如果某个 Consumer 处于 “离线” 状态的话，那么该分区将会被分配给同组中的另一个 Consumer。这就是所谓的 “再均衡（rebalance）”。当然，如果组中的 Consumer 多于分区数，则某些 Consumer 将会处于闲置的状态。相反，如果组中的 Consumer 少于分区数，则某些 Consumer 会获得来自一个以上分区的消息。</p><h3 id="lag-延迟"><a class="header-anchor" href="#lag-延迟"></a>Lag（延迟）</h3><p>当 Consumer 的速度跟不上消息的产生速度时，Consumer 就会因为无法从分区中读取消息，而产生延迟。</p><p>延迟表示为分区头后面的 Offset 数量。从延迟状态（到 “追赶上来”）恢复正常所需要的时间，取决于 Consumer 每秒能够应对的消息速度。</p><p><strong>其公式如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time = messages / (consume rate per second - produce rate per second)</span><br></pre></td></tr></table></figure><h2 id="架构原理"><a class="header-anchor" href="#架构原理"></a>架构原理</h2><p>对于 Kafka 的架构原理，我们先提出如下几个问题：</p><ul><li>Kafka 的 topic 和分区内部是如何存储的，有什么特点？</li><li>与传统的消息系统相比，Kafka 的消费模型有什么优点？</li><li>Kafka 如何实现分布式的数据存储与数据读取？</li></ul><h3 id="架构图"><a class="header-anchor" href="#架构图"></a>架构图</h3><p><strong>进程视角</strong></p><p><img src="/2018/10/21/聊聊Kafka/ndsa_0401.png" alt="Image result for kafka architecture"></p><p><strong>主题视角</strong></p><p><img src="/2018/10/21/聊聊Kafka/ndsa_0402.png" alt="ndsa 0402"></p><h3 id="消费模型"><a class="header-anchor" href="#消费模型"></a>消费模型</h3><p>消息由生产者发送到 Kafka 集群后，会被消费者消费。一般来说我们的消费模型有两种：</p><ul><li><strong>推送模型 (Push)</strong></li><li><strong>拉取模型 (Pull)</strong></li></ul><p>基于推送模型的消息系统，由消息代理记录消费状态。消息代理将消息推送到消费者后，标记这条消息为已经被消费，但是这种方式无法很好地保证消费的处理语义。</p><p>比如当我们已经把消息发送给消费者之后，由于消费进程挂掉或者由于网络原因没有收到这条消息，如果我们在消费代理将其标记为已消费，这个消息就永久丢失了。</p><p>如果我们利用生产者收到消息后回复这种方法，消息代理需要记录消费状态，这种不可取。</p><p>如果采用 Push，消息消费的速率就完全由消费代理控制，一旦消费者发生阻塞，就会出现问题。</p><p>Kafka 采取拉取模型 (Poll)，由自己控制消费速度，以及消费的进度，消费者可以按照任意的偏移量进行消费。<br>比如消费者可以消费已经消费过的消息进行重新处理，或者消费最近的消息等等。</p><h3 id="网络模型"><a class="header-anchor" href="#网络模型"></a>网络模型</h3><h4 id="kafka-client：单线程-selector"><a class="header-anchor" href="#kafka-client：单线程-selector"></a>Kafka Client：单线程 Selector</h4><p><img src="/2018/10/21/聊聊Kafka/640.jpeg" alt="img"></p><p>单线程模式适用于并发链接数小，逻辑简单，数据量小。</p><p>在kafka中，consumer和producer都是使用的上面的单线程模式。这种模式不适合kafka的服务端，在服务端中请求处理过程比较复杂，会造成线程阻塞，一旦出现后续请求就会无法处理，会造成大量请求超时，引起雪崩。而在服务器中应该充分利用多线程来处理执行逻辑。</p><h4 id="kafka-server：多线程selector"><a class="header-anchor" href="#kafka-server：多线程selector"></a>Kafka server：多线程Selector</h4><p><img src="/2018/10/21/聊聊Kafka/640-20190703171420885.jpeg" alt="img"></p><p>在kafka服务端采用的是多线程的Selector模型，Acceptor运行在一个单独的线程中，对于读取操作的线程池中的线程都会在selector注册read事件，负责服务端读取请求的逻辑。成功读取后，将请求放入message queue共享队列中。然后在写线程池中，取出这个请求，对其进行逻辑处理，即使某个请求线程阻塞了，还有后续的县城从消息队列中获取请求并进行处理，在写线程中处理完逻辑处理，由于注册了OP_WIRTE事件，所以还需要对其发送响应。</p><h3 id="日志结构与数据存储"><a class="header-anchor" href="#日志结构与数据存储"></a>日志结构与数据存储</h3><p>Kafka中的消息是以主题（Topic）为基本单位进行组织的，各个主题之间相互独立。在这里主题只是一个逻辑上的抽象概念，而在实际数据文件的存储中，Kafka中的消息存储在物理上是以一个或多个分区（Partition）构成，每个分区对应本地磁盘上的一个文件夹，每个文件夹内包含了日志索引文件（“.index”和“.timeindex”）和日志数据文件（“.log”）两部分。分区数量可以在创建主题时指定，也可以在创建Topic后进行修改。</p><p>在Kafka中正是因为使用了分区（Partition）的设计模型，通过将主题（Topic）的消息打散到多个分区，并分布保存在不同的Kafka Broker节点上实现了消息处理的高吞吐量。其生产者和消费者都可以多线程地并行操作，而每个线程处理的是一个分区的数据。</p><p><img src="/2018/10/21/聊聊Kafka/log_anatomy.png" alt="log_anatomy"></p><p>同时，Kafka为了实现集群的高可用性，在每个Partition中可以设置有一个或者多个副本（Replica），分区的副本分布在不同的Broker节点上。同时，从副本中会选出一个副本作为Leader，Leader副本负责与客户端进行读写操作。而其他副本作为Follower会从Leader副本上进行数据同步。</p><h3 id="分区-副本的日志文件存储"><a class="header-anchor" href="#分区-副本的日志文件存储"></a>分区、副本的日志文件存储</h3><p>在三台虚拟机上搭建完成Kafka的集群后（Kafka Broker节点数量为3个），通过在Kafka Broker节点的/bin下执行以下的命令即可创建主题和指定数量的分区以及副本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kafka-topics.sh --create --zookeeper 10.154.0.73:2181 --replication-factor 3 --partitions  3 --topic kafka-topic-01</span><br></pre></td></tr></table></figure><p>创建完主题、分区和副本后可以查到出主题的状态（该方式主要列举了主题所有分区对应的副本以及ISR列表信息）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./kafka-topics.sh --describe --zookeeper 10.154.0.73:2181 --topic kafka-topic-01</span><br><span class="line">Topic:kafka-topic-01    PartitionCount:3    ReplicationFactor:3 Configs:</span><br><span class="line">    Topic: kafka-topic-01   Partition: 0    Leader: 1   Replicas: 1,2,0 Isr: 1,2,0</span><br><span class="line">    Topic: kafka-topic-01   Partition: 1    Leader: 2   Replicas: 2,0,1 Isr: 2,1,0</span><br><span class="line">    Topic: kafka-topic-01   Partition: 2    Leader: 0   Replicas: 0,1,2 Isr: 1,2,0</span><br></pre></td></tr></table></figure><p>通过实现一个简单的Kafka Producer的demo，即可完成生产者发送消息给Kafka Broker的功能。在使用Producer产生大量的消息后，可以看到部署集群的三台虚拟机在Kafka的config/server.properties配置文件中**“log.dirs”**指定的日志数据存储目录下存在三个分区目录，同时在每个分区目录下存在很多对应的日志数据文件和日志索引文件文件，具体如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1、分区目录文件</span></span><br><span class="line">drwxr-x--- 2 root root 4096 Jul 26 19:35 kafka-topic-01-0</span><br><span class="line">drwxr-x--- 2 root root 4096 Jul 24 20:15 kafka-topic-01-1</span><br><span class="line">drwxr-x--- 2 root root 4096 Jul 24 20:15 kafka-topic-01-2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">2、分区目录中的日志数据文件和日志索引文件</span></span><br><span class="line">-rw-r----- 1 root root 512K Jul 24 19:51 00000000000000000000.index</span><br><span class="line">-rw-r----- 1 root root 1.0G Jul 24 19:51 00000000000000000000.log</span><br><span class="line">-rw-r----- 1 root root 768K Jul 24 19:51 00000000000000000000.timeindex</span><br><span class="line">-rw-r----- 1 root root 512K Jul 24 20:03 00000000000022372103.index</span><br><span class="line">-rw-r----- 1 root root 1.0G Jul 24 20:03 00000000000022372103.log</span><br><span class="line">-rw-r----- 1 root root 768K Jul 24 20:03 00000000000022372103.timeindex</span><br><span class="line">-rw-r----- 1 root root 512K Jul 24 20:15 00000000000044744987.index</span><br><span class="line">-rw-r----- 1 root root 1.0G Jul 24 20:15 00000000000044744987.log</span><br><span class="line">-rw-r----- 1 root root 767K Jul 24 20:15 00000000000044744987.timeindex</span><br><span class="line">-rw-r----- 1 root root  10M Jul 24 20:21 00000000000067117761.index</span><br><span class="line">-rw-r----- 1 root root 511M Jul 24 20:21 00000000000067117761.log</span><br><span class="line">-rw-r----- 1 root root  10M Jul 24 20:21 00000000000067117761.timeindex</span><br></pre></td></tr></table></figure><p>由上面可以看出，每个分区在物理上对应一个文件夹，分区的命名规则为主题名后接“—”连接符，之后再接分区编号，分区编号从0开始，编号的最大值为分区总数减1。每个分区又有1至多个副本，分区的副本分布在集群的不同代理上，以提高可用性。从存储的角度上来说，分区的每个副本在逻辑上可以抽象为一个日志（Log）对象，即分区副本与日志对象是相对应的。下图是在三个Kafka Broker节点所组成的集群中分区的主/备份副本的物理分布情况图：</p><p><img src="/2018/10/21/聊聊Kafka/4325076-9629d061b519d09d.png" alt="img"></p><h2 id="日志索引和数据文件的存储结构"><a class="header-anchor" href="#日志索引和数据文件的存储结构"></a>日志索引和数据文件的存储结构</h2><p>在Kafka中，每个Log对象又可以划分为多个LogSegment文件，每个LogSegment文件包括一个日志数据文件和两个索引文件（偏移量索引文件和消息时间戳索引文件）。其中，每个LogSegment中的日志数据文件大小均相等（该日志数据文件的大小可以通过在Kafka Broker的config/server.properties配置文件的中的<code>log.segment.bytes</code>进行设置，默认为1G大小（1073741824字节），在顺序写入消息时如果超出该设定的阈值，将会创建一组新的日志数据和索引文件）。</p><p>Kafka将日志文件封装成一个FileMessageSet对象，将偏移量索引文件和消息时间戳索引文件分别封装成OffsetIndex和TimerIndex对象。Log和LogSegment均为逻辑概念，Log是对副本在Broker上存储文件的抽象，而LogSegment是对副本存储下每个日志分段的抽象，日志与索引文件才与磁盘上的物理存储相对应。下图为Kafka日志存储结构中的对象之间的对应关系图：</p><p><img src="/2018/10/21/聊聊Kafka/4325076-5c44f41d4009e305.png" alt="img"></p><p>为了进一步查看“.index”偏移量索引文件、“.timeindex”时间戳索引文件和“.log”日志数据文件，可以执行下面的命令将二进制分段的索引和日志数据文件内容转换为字符型文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、执行下面命令即可将日志数据文件内容dump出来</span></span><br><span class="line">./kafka-run-class.sh kafka.tools.DumpLogSegments --files /apps/svr/Kafka/kafkalogs/kafka-topic-01-0/00000000000022372103.log --print-data-log &gt; 00000000000022372103_txt.log</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">2、dump出来的具体日志数据内容</span></span><br><span class="line">Dumping /apps/svr/Kafka/kafkalogs/kafka-topic-01-0/00000000000022372103.log</span><br><span class="line">Starting offset: 22372103</span><br><span class="line">offset: 22372103 position: 0 CreateTime: 1532433067157 isvalid: true keysize: 4 valuesize: 36 magic: 2 compresscodec: NONE producerId: -1 producerEpoch: -1 sequence: -1 isTransactional: false headerKeys: [] key: 1 payload: 5d2697c5-d04a-4018-941d-881ac72ed9fd</span><br><span class="line">offset: 22372104 position: 0 CreateTime: 1532433067159 isvalid: true keysize: 4 valuesize: 36 magic: 2 compresscodec: NONE producerId: -1 producerEpoch: -1 sequence: -1 isTransactional: false headerKeys: [] key: 1 payload: 0ecaae7d-aba5-4dd5-90df-597c8b426b47</span><br><span class="line">offset: 22372105 position: 0 CreateTime: 1532433067159 isvalid: true keysize: 4 valuesize: 36 magic: 2 compresscodec: NONE producerId: -1 producerEpoch: -1 sequence: -1 isTransactional: false headerKeys: [] key: 1 payload: 87709dd9-596b-4cf4-80fa-d1609d1f2087</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">offset: 22372444 position: 16365 CreateTime: 1532433067166 isvalid: true keysize: 4 valuesize: 36 magic: 2 compresscodec: NONE producerId: -1 producerEpoch: -1 sequence: -1 isTransactional: false headerKeys: [] key: 1 payload: 8d52ec65-88cf-4afd-adf1-e940ed9a8ff9</span><br><span class="line">offset: 22372445 position: 16365 CreateTime: 1532433067168 isvalid: true keysize: 4 valuesize: 36 magic: 2 compresscodec: NONE producerId: -1 producerEpoch: -1 sequence: -1 isTransactional: false headerKeys: [] key: 1 payload: 5f5f6646-d0f5-4ad1-a257-4e3c38c74a92</span><br><span class="line">offset: 22372446 position: 16365 CreateTime: 1532433067168 isvalid: true keysize: 4 valuesize: 36 magic: 2 compresscodec: NONE producerId: -1 producerEpoch: -1 sequence: -1 isTransactional: false headerKeys: [] key: 1 payload: 51dd1da4-053e-4507-9ef8-68ef09d18cca</span><br><span class="line">offset: 22372447 position: 16365 CreateTime: 1532433067168 isvalid: true keysize: 4 valuesize: 36 magic: 2 compresscodec: NONE producerId: -1 producerEpoch: -1 sequence: -1 isTransactional: false headerKeys: [] key: 1 payload: 80d50a8e-0098-4748-8171-fd22d6af3c9b</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">offset: 22372785 position: 32730 CreateTime: 1532433067174 isvalid: true keysize: 4 valuesize: 36 magic: 2 compresscodec: NONE producerId: -1 producerEpoch: -1 sequence: -1 isTransactional: false headerKeys: [] key: 1 payload: db80eb79-8250-42e2-ad26-1b6cfccb5c00</span><br><span class="line">offset: 22372786 position: 32730 CreateTime: 1532433067176 isvalid: true keysize: 4 valuesize: 36 magic: 2 compresscodec: NONE producerId: -1 producerEpoch: -1 sequence: -1 isTransactional: false headerKeys: [] key: 1 payload: 51d95ab0-ab0d-4530-b1d1-05eeb9a6ff00</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">3、同样地，dump出来的具体偏移量索引内容</span></span><br><span class="line">Dumping /apps/svr/Kafka/kafkalogs/kafka-topic-01-0/00000000000022372103.index</span><br><span class="line">offset: 22372444 position: 16365</span><br><span class="line">offset: 22372785 position: 32730</span><br><span class="line">offset: 22373467 position: 65460</span><br><span class="line">offset: 22373808 position: 81825</span><br><span class="line">offset: 22374149 position: 98190</span><br><span class="line">offset: 22374490 position: 114555</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">4、dump出来的时间戳索引文件内容</span></span><br><span class="line">Dumping /apps/svr/Kafka/kafkalogs/kafka-topic-01-0/00000000000022372103.timeindex</span><br><span class="line">timestamp: 1532433067174 offset: 22372784</span><br><span class="line">timestamp: 1532433067191 offset: 22373466</span><br><span class="line">timestamp: 1532433067206 offset: 22373807</span><br><span class="line">timestamp: 1532433067214 offset: 22374148</span><br><span class="line">timestamp: 1532433067222 offset: 22374489</span><br><span class="line">timestamp: 1532433067230 offset: 22374830</span><br><span class="line">......</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>由上面dump出来的偏移量索引文件和日志数据文件的具体内容可以分析出来，偏移量索引文件中存储着大量的索引元数据，日志数据文件中存储着大量消息结构中的各个字段内容和消息体本身的值。索引文件中的元数据postion字段指向对应日志数据文件中message的实际位置（即为物理偏移地址）。</p><p>下面的表格先列举了Kakfa消息体结构中几个主要字段的说明：</p><table><thead><tr><th style="text-align:center">Kafka消息字段</th><th style="text-align:center">各个字段说明</th></tr></thead><tbody><tr><td style="text-align:center">offset</td><td style="text-align:center">消息偏移量</td></tr><tr><td style="text-align:center">message size</td><td style="text-align:center">消息总长度</td></tr><tr><td style="text-align:center">CRC32</td><td style="text-align:center">CRC32编码校验和</td></tr><tr><td style="text-align:center">attributes</td><td style="text-align:center">表示为独立版本、或标识压缩类型、或编码类型</td></tr><tr><td style="text-align:center">magic</td><td style="text-align:center">表示本次发布Kafka服务程序协议版本号</td></tr><tr><td style="text-align:center">key length</td><td style="text-align:center">消息Key的长度</td></tr><tr><td style="text-align:center">key</td><td style="text-align:center">消息Key的实际数据</td></tr><tr><td style="text-align:center">valuesize</td><td style="text-align:center">消息的实际数据长度</td></tr><tr><td style="text-align:center">playload</td><td style="text-align:center">消息的实际数据</td></tr></tbody></table><h3 id="日志数据文件"><a class="header-anchor" href="#日志数据文件"></a>日志数据文件</h3><p>Kafka将生产者发送给它的消息数据内容保存至日志数据文件中，该文件以该段的基准偏移量左补齐0命名，文件后缀为“.log”。分区中的每条message由offset来表示它在这个分区中的偏移量，这个offset并不是该Message在分区中实际存储位置，而是逻辑上的一个值（Kafka中用8字节长度来记录这个偏移量），但它却唯一确定了分区中一条Message的逻辑位置，同一个分区下的消息偏移量按照顺序递增（这个可以类比下数据库的自增主键）。另外，从dump出来的日志数据文件的字符值中可以看到消息体的各个字段的内容值。</p><h3 id="偏移量索引文件"><a class="header-anchor" href="#偏移量索引文件"></a>偏移量索引文件</h3><p>如果消息的消费者每次fetch都需要从1G大小（默认值）的日志数据文件中来查找对应偏移量的消息，那么效率一定非常低，在定位到分段后还需要顺序比对才能找到。Kafka在设计数据存储时，为了提高查找消息的效率，故而为分段后的每个日志数据文件均使用稀疏索引的方式建立索引，这样子既节省空间又能通过索引快速定位到日志数据文件中的消息内容。偏移量索引文件和数据文件一样也同样也以该段的基准偏移量左补齐0命名，文件后缀为“.index”。</p><p>从上面dump出来的偏移量索引内容可以看出，索引条目用于将偏移量映射成为消息在日志数据文件中的实际物理位置，每个索引条目由offset和position组成，每个索引条目可以唯一确定在各个分区数据文件的一条消息。其中，Kafka采用稀疏索引存储的方式，每隔一定的字节数建立了一条索引，可以通过<code>index.interval.bytes</code>设置索引的跨度；</p><p>有了偏移量索引文件，通过它，Kafka就能够根据指定的偏移量快速定位到消息的实际物理位置。具体的做法是，根据指定的偏移量，使用二分法查询定位出该偏移量对应的消息所在的分段索引文件和日志数据文件。然后通过二分查找法，继续查找出小于等于指定偏移量的最大偏移量，同时也得出了对应的position（实际物理位置），根据该物理位置在分段的日志数据文件中顺序扫描查找偏移量与指定偏移量相等的消息。下面是Kafka中分段的日志数据文件和偏移量索引文件的对应映射关系图（ps：其中也说明了如何按照起始偏移量来定位到日志数据文件中的具体消息）。</p><p><img src="/2018/10/21/聊聊Kafka/4325076-06b14071c55e7e62.png" alt="img"></p><h3 id="时间戳索引文件"><a class="header-anchor" href="#时间戳索引文件"></a>时间戳索引文件</h3><p>从上面一节的分区目录中，我们还可以看到存在一些以“.timeindex”的时间戳索引文件。这种类型的索引文件是Kafka从0.10.1.1版本开始引入的的一个基于时间戳的索引文件，它们的命名方式与对应的日志数据文件和偏移量索引文件名基本一样，唯一不同的就是后缀名。从上面dump出来的该种类型的时间戳索引文件的内容来看，每一条索引条目都对应了一个8字节长度的时间戳字段和一个4字节长度的偏移量字段，其中时间戳字段记录的是该LogSegment到目前为止的最大时间戳，后面对应的偏移量即为此时插入新消息的偏移量。</p><p>另外，时间戳索引文件的时间戳类型与日志数据文件中的时间类型是一致的，索引条目中的时间戳值及偏移量与日志数据文件中对应的字段值相同（ps：Kafka也提供了通过时间戳索引来访问消息的方法）。</p><h3 id="副本机制"><a class="header-anchor" href="#副本机制"></a>副本机制</h3><p>Kafka的副本机制是多个服务端节点对其他节点的主题分区的日志进行复制。当集群中的某个节点出现故障，访问故障节点的请求会被转移到其他正常节点(这一过程通常叫Reblance),kafka每个主题的每个分区都有一个主副本以及0个或者多个副本，副本保持和主副本的数据同步，当主副本出故障时就会被替代。</p><p><img src="/2018/10/21/聊聊Kafka/%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6.png" alt="img"></p><p>在Kafka中并不是所有的副本都能被拿来替代主副本，所以在kafka的leader节点中维护着一个ISR(In sync Replicas)集合，翻译过来也叫正在同步中集合，在这个集合中的需要满足两个条件:</p><ul><li>节点必须和ZK保持连接</li><li>在同步的过程中这个副本不能落后主副本太多</li></ul><p>另外还有个AR(Assigned Replicas)用来标识副本的全集,OSR用来表示由于落后被剔除的副本集合，所以公式如下:ISR = leader + 没有落后太多的副本; AR = OSR+ ISR;</p><p>这里先要说下两个名词:HW(高水位)是consumer能够看到的此partition的位置，LEO是每个partition的log最后一条Message的位置。HW能保证leader所在的broker失效，该消息仍然可以从新选举的leader中获取，不会造成消息丢失。</p><p>当producer向leader发送数据时，可以通过request.required.acks参数来设置数据可靠性的级别：</p><ul><li>1（默认）：这意味着producer在ISR中的leader已成功收到的数据并得到确认后发送下一条message。如果leader宕机了，则会丢失数据。</li><li>0：这意味着producer无需等待来自broker的确认而继续发送下一批消息。这种情况下数据传输效率最高，但是数据可靠性确是最低的。</li><li>-1：producer需要等待ISR中的所有follower都确认接收到数据后才算一次发送完成，可靠性最高。但是这样也不能保证数据不丢失，比如当ISR中只有leader时(其他节点都和zk断开连接，或者都没追上)，这样就变成了acks=1的情况。</li></ul><h3 id="高可用及幂等"><a class="header-anchor" href="#高可用及幂等"></a>高可用及幂等</h3><p>在分布式系统中一般有三种处理语义:</p><h4 id="at-least-once"><a class="header-anchor" href="#at-least-once"></a>at-least-once</h4><p>至少一次，有可能会有多次。如果producer收到来自ack的确认，则表示该消息已经写入到Kafka了，此时刚好是一次，也就是我们后面的exactly-once。但是如果producer超时或收到错误，并且request.required.acks配置的不是-1，则会重试发送消息，客户端会认为该消息未写入Kafka。如果broker在发送Ack之前失败，但在消息成功写入Kafka之后，这一次重试将会导致我们的消息会被写入两次，所以消息就不止一次地传递给最终consumer，如果consumer处理逻辑没有保证幂等的话就会得到不正确的结果。</p><p>在这种语义中会出现乱序，也就是当第一次ack失败准备重试的时候，但是第二消息已经发送过去了，这个时候会出现单分区中乱序的现象,我们需要设置Prouducer的参数max.in.flight.requests.per.connection，flight.requests是Producer端用来保存发送请求且没有响应的队列，保证Producer端未响应的请求个数为1。</p><h4 id="at-most-once"><a class="header-anchor" href="#at-most-once"></a>at-most-once</h4><p>如果在ack超时或返回错误时producer不重试，也就是我们讲request.required.acks=-1，则该消息可能最终没有写入kafka，所以consumer不会接收消息。</p><h4 id="exactly-once"><a class="header-anchor" href="#exactly-once"></a>exactly-once</h4><p>刚好一次，即使producer重试发送消息，消息也会保证最多一次地传递给consumer。该语义是最理想的，也是最难实现的。在0.10之前并不能保证exactly-once，需要使用consumer自带的幂等性保证。0.11.0使用事务保证了</p><h4 id="如何实现exactly-once"><a class="header-anchor" href="#如何实现exactly-once"></a>如何实现exactly-once</h4><p>要实现exactly-once在Kafka 0.11.0中有两个官方策略:</p><h5 id="单producer单topic"><a class="header-anchor" href="#单producer单topic"></a>单Producer单Topic</h5><p>每个producer在初始化的时候都会被分配一个唯一的PID，对于每个唯一的PID，Producer向指定的Topic中某个特定的Partition发送的消息都会携带一个从0单调递增的sequence number。</p><p>在我们的Broker端也会维护一个维度为，每次提交一次消息的时候都会对齐进行校验:</p><ul><li>如果消息序号比Broker维护的序号大一以上，说明中间有数据尚未写入，也即乱序，此时Broker拒绝该消息，Producer抛出InvalidSequenceNumber</li><li>如果消息序号小于等于Broker维护的序号，说明该消息已被保存，即为重复消息，Broker直接丢弃该消息，Producer抛出DuplicateSequenceNumber</li><li>如果消息序号刚好大一，就证明是合法的</li></ul><p>上面所说的解决了两个问题:</p><ol><li><p>当Prouducer发送了一条消息之后失败，broker并没有保存，但是第二条消息却发送成功，造成了数据的乱序。</p></li><li><p>当Producer发送了一条消息之后，broker保存成功，ack回传失败，producer再次投递重复的消息。</p></li></ol><p>上面所说的都是在同一个PID下面，意味着必须保证在单个Producer中的同一个seesion内，如果Producer挂了，被分配了新的PID，这样就无法保证了，所以Kafka中又有事务机制去保证。</p><h5 id="事务"><a class="header-anchor" href="#事务"></a>事务</h5><p>在kafka中事务的作用是</p><ul><li><p>实现exactly-once语义</p></li><li><p>保证操作的原子性，要么全部成功，要么全部失败。</p></li><li><p>有状态的操作的恢复</p></li></ul><p>事务可以保证就算跨多个，在本次事务中的对消费队列的操作都当成原子性，要么全部成功，要么全部失败。并且，有状态的应用也可以保证重启后从断点处继续处理，也即事务恢复。在kafka的事务中，应用程序必须提供一个唯一的事务ID，即Transaction ID，并且宕机重启之后，也不会发生改变，Transactin ID与PID可能一一对应。区别在于Transaction ID由用户提供，而PID是内部的实现对用户透明。为了Producer重启之后，旧的Producer具有相同的Transaction ID失效，每次Producer通过Transaction ID拿到PID的同时，还会获取一个单调递增的epoch。由于旧的Producer的epoch比新Producer的epoch小，Kafka可以很容易识别出该Producer是老的Producer并拒绝其请求。为了实现这一点，Kafka 0.11.0.0引入了一个服务器端的模块，名为Transaction Coordinator，用于管理Producer发送的消息的事务性。该Transaction Coordinator维护Transaction Log，该log存于一个内部的Topic内。由于Topic数据具有持久性，因此事务的状态也具有持久性。Producer并不直接读写Transaction Log，它与Transaction Coordinator通信，然后由Transaction Coordinator将该事务的状态插入相应的Transaction Log。Transaction Log的设计与Offset Log用于保存Consumer的Offset类似。</p><h2 id="最佳实践"><a class="header-anchor" href="#最佳实践"></a>最佳实践</h2><h3 id="针对-partitions-的最佳实践"><a class="header-anchor" href="#针对-partitions-的最佳实践"></a>针对 Partitions 的最佳实践</h3><h4 id="了解分区的数据速率-以确保提供合适的数据保存空间"><a class="header-anchor" href="#了解分区的数据速率-以确保提供合适的数据保存空间"></a>了解分区的数据速率，以确保提供合适的数据保存空间</h4><p>此处所谓“分区的数据速率”是指数据的生成速率。换言之，它是由“平均消息大小”乘以“每秒消息数”得出的数据速率决定了在给定时间内，所能保证的数据保存空间的大小（以字节为单位）。<br>如果您不知道数据速率的话，则无法正确地计算出满足基于给定时间跨度的数据，所需要保存的空间大小。<br>同时，数据速率也能够标识出单个 Consumer 在不产生延时的情况下，所需要支持的最低性能值。</p><h4 id="除非您有其他架构上的需要-否则在写-topic-时请使用随机分区"><a class="header-anchor" href="#除非您有其他架构上的需要-否则在写-topic-时请使用随机分区"></a>除非您有其他架构上的需要，否则在写 Topic 时请使用随机分区</h4><p>在您进行大型操作时，各个分区在数据速率上的参差不齐是非常难以管理的。</p><p>其原因来自于如下三个方面：</p><ul><li><strong>首先，</strong>“热”（有较高吞吐量）分区上的 Consumer 势必会比同组中的其他 Consumer 处理更多的消息，因此很可能会导致出现在处理上和网络上的瓶颈。</li><li><strong>其次</strong>，那些为具有最高数据速率的分区，所配置的最大保留空间，会导致Topic 中其他分区的磁盘使用量也做相应地增长。</li><li><strong>第三</strong>，根据分区的 Leader 关系所实施的最佳均衡方案，比简单地将 Leader 关系分散到所有 Broker 上，要更为复杂。在同一 Topic 中，“热”分区会“承载”10 倍于其他分区的权重。</li></ul><p>有关 Topic Partition 的使用，可以参阅《Kafka Topic Partition的各种有效策略》<a href="https://blog.newrelic.com/engineering/effective-strategies-kafka-topic-partitioning/" target="_blank" rel="noopener">https://blog.newrelic.com/engineering/effective-strategies-kafka-topic-partitioning/</a> 。</p><h3 id="针对-consumers-的最佳实践"><a class="header-anchor" href="#针对-consumers-的最佳实践"></a>针对 Consumers 的最佳实践</h3><h4 id="如果-consumers-运行的是比-kafka-0-10-还要旧的版本-那么请马上升级"><a class="header-anchor" href="#如果-consumers-运行的是比-kafka-0-10-还要旧的版本-那么请马上升级"></a>如果 Consumers 运行的是比 Kafka 0.10 还要旧的版本，那么请马上升级</h4><p>在 0.8.x 版中，Consumer 使用 Apache ZooKeeper 来协调 Consumer group，而许多已知的 Bug 会导致其长期处于再均衡状态，或是直接导致再均衡算法的失败（我们称之为“再均衡风暴”）。<br>因此在再均衡期间，一个或多个分区会被分配给同一组中的每个 Consumer。<br>而在再均衡风暴中，分区的所有权会持续在各个 Consumers 之间流转，这反而阻碍了任何一个 Consumer 去真正获取分区的所有权。</p><h4 id="调优-consumer-的套接字缓冲区-socket-buffers-以应对数据的高速流入"><a class="header-anchor" href="#调优-consumer-的套接字缓冲区-socket-buffers-以应对数据的高速流入"></a>调优 Consumer 的套接字缓冲区（socket buffers），以应对数据的高速流入</h4><p>在 Kafka 的 0.10.x 版本中，参数 receive.buffer.bytes 的默认值为 64KB。而在 Kafka 的 0.8.x 版本中，参数 socket.receive.buffer.bytes 的默认值为 100KB。<br>这两个默认值对于高吞吐量的环境而言都太小了，特别是如果 Broker 和 Consumer 之间的网络带宽延迟积（bandwidth-delay product）大于局域网（local areanetwork，LAN）时。<br>对于延迟为 1 毫秒或更多的高带宽的网络（如 10Gbps 或更高），请考虑将套接字缓冲区设置为 8 或 16MB。<br>如果您的内存不足，也至少考虑设置为 1MB。当然，您也可以设置为 -1，它会让底层操作系统根据网络的实际情况，去调整缓冲区的大小。<br>但是，对于需要启动“热”分区的 Consumers 来说，自动调整可能不会那么快。</p><h4 id="设计具有高吞吐量的-consumers-以便按需实施背压-back-pressure"><a class="header-anchor" href="#设计具有高吞吐量的-consumers-以便按需实施背压-back-pressure"></a>设计具有高吞吐量的 Consumers，以便按需实施背压（back-pressure）</h4><p>通常，我们应该保证系统只去处理其能力范围内的数据，而不要超负荷“消费”，进而导致进程中断“挂起”，或出现 Consume group 的溢出。<br>如果是在 Java 虚拟机（JVM）中运行，Consumers 应当使用固定大小的缓冲区，而且最好是使用堆外内存（off-heap）。请参见 Disruptor 模式：<a href="http://lmax-exchange.github.io/disruptor/files/Disruptor-1.0.pdf" target="_blank" rel="noopener">http://lmax-exchange.github.io/disruptor/files/Disruptor-1.0.pdf</a><br>固定大小的缓冲区能够阻止 Consumer 将过多的数据拉到堆栈上，以至于 JVM 花费掉其所有的时间去执行垃圾回收，进而无法履行其处理消息的本质工作。</p><h4 id="在-jvm-上运行各种-consumers-时-请警惕垃圾回收对它们可能产生的影响"><a class="header-anchor" href="#在-jvm-上运行各种-consumers-时-请警惕垃圾回收对它们可能产生的影响"></a>在 JVM 上运行各种 Consumers 时，请警惕垃圾回收对它们可能产生的影响</h4><p>例如，长时间垃圾回收的停滞，可能导致 ZooKeeper 的会话被丢弃、或 Consumer group 处于再均衡状态。<br>对于 Broker 来说也如此，如果垃圾回收停滞的时间太长，则会产生集群掉线的风险。</p><h3 id="针对-producers-的最佳实践"><a class="header-anchor" href="#针对-producers-的最佳实践"></a>针对 Producers 的最佳实践</h3><h4 id="配置-producer-以等待各种确认"><a class="header-anchor" href="#配置-producer-以等待各种确认"></a>配置 Producer，以等待各种确认</h4><p>籍此 Producer 能够获知消息是否真正被发送到了 Broker 的分区上。在 Kafka 的 0.10.x 版本上，其设置是 Acks；而在 0.8.x 版本上，则为 request.required.acks。<br>Kafka 通过复制，来提供容错功能，因此单个节点的故障、或分区 Leader 关系的更改不会影响到系统的可用性。<br>如果您没有用 Acks 来配置 Producer（或称“fireand forget”）的话，则消息可能会悄然丢失。</p><h4 id="为各个-producer-配置-retries"><a class="header-anchor" href="#为各个-producer-配置-retries"></a>为各个 Producer 配置 Retries</h4><p>其默认值为 3，当然是非常低的。不过，正确的设定值取决于您的应用程序，即：就那些对于数据丢失零容忍的应用而言，请考虑设置为 Integer.MAX_VALUE（有效且最大）。<br>这样将能够应对 Broker 的 Leader 分区出现无法立刻响应 Produce 请求的情况。</p><h4 id="为高吞吐量的-producer-调优缓冲区的大小"><a class="header-anchor" href="#为高吞吐量的-producer-调优缓冲区的大小"></a>为高吞吐量的 Producer，调优缓冲区的大小</h4><p>特别是 buffer.memory 和 batch.size（以字节为单位）。由于 batch.size 是按照分区设定的，而 Producer 的性能和内存的使用量，都可以与 Topic 中的分区数量相关联。<br>因此，此处的设定值将取决于如下几个因素：</p><ul><li><strong>Producer 数据速率（消息的大小和数量）</strong></li><li><strong>要生成的分区数</strong></li><li><strong>可用的内存量</strong></li></ul><p>请记住，将缓冲区调大并不总是好事，如果 Producer 由于某种原因而失效了（例如，某个 Leader 的响应速度比确认还要慢），那么在堆内内存（on-heap）中的缓冲的数据量越多，其需要回收的垃圾也就越多。</p><h4 id="检测应用程序-以跟踪诸如生成的消息数-平均消息大小-以及已使用的消息数等指标"><a class="header-anchor" href="#检测应用程序-以跟踪诸如生成的消息数-平均消息大小-以及已使用的消息数等指标"></a>检测应用程序，以跟踪诸如生成的消息数、平均消息大小、以及已使用的消息数等指标</h4><h3 id="针对-brokers-的最佳实践"><a class="header-anchor" href="#针对-brokers-的最佳实践"></a>针对 Brokers 的最佳实践</h3><h4 id="在各个-brokers-上-请压缩-topics-所需的内存和-cpu-资源"><a class="header-anchor" href="#在各个-brokers-上-请压缩-topics-所需的内存和-cpu-资源"></a>在各个 Brokers 上，请压缩 Topics 所需的内存和 CPU 资源</h4><p>日志压缩（请参见https://kafka.apache.org/documentation/#compaction）需要各个 Broker 上的堆栈（内存）和 CPU 周期都能成功地配合实现而如果让那些失败的日志压缩数据持续增长的话，则会给 Brokers 分区带来风险。<br>您可以在 Broker 上调整 log.cleaner.dedupe.buffer.size 和 log.cleaner.threads 这两个参数，但是请记住，这两个值都会影响到各个 Brokers 上的堆栈使用。<br>如果某个 Broker 抛出 OutOfMemoryError 异常，那么它将会被关闭、并可能造成数据的丢失。<br>而缓冲区的大小和线程的计数，则取决于需要被清除的 Topic Partition 数量、以及这些分区中消息的数据速率与密钥的大小。<br>对于 Kafka 的 0.10.2.1 版本而言，通过 ERROR 条目来监控日志清理程序的日志文件，是检测其线程可能出现问题的最可靠方法。</p><h4 id="通过网络吞吐量来监控-brokers"><a class="header-anchor" href="#通过网络吞吐量来监控-brokers"></a>通过网络吞吐量来监控 Brokers</h4><p>请监控发向（transmit，TX）和收向（receive，RX）的流量，以及磁盘的 I/O、磁盘的空间、以及 CPU 的使用率，而且容量规划是维护群集整体性能的关键步骤。</p><h4 id="在群集的各个-brokers-之间分配分区的-leader-关系"><a class="header-anchor" href="#在群集的各个-brokers-之间分配分区的-leader-关系"></a>在群集的各个 Brokers 之间分配分区的 Leader 关系</h4><p>Leader 通常会需要大量的网络 I/O 资源。例如，当我们将复制因子（replication factor）配置为 3、并运行起来时。<br>Leader 必须首先获取分区的数据，然后将两套副本发送给另两个 Followers，进而再传输到多个需要该数据的 Consumers 上。<br>因此在该例子中，单个 Leader 所使用的网络 I/O，至少是 Follower 的四倍。而且，Leader 还可能需要对磁盘进行读操作，而 Follower 只需进行写操作。</p><h4 id="不要忽略监控-brokers-的-in-sync-replica-isr-shrinks-under-replicatedpartitions-和-unpreferred-leaders"><a class="header-anchor" href="#不要忽略监控-brokers-的-in-sync-replica-isr-shrinks-under-replicatedpartitions-和-unpreferred-leaders"></a>不要忽略监控 Brokers 的 in-sync replica（ISR）shrinks、under-replicatedpartitions 和 unpreferred leaders</h4><p>这些都是集群中潜在问题的迹象。例如，单个分区频繁出现 ISR 收缩，则暗示着该分区的数据速率超过了 Leader 的能力，已无法为 Consumer 和其他副本线程提供服务了。</p><h4 id="按需修改-apache-log4j-的各种属性"><a class="header-anchor" href="#按需修改-apache-log4j-的各种属性"></a>按需修改 Apache Log4j 的各种属性</h4><p>详细内容可以参考：<a href="https://github.com/apache/kafka/blob/trunk/config/log4j.properties" target="_blank" rel="noopener">https://github.com/apache/kafka/blob/trunk/config/log4j.properties</a><br>Kafka 的 Broker 日志记录会耗费大量的磁盘空间，但是我们却不能完全关闭它。<br>因为有时在发生事故之后，需要重建事件序列，那么 Broker 日志就会是我们最好的、甚至是唯一的方法。</p><h4 id="禁用-topic-的自动创建-或针对那些未被使用的-topics-建立清除策略"><a class="header-anchor" href="#禁用-topic-的自动创建-或针对那些未被使用的-topics-建立清除策略"></a>禁用 Topic 的自动创建，或针对那些未被使用的 Topics 建立清除策略</h4><p>例如，在设定的 x 天内，如果未出现新的消息，您应该考虑该 Topic 是否已经失效，并将其从群集中予以删除。此举可避免您花时间去管理群集中被额外创建的元数据。</p><h4 id="对于那些具有持续高吞吐量的-brokers-请提供足够的内存-以避免它们从磁盘子系统中进行读操作"><a class="header-anchor" href="#对于那些具有持续高吞吐量的-brokers-请提供足够的内存-以避免它们从磁盘子系统中进行读操作"></a>对于那些具有持续高吞吐量的 Brokers，请提供足够的内存，以避免它们从磁盘子系统中进行读操作</h4><p>我们应尽可能地直接从操作系统的缓存中直接获取分区的数据。然而，这就意味着您必须确保自己的 Consumers 能够跟得上“节奏”，而对于那些延迟的 Consumer 就只能强制 Broker 从磁盘中读取了。</p><h4 id="对于具有高吞吐量服务级别目标-service-level-objectives-slos-的大型群集-请考虑为-brokers-的子集隔离出不同的-topic"><a class="header-anchor" href="#对于具有高吞吐量服务级别目标-service-level-objectives-slos-的大型群集-请考虑为-brokers-的子集隔离出不同的-topic"></a>对于具有高吞吐量服务级别目标（service level objectives，SLOs）的大型群集，请考虑为 Brokers 的子集隔离出不同的 Topic</h4><p>至于如何确定需要隔离的 Topics，则完全取决于您自己的业务需要。例如，您有一些使用相同群集的联机事务处理（multipleonline transaction processing，OLTP）系统。<br>那么将每个系统的 Topics 隔离到不同 Brokers 子集中，则能够有助于限制潜在事件的影响半径。</p><h4 id="在旧的客户端上使用新的-topic-消息格式-应当代替客户端-在各个-brokers-上加载额外的格式转换服务"><a class="header-anchor" href="#在旧的客户端上使用新的-topic-消息格式-应当代替客户端-在各个-brokers-上加载额外的格式转换服务"></a>在旧的客户端上使用新的 Topic 消息格式。应当代替客户端，在各个 Brokers 上加载额外的格式转换服务</h4><p>当然，最好还是要尽量避免这种情况的发生。</p><h4 id="不要错误地认为在本地主机上测试好-broker-就能代表生产环境中的真实性能了"><a class="header-anchor" href="#不要错误地认为在本地主机上测试好-broker-就能代表生产环境中的真实性能了"></a>不要错误地认为在本地主机上测试好 Broker，就能代表生产环境中的真实性能了</h4><p>要知道，如果使用复制因子为 1，并在环回接口上对分区所做的测试，是与大多数生产环境截然不同的。<br>在环回接口上网络延迟几乎可以被忽略的，而在不涉及到复制的情况下，接收 Leader 确认所需的时间则同样会出现巨大的差异。</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><ol><li><a href="https://book.douban.com/subject/27174117/" target="_blank" rel="noopener">Kafka 入门与实践 牟大恩著 2017.11 出版</a></li><li><a href="https://blog.newrelic.com/engineering/kafka-best-practices/" target="_blank" rel="noopener">NewRelic 官方博客：20 Best Practices for Working With Apache Kafka at Scale</a></li><li><a href="https://mapr.com/ebooks/streaming-architecture/chapter-04-apache-kafka-overview.html" target="_blank" rel="noopener">MapR 官方博客：Kafka as Streaming Transport</a></li><li><a href="https://kafka.apache.org/documentation/" target="_blank" rel="noopener">Apache Kafka 官方文档</a></li><li><a href="https://mp.weixin.qq.com/s/vhwUCdimvpBt5Z38pRX5xw" target="_blank" rel="noopener">公众号咖啡拿铁：你必须知道的 Kafka</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2018/10/21/聊聊Kafka/Canva-Latte-Art-and-Leaf-on-Brown-Surface.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;
&lt;p&gt;kafka 的诞生，是为了解决 linkedin 的数据管道问题，期初 linkedin 采用了 ActiveMQ 来进行数据交换，大约是在 2010 年前后，那时的 ActiveMQ 还远远无法满足 linkedin 对数据传递系统的要求，经常由于各种缺陷而导致消息阻塞或者服务无法正常访问，为了能够解决这个问题，linkedin 决定研发自己的消息传递系统，当时 linkedin 的首席架构师 jay kreps 便开始组织团队进行消息传递系统的研发；&lt;/p&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="中间件" scheme="http://houqian.github.io/tags/中间件/"/>
    
    <category term="消息队列" scheme="http://houqian.github.io/tags/消息队列/"/>
    
    <category term="Kafka" scheme="http://houqian.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>调用模型</title>
    <link href="http://houqian.github.io/2018/08/30/%E8%B0%83%E7%94%A8%E6%A8%A1%E5%9E%8B/"/>
    <id>http://houqian.github.io/2018/08/30/%E8%B0%83%E7%94%A8%E6%A8%A1%E5%9E%8B/</id>
    <published>2018-08-30T11:02:19.000Z</published>
    <updated>2019-07-05T07:15:08.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>提示: 本文是<a href="http://houqian.xyz/2018/08/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/#%E7%AE%97%E6%B3%95%E4%BE%A7" target="_blank" rel="noopener">模型部署方案</a>的一部分</p><h1 id="依赖"><a class="header-anchor" href="#依赖"></a>依赖</h1><ul><li>java8</li><li>pmml-evaluator 1.4.2</li><li>pmml-evaluator-extension 1.4.2</li></ul><h1 id="步骤"><a class="header-anchor" href="#步骤"></a>步骤</h1><ol><li>使用JPMML执行引擎反序列化pmml文件</li><li>模型校验（此处具体校验的问题，笔者以后另开一篇）</li></ol><a id="more"></a><h1 id="我们开始吧"><a class="header-anchor" href="#我们开始吧"></a>我们开始吧</h1><p>maven依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pmml-evaluator.version</span>&gt;</span>1.4.2<span class="tag">&lt;/<span class="name">pmml-evaluator.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--运行模型--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jpmml<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pmml-evaluator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;pmml-evaluator.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jpmml<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pmml-evaluator-extension<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;pmml-evaluator.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="一网打尽"><a class="header-anchor" href="#一网打尽"></a>一网打尽</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.houqian.jpmml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jpmml.evaluator.*;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.SAXException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.bind.JAXBException;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : houqian</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> : 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> : 2018-08-30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Execute</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JAXBException, SAXException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 从pmml文件实例化模型执行引擎</span></span><br><span class="line">    Evaluator evaluator = <span class="keyword">new</span> LoadingModelEvaluatorBuilder()</span><br><span class="line">            .setLocatable(<span class="keyword">false</span>)</span><br><span class="line">            .setVisitors(<span class="keyword">new</span> DefaultVisitorBattery())</span><br><span class="line">            <span class="comment">//.setOutputFilter(OutputFilters.KEEP_FINAL_RESULTS)</span></span><br><span class="line">            .load(<span class="keyword">new</span> File(<span class="string">"src/main/resources/pipeline.pmml.xml"</span>))</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验模型合法性</span></span><br><span class="line">    evaluator.verify();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入变量</span></span><br><span class="line">    List&lt;? extends InputField&gt; inputFields = evaluator.getInputFields();</span><br><span class="line">    System.out.println(<span class="string">"Input fields: "</span> + inputFields);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标签</span></span><br><span class="line">    List&lt;? extends TargetField&gt; targetFields = evaluator.getTargetFields();</span><br><span class="line">    System.out.println(<span class="string">"Target field(s): "</span> + targetFields);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出变量</span></span><br><span class="line">    List&lt;? extends OutputField&gt; outputFields = evaluator.getOutputFields();</span><br><span class="line">    System.out.println(<span class="string">"Output fields: "</span> + outputFields);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放引用，优化GC</span></span><br><span class="line">    evaluator = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;提示: 本文是&lt;a href=&quot;http://houqian.xyz/2018/08/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/#%E7%AE%97%E6%B3%95%E4%BE%A7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;模型部署方案&lt;/a&gt;的一部分&lt;/p&gt;
&lt;h1 id=&quot;依赖&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#依赖&quot;&gt;&lt;/a&gt;依赖&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;java8&lt;/li&gt;
&lt;li&gt;pmml-evaluator 1.4.2&lt;/li&gt;
&lt;li&gt;pmml-evaluator-extension 1.4.2&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;步骤&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#步骤&quot;&gt;&lt;/a&gt;步骤&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;使用JPMML执行引擎反序列化pmml文件&lt;/li&gt;
&lt;li&gt;模型校验（此处具体校验的问题，笔者以后另开一篇）&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="机器学习" scheme="http://houqian.github.io/tags/机器学习/"/>
    
    <category term="部署" scheme="http://houqian.github.io/tags/部署/"/>
    
  </entry>
  
  <entry>
    <title>加载模型文件</title>
    <link href="http://houqian.github.io/2018/08/30/%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B%E6%96%87%E4%BB%B6/"/>
    <id>http://houqian.github.io/2018/08/30/%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B%E6%96%87%E4%BB%B6/</id>
    <published>2018-08-30T10:11:21.000Z</published>
    <updated>2019-07-29T20:02:51.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>提示: 本文是<a href="http://houqian.xyz/2018/08/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/#%E7%AE%97%E6%B3%95%E4%BE%A7" target="_blank" rel="noopener">模型部署方案</a>的一部分</p><h2 id="依赖"><a class="header-anchor" href="#依赖"></a>依赖</h2><ul><li>java8</li><li>pmml-model 1.4.2</li></ul><h2 id="步骤"><a class="header-anchor" href="#步骤"></a>步骤</h2><ol><li>加载反序列化模型文件为PMML对象</li><li>优化模型，并写到新模型文件</li></ol><a id="more"></a><h2 id="我们开始吧"><a class="header-anchor" href="#我们开始吧"></a>我们开始吧</h2><p>maven依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pmml-model.version</span>&gt;</span>1.4.2<span class="tag">&lt;/<span class="name">pmml-model.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--pmml模型--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jpmml<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pmml-model<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;pmml-model.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="加载模型-更新模型"><a class="header-anchor" href="#加载模型-更新模型"></a>加载模型 &amp; 更新模型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.houqian.jpmml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> org.dmg.pmml.PMML;</span><br><span class="line"><span class="keyword">import</span> org.jpmml.model.PMMLUtil;</span><br><span class="line"><span class="keyword">import</span> org.jpmml.model.visitors.LocatorNullifier;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.SAXException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.bind.JAXBException;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : houqian</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> : 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> : 2018-08-30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Load</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException, JAXBException, SAXException, JsonProcessingException </span>&#123;</span><br><span class="line">    <span class="comment">// 这里的pmml是之前sklearn、sparkml导出的文件，任选其一即可</span></span><br><span class="line">    FileInputStream srcModelIs = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"src/main/resources/pipeline.pmml.xml"</span>));</span><br><span class="line">    PMML pmml = PMMLUtil.unmarshal(srcModelIs);</span><br><span class="line"></span><br><span class="line">    optimize(pmml);</span><br><span class="line"></span><br><span class="line">    FileOutputStream newModelOs = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"src/main/resources/new-pipeline.pmml.xml"</span>));</span><br><span class="line">    store(pmml, newModelOs);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">optimize</span><span class="params">(PMML pmml)</span></span>&#123;</span><br><span class="line">    LocatorNullifier nullifier = <span class="keyword">new</span> LocatorNullifier();</span><br><span class="line">    nullifier.applyTo(pmml);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">store</span><span class="params">(PMML pmml, OutputStream os)</span> <span class="keyword">throws</span> JAXBException </span>&#123;</span><br><span class="line">    org.jpmml.model.PMMLUtil.marshal(pmml, os);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>笔者没有找到如何验证以上操作和模型正确性的关系，现在姑且先让它这样不报错跑通吧。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜  src git:(master) ✗ tree -L 3 </span><br><span class="line">.</span><br><span class="line">├── main</span><br><span class="line">│   ├── java</span><br><span class="line">│   │   ├── com</span><br><span class="line">│   │   └── org</span><br><span class="line">│   └── resources</span><br><span class="line">│       ├── application.properties</span><br><span class="line">│       ├── application.yml</span><br><span class="line">│       ├── import.sql</span><br><span class="line">│       ├── kafka</span><br><span class="line">│       ├── new-pipeline.pmml.xml   &lt;--生成的新模型文件</span><br><span class="line">│       └── pipeline.pmml.xml       &lt;--之前sklearn输出的模型文件</span><br><span class="line">└── test</span><br><span class="line">    └── java</span><br><span class="line">        └── org</span><br><span class="line"></span><br><span class="line">9 directories, 5 files</span><br></pre></td></tr></table></figure><h2 id="参考"><a class="header-anchor" href="#参考"></a>参考</h2><ol><li><a href="https://github.com/jpmml/jpmml-model" target="_blank" rel="noopener">https://github.com/jpmml/jpmml-model</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;提示: 本文是&lt;a href=&quot;http://houqian.xyz/2018/08/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/#%E7%AE%97%E6%B3%95%E4%BE%A7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;模型部署方案&lt;/a&gt;的一部分&lt;/p&gt;
&lt;h2 id=&quot;依赖&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#依赖&quot;&gt;&lt;/a&gt;依赖&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;java8&lt;/li&gt;
&lt;li&gt;pmml-model 1.4.2&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;步骤&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#步骤&quot;&gt;&lt;/a&gt;步骤&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;加载反序列化模型文件为PMML对象&lt;/li&gt;
&lt;li&gt;优化模型，并写到新模型文件&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="计算机科学与技术" scheme="http://houqian.github.io/categories/计算机科学与技术/"/>
    
    
    <category term="机器学习" scheme="http://houqian.github.io/tags/机器学习/"/>
    
    <category term="部署" scheme="http://houqian.github.io/tags/部署/"/>
    
  </entry>
  
</feed>
