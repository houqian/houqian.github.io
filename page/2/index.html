<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Page 2 | 侯乾的BLOG</title>
  <meta name="author" content="Hou Qian">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="侯乾的BLOG">

  
    <meta property="og:image" content="">
  

  
  
    <link href="/favicon.png" rel="icon">
  

  <!-- CSS -->
  <link rel="stylesheet" href="/css/themes/bootstrap.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight-default.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/comment.css" media="screen" type="text/css">
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.9/es5-shim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.7/es5-sham.min.js"></script>
  <![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>
  
  <!-- analytics -->
  



</head>
</html>
 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
	<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
       <a class="navbar-brand" href="/">侯乾的BLOG</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="91年人，喜欢声乐，想养一只猫">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 <div class="page-header page-header-inverse ">
  <h1 class="title title-inverse ">且听风吟</h1>
</div>

<div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">
      <i class="fa fa-heart"></i>
      647号小宇宙
</div>    
		<div id="top_search"></div>
		<div class="mypage">
		
		<!-- title and entry -->
        <!-- render top articles firstly -->
        
        <!-- render other articles -->
        
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2017-03-12 </div>
			<div class="article-title"><a href="/2017/03/12/深入理解Java内存模型/">深入理解 Java 内存模型</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<h1 id="说明"><a class="header-anchor" href="#说明"></a>说明</h1>
<p>又发现一本不错的小书<a href="https://www.infoq.cn/article/java_memory_model" target="_blank" rel="noopener">《深入理解 Java 内存模型》</a>，趁着昨天周六一口气读完，虽然篇幅只有区区70页，可受益颇多。由于原文短小精悍，为了预留合理的上下文以助于理解，本文保留了大部分原文，并且在关键处使用笔者自己的理解对原文进行再解释（以表达方式再排列、语义扩充等方法，尽量在语义上确保大于等于原意）。好了废话不多说，我们开始吧~</p>
<h1 id="基础"><a class="header-anchor" href="#基础"></a>基础</h1>
<h2 id="并发编程的分类"><a class="header-anchor" href="#并发编程的分类"></a>并发编程的分类</h2>
<p>在并发编程中，我们需要处理两个关键问题：线程之间如何通信及线程之间如何同步（这里的线程是指并发执行的活动实体）。通信是指线程之间以何种机制来交换 信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。</p>
<p>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。在消息传递的并发模型里，线程之间没有公共状 态，线程之间必须通过明确的发送消息来显式进行通信。</p>
<p>同步是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之 间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前， 因此同步是隐式进行的。</p>
<p>Java 的并发采用的是共享内存模型，Java 线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的 Java 程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。</p>
<h2 id="java-内存模型的抽象"><a class="header-anchor" href="#java-内存模型的抽象"></a>Java 内存模型的抽象</h2>
<p>在java中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享（本文使用“共享变量”这个术语代指实例域，静态域和数组元素）。局部变量 （Local variables），方法定义参数（java语言规范称之为formal method parameters）和异常处理器参数（exception handler parameters）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。</p>
<p>Java 线程之间的通信由 Java 内存模型（本文简称为 JMM）控制，JMM 决定一个 线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java 内存模型的抽象示意图如下：</p>
<p><img src="/2017/03/12/深入理解Java内存模型/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%8A%BD%E8%B1%A1%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="Java内存模型抽象示意图"></p>
<p>从上图来看，线程 A 与线程 B 之间如要通信的话，必须要经历下面 2 个步骤：</p>
<ol>
<li>线程 A 把本地内存 A 中更新过的共享变量刷新到主内存中去</li>
<li>然后，线程 B 到主内存中去读取线程 A 之前已经更新过的共享变量</li>
</ol>
<p><img src="/2017/03/12/深入理解Java内存模型/%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%AD%A5%E9%AA%A4.jpg" alt="两个线程通信步骤"></p>
<p>举例说明Java线程间通信机制：</p>
<p>以上图为背景，线程 A 、B 有主内存中共享变量 x 的副本。</p>
<ol>
<li>
<p>假设一开始，这三个内存中的 x 的值都为 0.</p>
</li>
<li>
<p>线程 A 在执行时，把更新后的 x 值（假设值为1）临时存放在自己的本地内存 A 中。</p>
</li>
<li>
<p>当线程 A 和 B 需要通信时，线程 A 首先会把自己本地内存中修改后的 x 值刷新到主内存中，此时主内存中的 x 值变为了 1。</p>
</li>
<li>
<p>随后，线程 B 到主内存中去读线程 A 更新后的 x 值，此时线程 B 的本地内存的 x 值夜变为了 1。</p>
</li>
</ol>
<blockquote>
<p>整体来看，实质上是线程 A 向 B 发送消息，而且这个通信过程必须要经过主内存。JMM 通过控制主内存与每个线程的本地内存之间的交互，来为 Java 程序员提供内存可见性保证。</p>
</blockquote>
<h2 id="重排序"><a class="header-anchor" href="#重排序"></a>重排序</h2>
<p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分为三种类型：</p>
<ol>
<li>
<p>编译器优化排序
编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</p>
</li>
<li>
<p>指令级并行重排序
现代处理器采用了指令级秉性技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应的机器指令的执行顺序。</p>
</li>
<li>
<p>内存系统的重排序</p>
<p>由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p>
</li>
</ol>
<p>从 Java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p>
<p><img src="/2017/03/12/深入理解Java内存模型/Java%E6%BA%90%E7%A0%81%E5%88%B0%E6%89%A7%E8%A1%8C%E6%B6%89%E5%8F%8A%E7%9A%84%E9%87%8D%E6%8E%92%E5%BA%8F.jpg" alt="Java 源码到执行涉及的重排序"></p>
<p>其中 1 属于编译器重排序，2 和 3 属于处理器重排序。</p>
<p>这些重排序都可能会导致多线程程序出现内存可见性问题。因此，为了避免此问题，JMM编译器设置了一些规则：</p>
<ul>
<li>对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。</li>
<li>对于处理器重排序，JMM 的处理器重排序规则会要求 Java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。</li>
</ul>
<blockquote>
<p>JMM 属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p>
</blockquote>
<h2 id="处理器重排序与内存屏障指令"><a class="header-anchor" href="#处理器重排序与内存屏障指令"></a>处理器重排序与内存屏障指令</h2>
<p>现代处理器使用写缓冲区来临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。虽然写缓冲区有这么多的好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产重要的影响：处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致！</p>
<p>我们来假设这样一种情况：</p>
<table>
<thead>
<tr>
<th>Processor A</th>
<th>Processor B</th>
</tr>
</thead>
<tbody>
<tr>
<td>a = 1;   //A1   <br>x = b;   //A2</td>
<td>b = 2;   //B1  <br> y = a;   //B2</td>
</tr>
</tbody>
</table>
<p>显然，我们期望得到的执行结果是: x = 2，y = 1。然而实际上，我们却可能得到 x = y = 0，这是为什么呢？</p>
<p><img src="/2017/03/12/深入理解Java内存模型/%E5%A4%84%E7%90%86%E5%99%A8%E9%87%8D%E6%8E%92%E5%BA%8F%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98.jpg" alt="处理器重排序导致的问题"></p>
<ul>
<li>这里处理器 A 和处理器 B 可以同时把共享变量写入自己的缓冲区（A1，B1）</li>
<li>然后从内存中读取另一个共享变量（A2，B2）</li>
<li>最后才把自己写缓存区保存的脏数据刷新到内存中（A3，B3）。当以这种时序执行时，程序就可以得到 x=y=0</li>
</ul>
<p>从内存操作实际发生的顺序看，直到处理器 A 执行 A3 来刷新自己的写缓存区 A，写操作 A1 才算真正执行了。虽然处理器 A 执行内存操作的顺序为：A1 -&gt; A2，但内存操作实际发生的顺序确是 A2 -&gt; A1。此时，处理器 A 的内存操作顺序被重排序了</p>
<p>处理器 B 和 A 的情况是类似的，这里不赘述了。</p>
<blockquote>
<p>产生这个结果的关键是，由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作顺序不一致。</p>
</blockquote>
<p>下面是常见处理器允许的重排序类型的列表：</p>
<table>
<thead>
<tr>
<th></th>
<th>Load-Load</th>
<th>Load-Store</th>
<th>Store-Store</th>
<th>Store-Load</th>
<th>数据依赖</th>
</tr>
</thead>
<tbody>
<tr>
<td>sparc- TSO</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td><strong>x86</strong></td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>ia64</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>PowerPC</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
</tbody>
</table>
<p>N 表示处理器不允许两个操作重排序，Y 反之。</p>
<p>从上表我们可以看出：常见的处理器都允许 Store-Load 重排序；常见的处理器都不允许对存在数据以来的操作做重排序。特别的，对于 x86 架构的处理器，仅仅会在 Store-Load 这种情况进行重排序。</p>
<p>到这里，有同学可能有疑问了，既然 CPU 肯定会对 Store-Load 这种情况进行重排序，那岂不是乱套了，我 Java 代码怎么写？？</p>
<p>实际上，为了解决这个问题，Java 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。</p>
<p>JMM 把内存屏障指令分为以下四类：</p>
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>指令示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>LoadLoad Barriers</td>
<td>Load1; LoadLoad; Load2</td>
<td>确保 Load1 数据的装载，之前于Load2 及所有后续装载指令的装载。</td>
</tr>
<tr>
<td>StoreStore Barriers</td>
<td>Store1;StoreStore; Store2</td>
<td>确保 Store1 数据对其他处理器可 见（刷新到内存），之前于 Store2 及所有后续存储指令的存储。</td>
</tr>
<tr>
<td>LoadStore Barriers</td>
<td>Load1;LoadStore; Store2</td>
<td>确保 Load1 数据装载，之前于 Store2 及所有后续的存储指令刷 新到内存。</td>
</tr>
<tr>
<td>StoreLoad Barriers</td>
<td>Store1;StoreLoad; Load2</td>
<td>确保 Store1 数据对其他处理器变得可见（指刷新到内存），之前于 Load2 及所有后续装载指令的装载。StoreLoad Barriers 会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>现代处理器大多支持 Store-Load Barriers （其他类型的屏障不一定被所有处理器支持）。但是执行该屏障的开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（buffer fully flush）。</p>
</blockquote>
<h2 id="happens-before"><a class="header-anchor" href="#happens-before"></a>happens-before</h2>
<p>从 JDK5 开始，Java 使用新的 JSR-133 内存模型（本文除非特别说明，针对的都是 JSR-133 内存模型）。JSR
-133 使用 happens-before 的概念来阐述操作之间的内存可见性。</p>
<blockquote>
<p>在 JMM 中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同的线程之间。</p>
</blockquote>
<p>happens-before 规则如下：</p>
<ul>
<li>程序顺序规则
一个线程中的每个操作，happens-before 于该线程中的任意后续操作</li>
<li>监视器锁规则
对一个监视器的解锁，happens-before 于随后对这个监视器的加锁</li>
<li>volatile 变量规则
对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读</li>
<li>传递性
如果 A happens-before B，且 B happens-before C，那么 A happens-before C</li>
</ul>
<p>这里，解释一下 happens-before 关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before 仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前。这个定义看起来很微妙，后文具体说明为什么这么定义。</p>
<p>总结下happens-before 与 JMM 的关系，如下图所示：</p>
<p><img src="/2017/03/12/深入理解Java内存模型/happens-before%E4%B8%8EJMM%E7%9A%84%E5%85%B3%E7%B3%BB.jpg" alt="happens-before与JMM的关系"></p>
<p>如上图所示，一个 happens-before 规则对应一个或多个编译器和处理器重排序规则。对于 Java 程序员来说，happens-before 规则简单易懂，它避免 Java 程序员为了理解 JMM 提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现。</p>
<h1 id="重排序-v2"><a class="header-anchor" href="#重排序-v2"></a>重排序</h1>
<h2 id="数据依赖性"><a class="header-anchor" href="#数据依赖性"></a>数据依赖性</h2>
<p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时，这两个操作之间就存在数据依赖性。</p>
<p>数据依赖分下列三种类型：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>代码示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>写后读</td>
<td>a = 1;   <br>b = a;</td>
<td>写一个变量之后，再读这个位置。</td>
</tr>
<tr>
<td>写后写</td>
<td>a = 1;   <br>a = 2;</td>
<td>写一个变量之后，再写这个变量。</td>
</tr>
<tr>
<td>读后写</td>
<td>a = b;<br>b = 1;</td>
<td>读一个变量之后，再写这个变量。</td>
</tr>
</tbody>
</table>
<p>很容易对这三种情况得出如下结论：</p>
<p>上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。</p>
<p>前面提到过，编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。也就是说，上面三种情况，不会发生处理器重排序。</p>
<p>不过，这里需要注意，这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑（这种情况参考<a href="#%E5%A4%84%E7%90%86%E5%99%A8%E9%87%8D%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E6%8C%87%E4%BB%A4">前面</a>中的例子）</p>
<h2 id="as-if-serial-语义"><a class="header-anchor" href="#as-if-serial-语义"></a>as-if-serial 语义</h2>
<p>不管怎么重排序（编译器和处理器为了提升并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。</p>
<p>为了遵守 as-if-serial 语义，编译器和处理器不会对存在 <a href="#%E6%95%B0%E6%8D%AE%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB">数据依赖关系</a> 的操作做重排序，因为这种重排序会改变执行结果。</p>
<p>但是，如果操作之前不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。我们举例说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> pi = <span class="number">3.14</span>;					<span class="comment">// A</span></span><br><span class="line"><span class="keyword">double</span> r = <span class="number">1.0</span>;						<span class="comment">// B</span></span><br><span class="line"><span class="keyword">double</span> area = pi * r * r; <span class="comment">// C</span></span><br></pre></td></tr></table></figure>
<p>上面三个操作的数据依赖关系如下图所示：</p>
<p><img src="/2017/03/12/深入理解Java内存模型/%E4%B8%89%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB.jpg" alt="三个操作的数据依赖关系"></p>
<p>如上图所示，A 和 C 之间存在数据依赖关系，同时 B 和 C 之间也存在数据依赖关系。因此在最终执行的指令序列中，C 不能被重排序到 A 和 B 的前面（因为这种情况下程序结果将被改变）。但 A 和 B 之间是没有数据依赖关系的，编译器和处理器可以重排序 A 和 B 之间的执行顺序。下图是该程序的两种执行顺序：</p>
<p><img src="/2017/03/12/深入理解Java内存模型/%E4%B8%A4%E7%A7%8D%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.jpg" alt="两种执行顺序"></p>
<blockquote>
<p>as-if-serial 语义把单线程程序保护了起来，遵守 as-if-serial 语义的编译器、runtime和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序时按程序的顺序来执行的。as-if-serial 语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。</p>
</blockquote>
<h2 id="程序顺序规则"><a class="header-anchor" href="#程序顺序规则"></a>程序顺序规则</h2>
<p>根据 happens-before 的程序顺序规则，上面计算圆的面积的示例代码存在三个 happens-before 关系：</p>
<ol>
<li>A happens-before B</li>
<li>B happens-before C</li>
<li>A happens-before C（根据前两个推导出来的，即传递性）</li>
</ol>
<p>这里 A happens-before B ，但实际执行 B 却可以排在 A 之前执行（看上面那两种重排序后的执行顺序）。在<a href="#happens-before">前面</a>提到过，如果 A happens-before B ，JMM 并不要求 A 一定要在 B 之前执行。JMM 仅仅要求前一个操作（执行的结果）对后一个操作可见；而且重排序操作 A 和操作 B 后的执行结果，与操作 A 和 B 按照程序顺序执行的结果一致。在这种情况下，JMM 会认为这种重排序并不非法（not illegal），JMM 允许这种排序。</p>
<p>在计算机中，软件技术和硬件技术有一个共同的目标：在不改变程序执行结果的前提下，尽可能的开发并行度。编译器和处理器遵从这一目标，从 happens-before 的定义我们可以看出，JMM 同样遵从这一目标。</p>
<h2 id="重排序对多线程的影响"><a class="header-anchor" href="#重排序对多线程的影响"></a>重排序对多线程的影响</h2>
<p>现在让我们看看，重排序是否会改变多线程程序的执行结果。我们还用一个示例代入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecorderExample</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	a = <span class="number">1</span>;							<span class="comment">// 1</span></span><br><span class="line">    flag = <span class="keyword">true</span>;				<span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">if</span> (flag) &#123;					<span class="comment">// 3</span></span><br><span class="line">    	<span class="keyword">int</span> i = a * a;		<span class="comment">// 4</span></span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flag 变量是一个标记，用来标识变量 a 是否已被写入。这里假设有两个线程 A 和 B，A 首先执行 writer()方法，随后 B 线程接着执行 reader()方法。线程 B 在执行操作 4 时，能否看到线程 A 在操作 1 对共享变量 a 的写入？</p>
<p>答案是：不一定看到。</p>
<p>由于操作 1 和操作 2 没有数据依赖关系，编译器和处理器可以对这两个操作重排序；同样，操作 3 和操作 4 没有数据依赖关系，编译器和处理器也可以对这两个操作重排序。让我们先来看看，当操作 1 和操作 2 重排序时，可能会产生什么效果？</p>
<p><img src="/2017/03/12/深入理解Java内存模型/%E6%93%8D%E4%BD%9C1%E5%92%8C%E6%93%8D%E4%BD%9C2%E9%87%8D%E6%8E%92%E5%BA%8F%E6%97%B6%EF%BC%8C%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%97%B6%E5%BA%8F%E5%9B%BE.jpg" alt="操作1和操作2重排序时，程序执行时序图"></p>
<p>注：本文统一用红色的虚箭线标识错误的读操作，用绿色的虚箭线标识正确的读操作</p>
<p>如上图所示，操作 1 和操作 2 做了重排序。程序执行时，线程 A 首先写标记变量 flag，随后线程 B 读这个变量。由于条件判断为真，线程 B 将读取变量 a。此时，变量 a 还根本没有被线程 A 写入，在这里多线程程序的语义被重排序破坏了！</p>
<p>现在再让我们看看，当操作 3 和操作 4 重排序时会产生什么效果（借助这个重排序，可以顺便说明控制依赖性）。如图所示，操作 3 和 4 重排序后，程序的执行时序：</p>
<p><img src="/2017/03/12/深入理解Java内存模型/%E6%93%8D%E4%BD%9C3%E5%92%8C%E6%93%8D%E4%BD%9C4%E9%87%8D%E6%8E%92%E5%BA%8F%E6%97%B6%EF%BC%8C%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%97%B6%E5%BA%8F%E5%9B%BE.jpg" alt="操作3和操作4重排序时，程序执行时序图"></p>

	
	</div>
  <a type="button" href="/2017/03/12/深入理解Java内存模型/#more" class="btn btn-default more">Read More</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2017-02-11 </div>
			<div class="article-title"><a href="/2017/02/11/JVM-Internals/">JVM Internals</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<h1 id="说明"><a class="header-anchor" href="#说明"></a>说明</h1>
<p>本文系转载，并在转载译文基础上根据笔者经验略作修改。原文链接在<a href="#%E8%BD%AC%E8%BD%BD%E9%93%BE%E6%8E%A5">文末</a></p>
<h1 id="一-前言"><a class="header-anchor" href="#一-前言"></a>一、前言</h1>
<p>本文将介绍JVM内部架构。下图展示符合Java7规范的JVM内部主要组件。</p>
<p><img src="/2017/02/11/JVM-Internals/291701116593444.png" alt="img"></p>
<p>下面我们将上述组件分为线程相关和线程独立两种类型来介绍。</p>
	
	</div>
  <a type="button" href="/2017/02/11/JVM-Internals/#more" class="btn btn-default more">Read More</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2016-05-31 </div>
			<div class="article-title"><a href="/2016/05/31/看起来简单的通知推送服务，真的简单吗/">看起来简单的通知推送服务，真的简单吗</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<h1 id="背景"><a class="header-anchor" href="#背景"></a>背景</h1>
<p>目前OneAlert提供短信、邮件、电话、APP四种通知通道，其中前三种的使用量最高(90%以上的用户)，因此靠谱的第三方推送提供商至关重要。经过对各种三方推送服务的公司调研，目前锁定了阿里大鱼<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>、容联云<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>、云片<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>、云之讯<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>、SendCloud<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>，这5家平台提供商。</p>
<p>首先我们来分析一下接入三方后的通讯模型</p>
<p><img src="/2016/05/31/看起来简单的通知推送服务，真的简单吗/%E6%8E%A8%E9%80%81%E6%A8%A1%E5%9E%8B.svg" alt="推送模型"></p>
<blockquote>
<p>注：配额这里是指三方服务商的发送限制，比如每小时最多每个电话拨打几次</p>
</blockquote>
	
	</div>
  <a type="button" href="/2016/05/31/看起来简单的通知推送服务，真的简单吗/#more" class="btn btn-default more">Read More</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2015-06-04 </div>
			<div class="article-title"><a href="/2015/06/04/Java集合源码剖析目录/">Java集合源码剖析目录</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<ol>
<li>
<p><a href="http://houqian.xyz/2015/05/14/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8B%E6%A0%B8%E5%BF%83%E6%8E%A5%E5%8F%A3/">Java集合源码剖析之核心接口</a></p>
</li>
<li>
<p><a href="http://houqian.xyz/2015/06/03/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8BArrayList/">Java集合源码剖析之ArrayList</a></p>
</li>
</ol>

	
	</div>
  <a type="button" href="/2015/06/04/Java集合源码剖析目录/#more" class="btn btn-default more">Read More</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2015-06-03 </div>
			<div class="article-title"><a href="/2015/06/03/Java集合源码剖析之ArrayList/">Java集合源码剖析之ArrayList</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>此为 <a href="http://houqian.xyz/2015/06/04/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%9B%AE%E5%BD%95/">Java集合源码剖析</a>系列的一部分</p>
<h1 id="简介"><a class="header-anchor" href="#简介"></a>简介</h1>
<p>ArrayList属于线性表的一种，底层由数组实现。相对于数组，它具有动态扩容的能力，也可以称其为动态数组。</p>
<h1 id="继承体系"><a class="header-anchor" href="#继承体系"></a>继承体系</h1>
<p><img src="/2015/06/03/Java集合源码剖析之ArrayList/ArrayList%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.svg" alt="ArrayList继承关系"></p>
	
	</div>
  <a type="button" href="/2015/06/03/Java集合源码剖析之ArrayList/#more" class="btn btn-default more">Read More</a>
</div>

           
		
           
			  
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2015-05-14 </div>
			<div class="article-title"><a href="/2015/05/14/Java集合源码剖析之核心接口/">Java集合源码剖析之核心接口</a></div>						
		</h3>
	


			  <div class="entry">
  <div class="row">
	
	
		<p>此为 <a href="http://houqian.xyz/2015/06/04/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%9B%AE%E5%BD%95/">Java集合源码剖析</a>系列的一部分</p>
<h1 id="背景"><a class="header-anchor" href="#背景"></a>背景</h1>
<p>最近把Javadoc精读了一遍，发现许多概念和自己印象里的不一致（记忆掺杂了各种想当然的假设，以及容易受到各种其他因素的干扰，因此和事实会产生许多不一致）。还是很有必要将其系统的梳理一下的，魔鬼在细节，虽然有点儿枯燥，但花些功夫矫正偏差是很有必要的。</p>
<h1 id="引言"><a class="header-anchor" href="#引言"></a>引言</h1>
<p>Java集合位于java.util包下，主要分为两大类：字典、线性表。其核心接口如下：</p>
<p><img src="/2015/05/14/Java集合源码剖析之核心接口/Java%E9%9B%86%E5%90%88%E6%A0%B8%E5%BF%83%E6%8E%A5%E5%8F%A3-9580177.svg" alt="Java集合核心接口"></p>
	
	</div>
  <a type="button" href="/2015/05/14/Java集合源码剖析之核心接口/#more" class="btn btn-default more">Read More</a>
</div>

           
		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">
<ul class="pagination">
	 
		
    	<li class="prev"><a href="/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i> Prev</a></li>
  		

        <li><a href="/"><i class="fa fa-home"></i>Home</a></li>

		
          <li class="next disabled"><a>Next<i class="fa fa-arrow-circle-o-right"></i></a></li>
        
	
</ul>
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			
  <div id="site_search">
   <div class="form-group">
    <input type="text" id="local-search-input" name="q" results="0" placeholder="Search" class="st-search-input st-default-search-input form-control">
   </div>  
  <div id="local-search-result"></div>
  </div>


		
			<div class="widget">
    
</div>

		
			
	<div class="widget">
		<h4>Categories</h4>
		<ul class="tag_box inline list-unstyled">
		
			<li><a href="/categories/APM/">APM<span>1</span></a></li>
		
			<li><a href="/categories/JVM/">JVM<span>2</span></a></li>
		
			<li><a href="/categories/Linux/">Linux<span>1</span></a></li>
		
			<li><a href="/categories/业务场景/">业务场景<span>1</span></a></li>
		
			<li><a href="/categories/机器学习/">机器学习<span>5</span></a></li>
		
			<li><a href="/categories/源码剖析/">源码剖析<span>3</span></a></li>
		
			<li><a href="/categories/论文/">论文<span>1</span></a></li>
		
			<li><a href="/categories/设计/">设计<span>1</span></a></li>
		
			<li><a href="/categories/读书笔记/">读书笔记<span>1</span></a></li>
		
		</ul>
	</div>

		
			
	<div class="widget">
		<h4>Tag Cloud</h4>
		<ul class="tag_box inline list-unstyled">		
		
			<li><a href="/tags/Java性能监控/">Java性能监控<span>1</span></a></li>
		
			<li><a href="/tags/deploy/">deploy<span>5</span></a></li>
		
			<li><a href="/tags/通知推送/">通知推送<span>1</span></a></li>
		
			<li><a href="/tags/并发/">并发<span>1</span></a></li>
		
			<li><a href="/tags/AQS/">AQS<span>1</span></a></li>
		
			<li><a href="/tags/架构模式/">架构模式<span>1</span></a></li>
		
			<li><a href="/tags/内存模型/">内存模型<span>2</span></a></li>
		
			<li><a href="/tags/故障分析/">故障分析<span>1</span></a></li>
		
			<li><a href="/tags/shell/">shell<span>1</span></a></li>
		
			<li><a href="/tags/Java集合/">Java集合<span>3</span></a></li>
		
			<li><a href="/tags/轮询算法/">轮询算法<span>1</span></a></li>
		
		 
		</ul>
	</div>


		
			
<div class="widget">
  <h4>Recent Posts</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2019/06/01/一张图澄清架构设计模式/"><i class="fa fa-file-o"></i>一张图澄清架构设计模式</a>
      </li>
    
      <li>
        <a href="/2019/02/06/JVM入门/"><i class="fa fa-file-o"></i>JVM入门</a>
      </li>
    
      <li>
        <a href="/2018/08/30/调用模型/"><i class="fa fa-file-o"></i>调用模型</a>
      </li>
    
      <li>
        <a href="/2018/08/30/加载模型文件/"><i class="fa fa-file-o"></i>加载模型文件</a>
      </li>
    
      <li>
        <a href="/2018/08/30/sparkml导出jpmml/"><i class="fa fa-file-o"></i>SparkML 导出 JPMML</a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>Links</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="fa fa-github"></i><a href="https://github.com/houqian" title="" target="_blank" ]);"="">Github</a></li>
	
	</ul>
</div>


		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->


	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2019 Hou Qian
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.    
</p> </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>


<!-- syntax highlighting -->


</body>
   </html>
