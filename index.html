<!-- build time:Wed Jul 03 2019 14:05:12 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><link rel="stylesheet" href="/lib/fancybox/source/jquery.fancybox.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0"><link rel="stylesheet" href="/css/main.css?v=7.1.2"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.2"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.2"><link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"7.1.2",sidebar:{position:"left",display:"always",offset:12,onmobile:!1,dimmer:!1},back2top:!0,back2top_sidebar:!1,fancybox:!0,fastclick:!0,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta property="og:type" content="website"><meta property="og:title" content="且听风吟"><meta property="og:url" content="http://houqian.xyz/index.html"><meta property="og:site_name" content="且听风吟"><meta property="og:locale" content="zh-CN"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="且听风吟"><link rel="canonical" href="http://houqian.xyz/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>且听风吟</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?9b25ec9db5ebea33bd171d5411faa5c1";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-home"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">且听风吟</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">647 号小宇宙</h1></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home menu-item-active"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-wiki"><a href="/wiki" rel="section"><i class="menu-item-icon fa fa-fw fa-pencil"></i><br>WikiNotes</a></li><li class="menu-item menu-item-series"><a href="/series" rel="section"><i class="menu-item-icon fa fa-fw fa-align-left"></i><br>系列</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><section id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://houqian.xyz/2019/06/01/一张图澄清架构设计模式/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="侯乾"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="且听风吟"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2019/06/01/一张图澄清架构设计模式/" class="post-title-link" itemprop="url">一张图澄清架构设计模式</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-06-01 22:29:20" itemprop="dateCreated datePublished" datetime="2019-06-01T22:29:20+08:00">2019-06-01</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/计算机科学与技术/" itemprop="url" rel="index"><span itemprop="name">计算机科学与技术</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span title="本文字数">0</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">1 分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="/2019/06/01/一张图澄清架构设计模式/%E4%B8%80%E5%BC%A0%E5%9B%BE%E6%BE%84%E6%B8%85%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.svg" alt="一张图澄清架构设计模式"></p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://houqian.xyz/2019/05/12/聊聊消息队列/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="侯乾"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="且听风吟"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2019/05/12/聊聊消息队列/" class="post-title-link" itemprop="url">聊聊消息队列</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-05-12 19:21:51" itemprop="dateCreated datePublished" datetime="2019-05-12T19:21:51+08:00">2019-05-12</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/计算机科学与技术/" itemprop="url" rel="index"><span itemprop="name">计算机科学与技术</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span title="本文字数">6.5k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">12 分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="背景"><a class="header-anchor" href="#背景"></a>背景</h2><p>看到 infoq 上这篇不错的<a href="https://www.infoq.cn/article/s*RvY8D1jrNIsfOJylPE" target="_blank" rel="noopener">消息队列文章</a>，作者是某大厂基础设施开发工程师，个人觉得总结的不错，记录一下。</p><h2 id="三种常见消息协议"><a class="header-anchor" href="#三种常见消息协议"></a>三种常见消息协议</h2><h3 id="jms"><a class="header-anchor" href="#jms"></a>JMS</h3><p>全称 Java Message Service。JMS 本质上是 Java API。在 JMS 中定义了 Producer，Consumer，Provider 三种角色，Producer 作为消息的发送方，Consumer 作为消息的接收方，Provider 作为服务的提供者，Producer 和 Consumer 统称为 Client。JMS 定义了点对点和发布订阅两种消息模型，发布订阅模型中，通过 topic 对消息进行路由，生产者可以将消息发到指定的 topic，消费者订阅这个 topic 即可收到生产者发送的消息。一个生产者可以向一个或多个 topic 中发送消息，一个消费者也可以消费一个或多个 topic 中的消息，一个 topic 也可以有多个生产者或消费者，生产者和消费者只需要关联 topic，而不用关心这消息由谁发送或者消费。 Provider 为每一个 topic 维护一个或多个 queue 来保存消息，消息在 queue 中是有序的，遵循先进先出的原则，不同 queue 间的消息是无序的。点对点模式中没有 topic 的概念，生产者直接将消息发送到指定 queue，消费者也指定 queue 进行消费，消息只能被一个消费者消费，不可以被多个消费者消费。Kafka 部分实现了 JMS 协议。</p><h3 id="amqp"><a class="header-anchor" href="#amqp"></a>AMQP</h3><p>全称 Advanced Message Queuing Protocol。与 JMS 不同，AMQP 是一个应用层的网络传输协议，对报文格式进行定义，与开发语言无关。在 AMQP 中同样有生产者，消费者两种角色，消息也是保存在 queue 中的。 但不同于 JMS 用 topic 对消息进行路由，AMQP 的路由方式由 exchange 和 binding 决定。 client 可以创建 queue，并在创建 queue 的同时通知 exchange 这个 queue 接受符合什么条件的消息，这个条件即为 Bingding key。生产者发送消息到 exchange 的时候会指定一个 router key，exchange 收到消息后会与自己所维护的 Bingding key 做比较，发送到符合条件的 queue 中。消费者在消费时指定 queue 进行消费。RabbitMQ 实现了 AMQP 协议。</p><h3 id="mqtt"><a class="header-anchor" href="#mqtt"></a>MQTT</h3><p>全称 Message Queuing Telemetry Transport。MQTT 协议是一种基于发布订阅的轻量级协议，支持 TCP 和 UDP 两种连接方式，主要应用于即时通讯，小型设备，移动应用等领域。 MQTT 中有发布者（Publish），订阅者（Subscribe）和代理服务器（Broker）三种角色。Broker 是服务的提供者，发布者和前两种协议中的生产者相同，将消息（Message）发送到 Broker，Subscribe 从 Broker 中获取消息并做业务处理。MQTT 的 Message 中固定消息头（Fixed header）仅有 2 字节，开销极小，除此之外分为可变头（Variable header）和消息体（payload）两部分。固定头中包含消息类型，消息级别，变长头的大小以及消息体的总长度等信息。 变长头则根据消息类别，含有不同的标识信息。 MQTT 允许客户端动态的创建主题，发布者与服务端建立会话（session）后，可以通过 Publish 方法发送数据到服务端的对应主题，订阅者通过 Subscribe 订阅主题后，服务端就会将主题中的消息推送给对应的订阅者。</p><h2 id="系统解耦"><a class="header-anchor" href="#系统解耦"></a>系统解耦</h2><p>一般来说，系统间如果需要通信，除了正常情况下的消息传递外，还要考虑下游系统处理异常，上游系统如何处理？系统宕机的情况下会不会导致数据丢失？当有业务数据异常时，如何去定位是上游系统发送出了问题还是下游系统的问题？如果需要同时将信息发送给多个下游系统，其中一个处理有问题会不会导致其它系统受影响？而 MQ 可以让这些问题变得简单。</p><h2 id="推-拉两种模式"><a class="header-anchor" href="#推-拉两种模式"></a>推 / 拉两种模式</h2><p>在消费中，一般有推消息和拉消息两种模式。推模式即服务端收到消息后，主动将消息推送给消费者，由消费者进行处理，这种模式具有更高的实时性，但是由于服务端不能准确评估消费端的消费性能，所以有可能造成消息推送过多使客户端来不及处理收到的消息； 拉模式则是服务端收到消息后将消息保存在服务端，被动的等待客户端来拉取消息，这种模式下客户端可以根据自己的处理能力来决定拉消息的频率，但是缺点就是消息处理可能有延迟，不过可以通过长轮询的方式来提高实时性。</p><h2 id="三种消息级别"><a class="header-anchor" href="#三种消息级别"></a>三种消息级别</h2><p>消息传递过程中，会有各种异常导致消息不能正常发送，这时候，我们有以下三种选择：</p><ul><li>下游允许部分消息丢失，不进行处理，这种方式一般适用于监控信息和 log 的传递，少一两条影响不大，称为至多一次（Qos=0）；</li><li>还有一种是消息必须全部送达，不允许任何消息丢失，但是可以接受部分消息重复，这种我们称为至少一次（Qos=1），此种方式一般适用于订单，支付等场景（当然，这要求下游系统实现去重或幂等）；</li><li>还有一种最严格的要求，就是消息只能送达一次，不能多也不能少，这种我们称为正好一次（Qos=2）。</li></ul><p>这三种方式又分别是如何实现的呢？</p><h3 id="至多一次的实现"><a class="header-anchor" href="#至多一次的实现"></a>至多一次的实现</h3><p>要实现至多一次并不难，生产者只需要异步发送，在发送失败或者消费失败的时候不做任何处理即可。MQ 在消费者拉走消息后，就直接将消息标记为已经消费或者删除消息。在监控系统和日志系统中，丢失部分信息是可以接受的，但显然，电商系统，金融系统等大部分业务，是不允许出现消息丢失这种情况的，需要保证消息一定会送达到消费者。</p><h3 id="至少一次的实现"><a class="header-anchor" href="#至少一次的实现"></a>至少一次的实现</h3><p>至少一次的实现一般如下：生产者发消息到 MQ，MQ 收到消息后返回确认信息（ACK）给生产者，生产者收到确认信息后生产过程完成，如果在一定时间内，生产者没有收到确认信息，生产者重新发送消息。 重新发送的过程可以是立即发送，也可以将处理异常的消息持久化，比如保存到数据库中，然后定时重试知道成功。同样，消费者从 MQ 获取到消息后，当业务逻辑处理完成，向 MQ 返回 ACK 信息。 但是存在下面一种情况，当 MQ 收到消息并发送 ACK，或者消费者消费完成发送 ACK 信息之后，由于网络，系统故障等问题，ACK 信息没有成功送达，就会导致消息重复发送。 对于大部分消息队列的实现来说（如 kafka，RocketMQ）对于消息重复的处理方式，就是不处理，交由消费者根据业务逻辑自己实现去重或幂等。消费者根据业务逻辑自己实现去重或幂等。消费者根据业务逻辑自己实现去重或幂等。 重要的事情说三遍。有些人或许会觉得这是常识和基本素养，但也有部分同学过于相信 MQ 系统和网络环境的稳定性，不做去重导致业务出现问题，比如优惠卷系统没有做去重处理，本来只能领取一张的优惠卷，结果给用户发了多张。</p><h3 id="正好一次的实现"><a class="header-anchor" href="#正好一次的实现"></a>正好一次的实现</h3><p>如果要实现正好一次的消息级别，每次消息传递过程正需要四次通信，过程如下： 发送端发消息给接收端，接收端收到消息后持久化保存消息 ID 并返回 REC 信息给发送端，通知生产端我已经收到这个消息了。 这时消息是一种中间态，接受端不会进行业务逻辑的处理。这个过程中，如果 REC 消息丢失，服务端重传了消息， 接受端接受到消息后会和本地保存到消息 ID 做对比，如果重复，就丢弃消息不做处理，避免消息被处理多次，而且消息 ID 会持久化到硬盘，防止因为断电内存中数据丢失倒是消息被重复处理。 发送端收到接收端返回的 rec 消息后，发送一个 rel 请求给消费端，告诉消费端我确认收到了你的确认消息，接收端收到 rel 请求后才会进行具体的业务逻辑处理，并返回 comp 信息给发送端，同时在本地删除保存的消息 ID。如果发送端没有收到 comp 信息，会重发 rel 请求而不会重发消息。</p><p>以上，就是正好一次的实现过程。如果你没看懂，那就再看一遍，如果还是没看懂，那也没关系，至少，你知道这玩意实现起来很复杂就好了。也就明白了为什么大部分消息中间件一般只保证至少一次，去重的过程交给消费者自己处理了。 毕竟对于大多数场景，吞吐量才是首要指标。 那么，什么场景下，需要保证正好一次呢？ 答案是物联网。 而标准的实现协议，是 MQTT。 因为物联网场景下，大部分终端是嵌入式系统，处理能力会比服务器低很多，所以服务端需要帮助终端实现去重，简化终端的业务逻辑。</p><h2 id="数据的可靠性"><a class="header-anchor" href="#数据的可靠性"></a>数据的可靠性</h2><p>生产者将消息发到消息队列的 Broker 之后，如果 Broker 只将消息保存在内存中，那当服务器断电或各种原因导致宕机时， 还没有被消费的消息将会丢失。 为了解决这个问题，可以选择将数据持久化到硬盘，这样当机器故障恢复后数据还在，消费者可以继续消费之前没有消费完的数据。但是，如果仅仅持久化到硬盘，当服务器发生磁盘故障，Raid 卡故障时，数据依然存在丢失的风险。 为了解决这个问题，绝大多数消息队列的实现都引入了复制 / 多副本的概念，将每份数据都保存在多台服务器上，而且一般这些服务器还要尽可能多实现跨机架甚至跨数据中心。 复制可以是同步的也可以是异步的，可以是一主一从，也可以是一主多从，也可以基于 Raft，Paxos 等算法实现多副本。</p><p>不管是持久化还是复制，在保证数据可靠性的同时，都必然会带来一部分性能的损耗，所以不同的消息队列实现根据自己的定位，会选择不同的复制的实现方式以及持久化时的文件结构。</p><h2 id="消息队列的高级特性"><a class="header-anchor" href="#消息队列的高级特性"></a>消息队列的高级特性</h2><h3 id="顺序消息"><a class="header-anchor" href="#顺序消息"></a>顺序消息</h3><p>一般情况下，因为消息分布在不同的 Broker 上，且有多个客户端同时消费，各实例间的网络状态和处理能力都是不一定的，所以分布式消息系统是没有办法保证消息的处理顺序的。但如果你了解了一般消息队列的文件结构，你就会发现不管是 Kafka 的 partition 那种方式，还是 RocketMQ 的方式，都可以保证同一个 partition 或者同一个 ConsumerQueue 内的消息是可以保证顺序的。剩下的，我们需要做的就是将需要保证顺序的消息放入到同一个 partiton 或者 queue 中就好了， 最简单的方式是我们只为主题分配一个 partition 或者 queue，这样就可以保证严格的顺序，但是这样就不能体现分布式系统的性能优势了，集群的处理能力没有办法横向扩展。</p><p>在实际的生产中，大多数情况下我们其实并不需要所有的消息都顺序处理，更多时候只要求具有相同特征的消息保证顺序，如电商系统中，一般要求具有相同订单号的消息需要保证顺序，不同的订单之间可以乱序，也就是说我们只要保证有办法将具有相同订单编号的消息放入到同一个队列或者 partition 中即可。</p><p>Kafka 提供了指定 partition 发送的功能，使用者可以在客户端根据业务逻辑自行处理，还有的消息队列支持根据某个字段的值，将消息 hash 到消息指定消息队列中。 指定 partition 和 hash 两种方式的主要区别，就是当有某个分片故障时，指定 partition 的方式会导致部分消息发送失败，而 hash 的方式有可能造成少量消息的乱序。</p><h3 id="事务消息"><a class="header-anchor" href="#事务消息"></a>事务消息</h3><p>事务消息主要指消息生产过程中，需要确保发送操作和其它业务逻辑处理结果的一致性，要么都成功要么都失败。 比如要同时执行写入 MySQL 数据库和发送消息两种操作，要保证写库成功同时发送消息也成功，如果写库失败，消息也要取消发送。事务消息的实现一般是依赖两步提交策略。 已写库并发消息为例，首先客户端将消息发送到 Broker，Broker 收到消息后，给客户端返回一个确认信息。 这时消息在服务端是处于一种中间状态，消费者不可以消费这种状态的消息。 客户端收到确认消息后，执行写数据库的操作，写库成功后，向 Broker 再发送一个提交信息。 服务端收到提交信息后将消息更改就绪状态，允许消费者正常消费。 同时，生产者客户端还要提供一个回调方法，当 Broker 收到消息后，长时间没有收到确认信息时，调用客户端提供的回调方法进行回滚，如重置数据库。</p><h3 id="消息回放"><a class="header-anchor" href="#消息回放"></a>消息回放</h3><p>有时，消费者可能会因为系统问题或其它原因，需要重新消费已经消费完的消息。大部分消息队列都可以实现这个功能，一般将次功能称为消息回放。要实现消息回放的功能，需要保证消息不会在消费成功之后立刻删除，而是保存一段时间后，根据一定策略，如一周后删除。同时，还需要对消费者当前消费的消费位置进行记录，Kafka 会通过一个 Offset 文件来记录消费者的消费位置，当消费者消费完成功，更新并提交 Offset。一般来说，Offset 文件中还需要记录最大消费位置，即已经入队的最新一条消息所在的位置和最小消费位置，即还没删除的最老的消息所在的位置。Offset 文件可以保存在服务端，也可以保存在客户端，也可以保存在 ZooKeeper 中，或者其它如 Redis 之类的第三方存储。 早期版本（0.9.0 之前）的 Kafka 是将消息保存在 ZooKeeper 中，之后为了减轻 ZooKeeper 的负担，将 Offset 保存到 Broker 对应的 topic 中。</p><h2 id="影响单机性能的因素"><a class="header-anchor" href="#影响单机性能的因素"></a>影响单机性能的因素</h2><p>Kafka 作为一个优秀的分布式消息系统，当需要服务于有较高高吞吐量要求的服务时，可以通过扩容来解决需求。虽然如此，我们也不应放弃对单机吞吐量的追求，毕竟单机处理能力越高，意味着可以节省更多资源。而决定单机性能的因素，我能想到的主要有下面几个方面：</p><h3 id="硬件层面"><a class="header-anchor" href="#硬件层面"></a>硬件层面</h3><h4 id="硬盘"><a class="header-anchor" href="#硬盘"></a>硬盘</h4><p>一般来说消息队列的瓶颈主要在磁盘 IO，更好的硬盘会带来更高的性能，正常情况性能由高到低排序为 NVMe &gt; 传统 SSD（Non-Volatile Memory express） &gt;SAS &gt;SATA。 对于 SAS 盘和 SATA 盘这种机械硬盘来说，还要看具体硬盘的转速。</p><h4 id="raid-卡"><a class="header-anchor" href="#raid-卡"></a>Raid 卡</h4><p>Raid 卡的型号和性能，以及是否带有 Raid 卡缓存，Raid 卡的鞋策略是 WriteThough 还是 WriteBack 也会影响到服务的 I/O 性能进而影响到吞吐量。</p><h3 id="系统层面"><a class="header-anchor" href="#系统层面"></a>系统层面</h3><h4 id="raid-级别"><a class="header-anchor" href="#raid-级别"></a>Raid 级别</h4><p>当有 4 块盘时，Raid0，Raid5 和 Raid10 三种形式的 Raid 会对 I/O 性能造成不同的影响。Raid0 因为不需要任何其它操作，速度是最快的，几乎等于单盘写速度的四倍。Raid10 需要写一份数据和一份镜像，写性能是略小于单盘写速度的两倍的；Raid5 可以有三个盘提供写服务，另一个盘来存放校验和，由于计算校验和存在一定的性能损耗，写速度略小于单盘写速度的三倍，而且随着硬盘数量的增多，Raid5 计算校验和造成的开销会随之增大，如果没有 Raid 卡缓存支撑的话，在磁盘数量超过一定值后，性能是低于 Raid10 的。</p><h4 id="linux-i-o-调度算法"><a class="header-anchor" href="#linux-i-o-调度算法"></a>Linux I/O 调度算法</h4><p>Linux 内核包含 Noop，Deadline，CFG, Anticipatory 四种 I/O 调度算法，需要结合应用特性和硬件选择合适的调度算法。 据说 SSD 硬盘更适合使用 Noop 算法。</p><h4 id="文件系统的-block-size"><a class="header-anchor" href="#文件系统的-block-size"></a>文件系统的 block size</h4><p>调整合适的文件系统的 block size 也会提高吞吐量。</p><h4 id="swap-的使用"><a class="header-anchor" href="#swap-的使用"></a>SWAP 的使用</h4><p>SWAP 空间使用过程中会造成一定的 I/O 开销，如果内存充足的情况下，可以关闭 SWAP 功能。</p><h3 id="应用层面"><a class="header-anchor" href="#应用层面"></a>应用层面</h3><h4 id="文件读写的方式"><a class="header-anchor" href="#文件读写的方式"></a>文件读写的方式</h4><p>一般来说，顺序读写速度远高于随机读写，且一次性读写的文件越大相对来说效率越高。应用可以据此来对文件结构和读写方式做一定优化。</p><h4 id="缓存策略"><a class="header-anchor" href="#缓存策略"></a>缓存策略</h4><p>应用可以通过一定的缓存策略，提前将可能用到的数据读到内存中，当收到请求时，如果能命中缓存中的数据，在缓存中直接读取效率远高于读写磁盘。同样，写操作时也可以通过缓存将零散的写操作进行汇集，提高写操作的效率。 所有适合的缓存策略将显著提高 Broker 的处理能力。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://houqian.xyz/2018/08/30/调用模型/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="侯乾"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="且听风吟"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2018/08/30/调用模型/" class="post-title-link" itemprop="url">调用模型</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-08-30 19:02:19" itemprop="dateCreated datePublished" datetime="2018-08-30T19:02:19+08:00">2018-08-30</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/计算机科学与技术/" itemprop="url" rel="index"><span itemprop="name">计算机科学与技术</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span title="本文字数">1.9k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">3 分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><p>提示: 本文是<a href="http://houqian.xyz/2018/08/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/#%E7%AE%97%E6%B3%95%E4%BE%A7">模型部署方案</a>的一部分</p><h1 id="依赖"><a class="header-anchor" href="#依赖"></a>依赖</h1><ul><li>java8</li><li>pmml-evaluator 1.4.2</li><li>pmml-evaluator-extension 1.4.2</li></ul><h1 id="步骤"><a class="header-anchor" href="#步骤"></a>步骤</h1><ol><li><p>使用JPMML执行引擎反序列化pmml文件</p></li><li><p>模型校验（此处具体校验的问题，笔者以后另开一篇）</p></li></ol><div class="post-button text-center"><a class="btn" href="/2018/08/30/调用模型/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://houqian.xyz/2018/08/30/加载模型文件/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="侯乾"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="且听风吟"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2018/08/30/加载模型文件/" class="post-title-link" itemprop="url">加载模型文件</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-08-30 18:11:21" itemprop="dateCreated datePublished" datetime="2018-08-30T18:11:21+08:00">2018-08-30</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/计算机科学与技术/" itemprop="url" rel="index"><span itemprop="name">计算机科学与技术</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span title="本文字数">2.2k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">4 分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><p>提示: 本文是<a href="http://houqian.xyz/2018/08/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/#%E7%AE%97%E6%B3%95%E4%BE%A7">模型部署方案</a>的一部分</p><h1 id="依赖"><a class="header-anchor" href="#依赖"></a>依赖</h1><ul><li>java8</li><li>pmml-model 1.4.2</li></ul><h1 id="步骤"><a class="header-anchor" href="#步骤"></a>步骤</h1><ol><li>加载反序列化模型文件为PMML对象</li><li>优化模型，并写到新模型文件</li></ol><div class="post-button text-center"><a class="btn" href="/2018/08/30/加载模型文件/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://houqian.xyz/2018/08/30/sparkml导出jpmml/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="侯乾"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="且听风吟"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2018/08/30/sparkml导出jpmml/" class="post-title-link" itemprop="url">SparkML 导出 JPMML</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-08-30 16:07:13" itemprop="dateCreated datePublished" datetime="2018-08-30T16:07:13+08:00">2018-08-30</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/计算机科学与技术/" itemprop="url" rel="index"><span itemprop="name">计算机科学与技术</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span title="本文字数">9.2k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">17 分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><p>提示: 本文是<a href="http://houqian.xyz/2018/08/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/#%E7%AE%97%E6%B3%95%E4%BE%A7">模型部署方案</a>的一部分</p><h1 id="依赖"><a class="header-anchor" href="#依赖"></a>依赖</h1><ul><li>spark 2.2</li><li>jpmml-sparkml 1.3.8</li><li>scala 2.11</li></ul><h1 id="步骤"><a class="header-anchor" href="#步骤"></a>步骤</h1><ol><li>使用spark ml训练一个决策树模型</li><li>在控制台验证可以输出后，写到文件中</li></ol><div class="post-button text-center"><a class="btn" href="/2018/08/30/sparkml导出jpmml/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://houqian.xyz/2018/08/30/sklearn导出jpmml/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="侯乾"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="且听风吟"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2018/08/30/sklearn导出jpmml/" class="post-title-link" itemprop="url">scikit-learn 导出 JPMML</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-08-30 13:01:16" itemprop="dateCreated datePublished" datetime="2018-08-30T13:01:16+08:00">2018-08-30</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/计算机科学与技术/" itemprop="url" rel="index"><span itemprop="name">计算机科学与技术</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span title="本文字数">2k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">4 分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><p>提示: 本文是<a href="http://houqian.xyz/2018/08/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/#%E7%AE%97%E6%B3%95%E4%BE%A7">模型部署方案</a>的一部分</p><h1 id="依赖"><a class="header-anchor" href="#依赖"></a>依赖</h1><ul><li>Python 2.7, 3.4 or newer.</li><li><a href="https://pypi.python.org/pypi/scikit-learn" target="_blank" rel="noopener"><code>scikit-learn</code></a> 0.16.0 or newer.</li><li><a href="https://pypi.python.org/pypi/sklearn-pandas" target="_blank" rel="noopener"><code>sklearn-pandas</code></a> 0.0.10 or newer.</li><li><a href="https://github.com/jpmml/sklearn2pmml" target="_blank" rel="noopener"><code>sklearn2pmml</code></a> 0.14.0 or newer.</li></ul><h1 id="步骤"><a class="header-anchor" href="#步骤"></a>步骤</h1><ol><li>使用sklearn训练一个模型</li><li>使用sklearn原生API将模型到处为 <code>pickle</code> 格式</li><li>使用 JPMML-SkLearn命令将原始<code>pickle</code> 格式文件转换成JPMML文件</li></ol><div class="post-button text-center"><a class="btn" href="/2018/08/30/sklearn导出jpmml/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://houqian.xyz/2018/08/29/机器学习模型部署方案/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="侯乾"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="且听风吟"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2018/08/29/机器学习模型部署方案/" class="post-title-link" itemprop="url">机器学习模型部署方案</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-08-29 15:26:48" itemprop="dateCreated datePublished" datetime="2018-08-29T15:26:48+08:00">2018-08-29</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/计算机科学与技术/" itemprop="url" rel="index"><span itemprop="name">计算机科学与技术</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span title="本文字数">2.1k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">4 分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="背景"><a class="header-anchor" href="#背景"></a>背景</h1><p>目前，我们组反欺诈业务已经进行到了较为后期的阶段，初步有了基础的数据平台、计算平台。此时，算法同事也升级了过往基于统计分布的简单算法实现，而采用了更为强大的机器学习模型，目前已知的将会使用以下几类算法：离群点检测算法、树类算法等（笔者仅了解常见算法，描述不准确还望见谅。）</p><h1 id="问题"><a class="header-anchor" href="#问题"></a>问题</h1><p>算法同学日常使用sk-learn或者spark ml居多，其中前者使用python后者使用scala作为日常开发语言。笔者目前所做的属于算法工程化，需要对接线上实时数据流、离线数据实现对算法同学产出的模型的上线。</p><p>目前，已知的其他团队的方案有：</p><ol><li>使用python语言实现backend，并对接实时、离线数据</li><li>使用Java重新实现一遍算法逻辑，然后实现web api，并对接实时、离线数据</li></ol><p>分析一下这两种方案：</p><p>对于1，他们这么做的理由是算法同学自己的工程能力非常强，可以自己用python一站式搞定模型训练、上线，并且他们的业务离线居多，对实时性的要求不高。</p><p>对于2，他们这么做的理由是算法同学工程能力较弱，自己无法搞定一站式。使用线性模型比较多，后端Java同学实现起来还是比较简单的，性能也非常好。</p><p>然而，这两种方案目前看来都不能满足我们组的需求。</p><ul><li>我们的模型比较复杂，用Java实现一遍显的复杂性不可控，验证实现正确性的成本也很高。</li><li>主要是实时、数据量较少的场景，对实时性要求比较高（查询四五个数据源，加上模型逻辑，需要在1秒内给业务方返回）</li><li>希望做到模型的部署和训练接耦，算法同学和后端同学各自专注自己的事情</li></ul><div class="post-button text-center"><a class="btn" href="/2018/08/29/机器学习模型部署方案/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://houqian.xyz/2017/11/22/小议Docker-Docker基础/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="侯乾"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="且听风吟"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/11/22/小议Docker-Docker基础/" class="post-title-link" itemprop="url">小议 Docker：Docker 基础</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2017-11-22 20:11:55" itemprop="dateCreated datePublished" datetime="2017-11-22T20:11:55+08:00">2017-11-22</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/计算机科学与技术/" itemprop="url" rel="index"><span itemprop="name">计算机科学与技术</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span title="本文字数">7.3k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">13 分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><p>Linux 平台是 Docker 原生支持的平台，在 Linux 上使用 Docker 可以得到最佳的用户体验。</p><h2 id="docker-安装"><a class="header-anchor" href="#docker-安装"></a>Docker 安装</h2><p>Docker 是一个轻量级虚拟化技术，它具备传统虚拟机无可比拟的优势。它更简易的安装和使用方式、更快的速度、服务集成与开发流程自动化，都使Docker 被广大技术爱好者青睐。</p><h3 id="安装-docker-的基本要求"><a class="header-anchor" href="#安装-docker-的基本要求"></a>安装 Docker 的基本要求</h3><ul><li>Docker 只支持 64 位 CPU 架构的计算机，目前不支持 32 位 CPU</li><li>建议系统的 Linux 内核版本为 3.10 及以上</li><li>Linux 需开启 cgroups 和 namespace 功能</li></ul><h2 id="docker-操作参数解读"><a class="header-anchor" href="#docker-操作参数解读"></a>Docker 操作参数解读</h2><p>Docker 的命令行工具是我们日常使用的重点，本节将有选择的介绍其部分功能。为了了解命令行工具的概括，我们可以使用 <code>docker</code> 命令或<code>docker help</code>命令来获取 Docker 的命令清单。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker</span><br><span class="line"></span><br><span class="line">Usage:	docker [OPTIONS] COMMAND</span><br><span class="line">......</span><br><span class="line">  unpause     Unpause all processes within one or more containers</span><br><span class="line">  update      Update configuration of one or more containers</span><br><span class="line">  version     Show the Docker version information</span><br><span class="line">  wait        Block until one or more containers stop, then print their exit codes</span><br><span class="line"></span><br><span class="line">Run 'docker COMMAND --help' for more information on a command.</span><br></pre></td></tr></table></figure><p>随着 Docker 的不断发展，docker 的子命令已经达到 41 个，其中核心子命令还有复杂的可选执行参数。对于每一个特定的子命令，用户可以使用 <code>docker COMMNAD —help</code>命令来查看该子命令的详细信息，包括子命令的使用方法及可用的操作参数。以下这个例子使用<code>docker start --help</code>命令获取子命令 start 的详细信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker start --help</span><br><span class="line"></span><br><span class="line">Usage:	docker start [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line"></span><br><span class="line">Start one or more stopped containers</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -a, --attach                  Attach STDOUT/STDERR and forward signals</span><br><span class="line">      --checkpoint string       Restore from this checkpoint</span><br><span class="line">      --checkpoint-dir string   Use a custom checkpoint storage directory</span><br><span class="line">      --detach-keys string      Override the key sequence for detaching a</span><br><span class="line">                                container</span><br><span class="line">  -i, --interactive             Attach container's STDIN</span><br></pre></td></tr></table></figure><p>下面是根据命令的用途对其进行分类：</p><table><thead><tr><th>子命令分类</th><th>子命令</th></tr></thead><tbody><tr><td>Docker 环境信息</td><td>info、version</td></tr><tr><td>容器生命周期管理</td><td>create、exec、kill、pause、restart、rm、run、start、stop、unpause</td></tr><tr><td>镜像仓库命令</td><td>login、logout、pull、push、search</td></tr><tr><td>镜像管理</td><td>build、images、import、load、rmi、save、tag、commit</td></tr><tr><td>容器运维操作</td><td>attach、export、inspect、port、ps、rename、stats、top、wait、cp、diff、update</td></tr><tr><td>容器资源管理</td><td>volume、network</td></tr><tr><td>系统日志信息</td><td>events、history、logs</td></tr></tbody></table><div class="post-button text-center"><a class="btn" href="/2017/11/22/小议Docker-Docker基础/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://houqian.xyz/2017/11/02/小议Docker-容器和容器云/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="侯乾"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="且听风吟"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/11/02/小议Docker-容器和容器云/" class="post-title-link" itemprop="url">小议 Docker：容器、容器云</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2017-11-02 19:26:53" itemprop="dateCreated datePublished" datetime="2017-11-02T19:26:53+08:00">2017-11-02</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/计算机科学与技术/" itemprop="url" rel="index"><span itemprop="name">计算机科学与技术</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span title="本文字数">3.4k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">6 分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><p>从 2013 年发布至今，Docker 一直保持着旺盛的生命力。Docker 选择容器作为核心和基础，依靠容器技术支撑的 Docker 迅速成为国内外各大云计算厂商和开发者手中的至宝。</p><h2 id="云计算平台"><a class="header-anchor" href="#云计算平台"></a>云计算平台</h2><p>云计算时代蕴育出了众多的云计算平台，虽然在服务类型后平台功能上有所差异，但他们的本质上如出一辙，都与 NIST 对于云计算平台的定义有着密切的关系。</p><blockquote><p>云计算是一种资源服务模式，能便捷按需地将资源（网络、服务器、存储、应用及服务）快速供应并释放。</p></blockquote><p>经典云计算架构包括 IaaS（Infrastructure as a Service，基础设施即服务）、PaaS（Platform as a Service，平台即服务）、SaaS（Software as a Service， 软件即服务）三层。</p><p><img src="/2017/11/02/小议Docker-容器和容器云/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%88%86%E5%B1%82.jpg" alt="云计算分层"></p><ul><li>IaaS 层为基础设施运维人员服务，提供计算、存储、网络及其他基础资源，云平台使用者可以在上面部署和运行包括操作系统和应用程序在内的任意软件，无需再为基础设施的管理而分心。</li><li>PaaS 层为应用开发人员服务，提供支撑应用运行所需的软件运行环境、相关工具与服务，如数据库服务、日志服务、监控服务、服务发现等，让应用开发者可以专注于核心业务的开发。</li><li>SaaS 层为一般用户服务，提供了一套完整可用的软件系统，让一般用户无需关注技术细节，只需要通过浏览器、应用客户端等方式就能使用部署在云上的应用服务。</li></ul><div class="post-button text-center"><a class="btn" href="/2017/11/02/小议Docker-容器和容器云/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://houqian.xyz/2017/08/29/监控调研/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="侯乾"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="且听风吟"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/08/29/监控调研/" class="post-title-link" itemprop="url">监控调研</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2017-08-29 15:37:38" itemprop="dateCreated datePublished" datetime="2017-08-29T15:37:38+08:00">2017-08-29</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/计算机科学与技术/" itemprop="url" rel="index"><span itemprop="name">计算机科学与技术</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span title="本文字数">452</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">1 分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><h3 id="背景"><a class="header-anchor" href="#背景"></a>背景</h3><p>性能压测后，逐个埋点添加各种StopWatch。</p><p><strong>两个缺点：</strong></p><ol><li>侵入了业务逻辑，降低可读性</li><li>耗时，工作量大</li></ol><p><strong>期望：</strong></p><ol><li>【注解】 基于配置或注解可以精确控制要添加性能监控的method或class</li><li>【指标维度全面】监控指标全面，除了常见的QPS、Req Cost Time，还要有TPS, P90, P95 ,P99等指标</li><li>【可视化】最好有图形化的界面可以实时看到各个method的性能状况</li></ol><div class="post-button text-center"><a class="btn" href="/2017/08/29/监控调研/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article></section><nav class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a></nav></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><div class="site-overview-wrap sidebar-panel sidebar-panel-active"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">侯乾</p><div class="site-description motion-element" itemprop="description"></div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">28</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">1</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">26</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/houqian" title="GitHub &rarr; https://github.com/houqian" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a></span></div></div></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2016 – <span itemprop="copyrightYear">2019</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">侯乾</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span title="站点总字数">193k</span></div><div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动</div><span class="post-meta-divider">|</span><div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script src="/lib/jquery/index.js?v=3.4.1"></script><script src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/lib/fancybox/source/jquery.fancybox.pack.js"></script><script src="/js/utils.js?v=7.1.2"></script><script src="/js/motion.js?v=7.1.2"></script><script src="/js/kity.min.js?v=7.1.2"></script><script src="/js/kityminder.core.min.js?v=7.1.2"></script><script src="/js/mindmap.min.js?v=7.1.2"></script><script src="/js/affix.js?v=7.1.2"></script><script src="/js/schemes/pisces.js?v=7.1.2"></script><script src="/js/next-boot.js?v=7.1.2"></script><script>function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var e=$("#local-search-input");e.attr("autocapitalize","none"),e.attr("autocorrect","off"),e.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(e){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(e,t,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:e,dataType:isXml?"xml":"json",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():e,r=document.getElementById(t),s=document.getElementById(o),a=function(){var e=r.value.trim().toLowerCase(),t=e.split(/[\s\-]+/);t.length>1&&t.push(e);var o=[];if(e.length>0&&n.forEach(function(n){function r(t,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===e&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(e,t){var o="",n=t.start;return t.hits.forEach(function(t){o+=e.substring(n,t.position);var r=t.position+t.length;o+='<b class="search-keyword">'+e.substring(t.position,r)+"</b>",n=r}),o+=e.substring(n,t.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url).replace(/\/{2,}/g,"/"),d=[],g=[];if(""!=l&&(t.forEach(function(e){function t(e,t,o){var n=e.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(t=t.toLowerCase(),e=e.toLowerCase());(s=t.indexOf(e,r))>-1;)a.push({position:s,word:e}),r=s+n;return a}d=d.concat(t(e,h,!1)),g=g.concat(t(e,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(e){e.sort(function(e,t){return t.position!==e.position?t.position-e.position:e.word.length-t.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hits.length!==t.hits.length?t.hits.length-e.hits.length:e.start-t.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(e){b+="<a href='"+f+'\'><p class="search-result">'+s(p,e)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===t.length&&""===t[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x"></i></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>';else{o.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hitCount!==t.hitCount?t.hitCount-e.hitCount:t.id-e.id});var a='<ul class="search-result-list">';o.forEach(function(e){a+=e.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(e){e.stopPropagation()}),$(document).on("keyup",function(e){var t=27===e.which&&$(".search-popup").is(":visible");t&&onPopupClose()})</script><script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script><script>pangu.spacingPage()</script><script>$(".highlight").not(".gist .highlight").each(function(t,e){var n=$("<div>").addClass("highlight-wrap");$(e).after(n),n.append($("<button>").addClass("copy-btn").append("复制").on("click",function(t){var e=$(this).parent().find(".code").find(".line").map(function(t,e){return $(e).text()}).toArray().join("\n"),n=document.createElement("textarea"),o=window.pageYOffset||document.documentElement.scrollTop;n.style.top=o+"px",n.style.position="absolute",n.style.opacity="0",n.readOnly=!0,n.value=e,document.body.appendChild(n);const a=document.getSelection(),i=a.rangeCount>0?a.getRangeAt(0):!1;n.select(),n.setSelectionRange(0,e.length),n.readOnly=!1;var l=document.execCommand("copy");l?$(this).text("复制成功"):$(this).text("复制失败"),n.blur(),$(this).blur(),i&&(a.removeAllRanges(),a.addRange(i))})).on("mouseleave",function(t){var e=$(this).find(".copy-btn");setTimeout(function(){e.text("复制")},300)}).append(e)})</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body></html><!-- rebuild by neat -->